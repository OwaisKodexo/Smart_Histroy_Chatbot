"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@apidevtools";
exports.ids = ["vendor-chunks/@apidevtools"];
exports.modules = {

/***/ "(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/bundle.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/bundle.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst ref_js_1 = __importDefault(__webpack_require__(/*! ./ref.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/ref.js\"));\nconst pointer_js_1 = __importDefault(__webpack_require__(/*! ./pointer.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/pointer.js\"));\nconst url = __importStar(__webpack_require__(/*! ./util/url.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/url.js\"));\n/**\n * Bundles all external JSON references into the main JSON schema, thus resulting in a schema that\n * only has *internal* references, not any *external* references.\n * This method mutates the JSON schema object, adding new references and re-mapping existing ones.\n *\n * @param parser\n * @param options\n */\nfunction bundle(parser, options) {\n    // console.log('Bundling $ref pointers in %s', parser.$refs._root$Ref.path);\n    // Build an inventory of all $ref pointers in the JSON Schema\n    const inventory = [];\n    crawl(parser, \"schema\", parser.$refs._root$Ref.path + \"#\", \"#\", 0, inventory, parser.$refs, options);\n    // Remap all $ref pointers\n    remap(inventory);\n}\n/**\n * Recursively crawls the given value, and inventories all JSON references.\n *\n * @param parent - The object containing the value to crawl. If the value is not an object or array, it will be ignored.\n * @param key - The property key of `parent` to be crawled\n * @param path - The full path of the property being crawled, possibly with a JSON Pointer in the hash\n * @param pathFromRoot - The path of the property being crawled, from the schema root\n * @param indirections\n * @param inventory - An array of already-inventoried $ref pointers\n * @param $refs\n * @param options\n */\nfunction crawl(parent, key, path, pathFromRoot, indirections, inventory, $refs, options) {\n    const obj = key === null ? parent : parent[key];\n    if (obj && typeof obj === \"object\" && !ArrayBuffer.isView(obj)) {\n        if (ref_js_1.default.isAllowed$Ref(obj)) {\n            inventory$Ref(parent, key, path, pathFromRoot, indirections, inventory, $refs, options);\n        }\n        else {\n            // Crawl the object in a specific order that's optimized for bundling.\n            // This is important because it determines how `pathFromRoot` gets built,\n            // which later determines which keys get dereferenced and which ones get remapped\n            const keys = Object.keys(obj).sort((a, b) => {\n                // Most people will expect references to be bundled into the the \"definitions\" property,\n                // so we always crawl that property first, if it exists.\n                if (a === \"definitions\") {\n                    return -1;\n                }\n                else if (b === \"definitions\") {\n                    return 1;\n                }\n                else {\n                    // Otherwise, crawl the keys based on their length.\n                    // This produces the shortest possible bundled references\n                    return a.length - b.length;\n                }\n            });\n            for (const key of keys) {\n                const keyPath = pointer_js_1.default.join(path, key);\n                const keyPathFromRoot = pointer_js_1.default.join(pathFromRoot, key);\n                const value = obj[key];\n                if (ref_js_1.default.isAllowed$Ref(value)) {\n                    inventory$Ref(obj, key, path, keyPathFromRoot, indirections, inventory, $refs, options);\n                }\n                else {\n                    crawl(obj, key, keyPath, keyPathFromRoot, indirections, inventory, $refs, options);\n                }\n            }\n        }\n    }\n}\n/**\n * Inventories the given JSON Reference (i.e. records detailed information about it so we can\n * optimize all $refs in the schema), and then crawls the resolved value.\n *\n * @param $refParent - The object that contains a JSON Reference as one of its keys\n * @param $refKey - The key in `$refParent` that is a JSON Reference\n * @param path - The full path of the JSON Reference at `$refKey`, possibly with a JSON Pointer in the hash\n * @param indirections - unknown\n * @param pathFromRoot - The path of the JSON Reference at `$refKey`, from the schema root\n * @param inventory - An array of already-inventoried $ref pointers\n * @param $refs\n * @param options\n */\nfunction inventory$Ref($refParent, $refKey, path, pathFromRoot, indirections, inventory, $refs, options) {\n    const $ref = $refKey === null ? $refParent : $refParent[$refKey];\n    const $refPath = url.resolve(path, $ref.$ref);\n    const pointer = $refs._resolve($refPath, pathFromRoot, options);\n    if (pointer === null) {\n        return;\n    }\n    const parsed = pointer_js_1.default.parse(pathFromRoot);\n    const depth = parsed.length;\n    const file = url.stripHash(pointer.path);\n    const hash = url.getHash(pointer.path);\n    const external = file !== $refs._root$Ref.path;\n    const extended = ref_js_1.default.isExtended$Ref($ref);\n    indirections += pointer.indirections;\n    const existingEntry = findInInventory(inventory, $refParent, $refKey);\n    if (existingEntry) {\n        // This $Ref has already been inventoried, so we don't need to process it again\n        if (depth < existingEntry.depth || indirections < existingEntry.indirections) {\n            removeFromInventory(inventory, existingEntry);\n        }\n        else {\n            return;\n        }\n    }\n    inventory.push({\n        $ref, // The JSON Reference (e.g. {$ref: string})\n        parent: $refParent, // The object that contains this $ref pointer\n        key: $refKey, // The key in `parent` that is the $ref pointer\n        pathFromRoot, // The path to the $ref pointer, from the JSON Schema root\n        depth, // How far from the JSON Schema root is this $ref pointer?\n        file, // The file that the $ref pointer resolves to\n        hash, // The hash within `file` that the $ref pointer resolves to\n        value: pointer.value, // The resolved value of the $ref pointer\n        circular: pointer.circular, // Is this $ref pointer DIRECTLY circular? (i.e. it references itself)\n        extended, // Does this $ref extend its resolved value? (i.e. it has extra properties, in addition to \"$ref\")\n        external, // Does this $ref pointer point to a file other than the main JSON Schema file?\n        indirections, // The number of indirect references that were traversed to resolve the value\n    });\n    // Recursively crawl the resolved value\n    if (!existingEntry || external) {\n        crawl(pointer.value, null, pointer.path, pathFromRoot, indirections + 1, inventory, $refs, options);\n    }\n}\n/**\n * Re-maps every $ref pointer, so that they're all relative to the root of the JSON Schema.\n * Each referenced value is dereferenced EXACTLY ONCE.  All subsequent references to the same\n * value are re-mapped to point to the first reference.\n *\n * @example: {\n *    first: { $ref: somefile.json#/some/part },\n *    second: { $ref: somefile.json#/another/part },\n *    third: { $ref: somefile.json },\n *    fourth: { $ref: somefile.json#/some/part/sub/part }\n *  }\n *\n * In this example, there are four references to the same file, but since the third reference points\n * to the ENTIRE file, that's the only one we need to dereference.  The other three can just be\n * remapped to point inside the third one.\n *\n * On the other hand, if the third reference DIDN'T exist, then the first and second would both need\n * to be dereferenced, since they point to different parts of the file. The fourth reference does NOT\n * need to be dereferenced, because it can be remapped to point inside the first one.\n *\n * @param inventory\n */\nfunction remap(inventory) {\n    // Group & sort all the $ref pointers, so they're in the order that we need to dereference/remap them\n    inventory.sort((a, b) => {\n        if (a.file !== b.file) {\n            // Group all the $refs that point to the same file\n            return a.file < b.file ? -1 : +1;\n        }\n        else if (a.hash !== b.hash) {\n            // Group all the $refs that point to the same part of the file\n            return a.hash < b.hash ? -1 : +1;\n        }\n        else if (a.circular !== b.circular) {\n            // If the $ref points to itself, then sort it higher than other $refs that point to this $ref\n            return a.circular ? -1 : +1;\n        }\n        else if (a.extended !== b.extended) {\n            // If the $ref extends the resolved value, then sort it lower than other $refs that don't extend the value\n            return a.extended ? +1 : -1;\n        }\n        else if (a.indirections !== b.indirections) {\n            // Sort direct references higher than indirect references\n            return a.indirections - b.indirections;\n        }\n        else if (a.depth !== b.depth) {\n            // Sort $refs by how close they are to the JSON Schema root\n            return a.depth - b.depth;\n        }\n        else {\n            // Determine how far each $ref is from the \"definitions\" property.\n            // Most people will expect references to be bundled into the the \"definitions\" property if possible.\n            const aDefinitionsIndex = a.pathFromRoot.lastIndexOf(\"/definitions\");\n            const bDefinitionsIndex = b.pathFromRoot.lastIndexOf(\"/definitions\");\n            if (aDefinitionsIndex !== bDefinitionsIndex) {\n                // Give higher priority to the $ref that's closer to the \"definitions\" property\n                return bDefinitionsIndex - aDefinitionsIndex;\n            }\n            else {\n                // All else is equal, so use the shorter path, which will produce the shortest possible reference\n                return a.pathFromRoot.length - b.pathFromRoot.length;\n            }\n        }\n    });\n    let file, hash, pathFromRoot;\n    for (const entry of inventory) {\n        // console.log('Re-mapping $ref pointer \"%s\" at %s', entry.$ref.$ref, entry.pathFromRoot);\n        if (!entry.external) {\n            // This $ref already resolves to the main JSON Schema file\n            entry.$ref.$ref = entry.hash;\n        }\n        else if (entry.file === file && entry.hash === hash) {\n            // This $ref points to the same value as the prevous $ref, so remap it to the same path\n            entry.$ref.$ref = pathFromRoot;\n        }\n        else if (entry.file === file && entry.hash.indexOf(hash + \"/\") === 0) {\n            // This $ref points to a sub-value of the prevous $ref, so remap it beneath that path\n            entry.$ref.$ref = pointer_js_1.default.join(pathFromRoot, pointer_js_1.default.parse(entry.hash.replace(hash, \"#\")));\n        }\n        else {\n            // We've moved to a new file or new hash\n            file = entry.file;\n            hash = entry.hash;\n            pathFromRoot = entry.pathFromRoot;\n            // This is the first $ref to point to this value, so dereference the value.\n            // Any other $refs that point to the same value will point to this $ref instead\n            entry.$ref = entry.parent[entry.key] = ref_js_1.default.dereference(entry.$ref, entry.value);\n            if (entry.circular) {\n                // This $ref points to itself\n                entry.$ref.$ref = entry.pathFromRoot;\n            }\n        }\n    }\n    // we want to ensure that any $refs that point to another $ref are remapped to point to the final value\n    // let hadChange = true;\n    // while (hadChange) {\n    //   hadChange = false;\n    //   for (const entry of inventory) {\n    //     if (entry.$ref && typeof entry.$ref === \"object\" && \"$ref\" in entry.$ref) {\n    //       const resolved = inventory.find((e: InventoryEntry) => e.pathFromRoot === entry.$ref.$ref);\n    //       if (resolved) {\n    //         const resolvedPointsToAnotherRef =\n    //           resolved.$ref && typeof resolved.$ref === \"object\" && \"$ref\" in resolved.$ref;\n    //         if (resolvedPointsToAnotherRef && entry.$ref.$ref !== resolved.$ref.$ref) {\n    //           // console.log('Re-mapping $ref pointer \"%s\" at %s', entry.$ref.$ref, entry.pathFromRoot);\n    //           entry.$ref.$ref = resolved.$ref.$ref;\n    //           hadChange = true;\n    //         }\n    //       }\n    //     }\n    //   }\n    // }\n}\n/**\n * TODO\n */\nfunction findInInventory(inventory, $refParent, $refKey) {\n    for (const existingEntry of inventory) {\n        if (existingEntry && existingEntry.parent === $refParent && existingEntry.key === $refKey) {\n            return existingEntry;\n        }\n    }\n    return undefined;\n}\nfunction removeFromInventory(inventory, entry) {\n    const index = inventory.indexOf(entry);\n    inventory.splice(index, 1);\n}\nexports[\"default\"] = bundle;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvYnVuZGxlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlDQUFpQyxtQkFBTyxDQUFDLDBGQUFVO0FBQ25ELHFDQUFxQyxtQkFBTyxDQUFDLGtHQUFjO0FBQzNELHlCQUF5QixtQkFBTyxDQUFDLG9HQUFlO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGFBQWE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQ0FBZ0M7QUFDL0MsZ0JBQWdCLG1DQUFtQztBQUNuRCxlQUFlLHFCQUFxQjtBQUNwQyxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2hhdGJvdC11aS8uL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kaXN0L2xpYi9idW5kbGUuanM/MjQ1NyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgcmVmX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcmVmLmpzXCIpKTtcbmNvbnN0IHBvaW50ZXJfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9wb2ludGVyLmpzXCIpKTtcbmNvbnN0IHVybCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi91dGlsL3VybC5qc1wiKSk7XG4vKipcbiAqIEJ1bmRsZXMgYWxsIGV4dGVybmFsIEpTT04gcmVmZXJlbmNlcyBpbnRvIHRoZSBtYWluIEpTT04gc2NoZW1hLCB0aHVzIHJlc3VsdGluZyBpbiBhIHNjaGVtYSB0aGF0XG4gKiBvbmx5IGhhcyAqaW50ZXJuYWwqIHJlZmVyZW5jZXMsIG5vdCBhbnkgKmV4dGVybmFsKiByZWZlcmVuY2VzLlxuICogVGhpcyBtZXRob2QgbXV0YXRlcyB0aGUgSlNPTiBzY2hlbWEgb2JqZWN0LCBhZGRpbmcgbmV3IHJlZmVyZW5jZXMgYW5kIHJlLW1hcHBpbmcgZXhpc3Rpbmcgb25lcy5cbiAqXG4gKiBAcGFyYW0gcGFyc2VyXG4gKiBAcGFyYW0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBidW5kbGUocGFyc2VyLCBvcHRpb25zKSB7XG4gICAgLy8gY29uc29sZS5sb2coJ0J1bmRsaW5nICRyZWYgcG9pbnRlcnMgaW4gJXMnLCBwYXJzZXIuJHJlZnMuX3Jvb3QkUmVmLnBhdGgpO1xuICAgIC8vIEJ1aWxkIGFuIGludmVudG9yeSBvZiBhbGwgJHJlZiBwb2ludGVycyBpbiB0aGUgSlNPTiBTY2hlbWFcbiAgICBjb25zdCBpbnZlbnRvcnkgPSBbXTtcbiAgICBjcmF3bChwYXJzZXIsIFwic2NoZW1hXCIsIHBhcnNlci4kcmVmcy5fcm9vdCRSZWYucGF0aCArIFwiI1wiLCBcIiNcIiwgMCwgaW52ZW50b3J5LCBwYXJzZXIuJHJlZnMsIG9wdGlvbnMpO1xuICAgIC8vIFJlbWFwIGFsbCAkcmVmIHBvaW50ZXJzXG4gICAgcmVtYXAoaW52ZW50b3J5KTtcbn1cbi8qKlxuICogUmVjdXJzaXZlbHkgY3Jhd2xzIHRoZSBnaXZlbiB2YWx1ZSwgYW5kIGludmVudG9yaWVzIGFsbCBKU09OIHJlZmVyZW5jZXMuXG4gKlxuICogQHBhcmFtIHBhcmVudCAtIFRoZSBvYmplY3QgY29udGFpbmluZyB0aGUgdmFsdWUgdG8gY3Jhd2wuIElmIHRoZSB2YWx1ZSBpcyBub3QgYW4gb2JqZWN0IG9yIGFycmF5LCBpdCB3aWxsIGJlIGlnbm9yZWQuXG4gKiBAcGFyYW0ga2V5IC0gVGhlIHByb3BlcnR5IGtleSBvZiBgcGFyZW50YCB0byBiZSBjcmF3bGVkXG4gKiBAcGFyYW0gcGF0aCAtIFRoZSBmdWxsIHBhdGggb2YgdGhlIHByb3BlcnR5IGJlaW5nIGNyYXdsZWQsIHBvc3NpYmx5IHdpdGggYSBKU09OIFBvaW50ZXIgaW4gdGhlIGhhc2hcbiAqIEBwYXJhbSBwYXRoRnJvbVJvb3QgLSBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgYmVpbmcgY3Jhd2xlZCwgZnJvbSB0aGUgc2NoZW1hIHJvb3RcbiAqIEBwYXJhbSBpbmRpcmVjdGlvbnNcbiAqIEBwYXJhbSBpbnZlbnRvcnkgLSBBbiBhcnJheSBvZiBhbHJlYWR5LWludmVudG9yaWVkICRyZWYgcG9pbnRlcnNcbiAqIEBwYXJhbSAkcmVmc1xuICogQHBhcmFtIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gY3Jhd2wocGFyZW50LCBrZXksIHBhdGgsIHBhdGhGcm9tUm9vdCwgaW5kaXJlY3Rpb25zLCBpbnZlbnRvcnksICRyZWZzLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgb2JqID0ga2V5ID09PSBudWxsID8gcGFyZW50IDogcGFyZW50W2tleV07XG4gICAgaWYgKG9iaiAmJiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiICYmICFBcnJheUJ1ZmZlci5pc1ZpZXcob2JqKSkge1xuICAgICAgICBpZiAocmVmX2pzXzEuZGVmYXVsdC5pc0FsbG93ZWQkUmVmKG9iaikpIHtcbiAgICAgICAgICAgIGludmVudG9yeSRSZWYocGFyZW50LCBrZXksIHBhdGgsIHBhdGhGcm9tUm9vdCwgaW5kaXJlY3Rpb25zLCBpbnZlbnRvcnksICRyZWZzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIENyYXdsIHRoZSBvYmplY3QgaW4gYSBzcGVjaWZpYyBvcmRlciB0aGF0J3Mgb3B0aW1pemVkIGZvciBidW5kbGluZy5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IGJlY2F1c2UgaXQgZGV0ZXJtaW5lcyBob3cgYHBhdGhGcm9tUm9vdGAgZ2V0cyBidWlsdCxcbiAgICAgICAgICAgIC8vIHdoaWNoIGxhdGVyIGRldGVybWluZXMgd2hpY2gga2V5cyBnZXQgZGVyZWZlcmVuY2VkIGFuZCB3aGljaCBvbmVzIGdldCByZW1hcHBlZFxuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaikuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgICAgIC8vIE1vc3QgcGVvcGxlIHdpbGwgZXhwZWN0IHJlZmVyZW5jZXMgdG8gYmUgYnVuZGxlZCBpbnRvIHRoZSB0aGUgXCJkZWZpbml0aW9uc1wiIHByb3BlcnR5LFxuICAgICAgICAgICAgICAgIC8vIHNvIHdlIGFsd2F5cyBjcmF3bCB0aGF0IHByb3BlcnR5IGZpcnN0LCBpZiBpdCBleGlzdHMuXG4gICAgICAgICAgICAgICAgaWYgKGEgPT09IFwiZGVmaW5pdGlvbnNcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGIgPT09IFwiZGVmaW5pdGlvbnNcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgY3Jhd2wgdGhlIGtleXMgYmFzZWQgb24gdGhlaXIgbGVuZ3RoLlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHByb2R1Y2VzIHRoZSBzaG9ydGVzdCBwb3NzaWJsZSBidW5kbGVkIHJlZmVyZW5jZXNcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEubGVuZ3RoIC0gYi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5UGF0aCA9IHBvaW50ZXJfanNfMS5kZWZhdWx0LmpvaW4ocGF0aCwga2V5KTtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlQYXRoRnJvbVJvb3QgPSBwb2ludGVyX2pzXzEuZGVmYXVsdC5qb2luKHBhdGhGcm9tUm9vdCwga2V5KTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG9ialtrZXldO1xuICAgICAgICAgICAgICAgIGlmIChyZWZfanNfMS5kZWZhdWx0LmlzQWxsb3dlZCRSZWYodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGludmVudG9yeSRSZWYob2JqLCBrZXksIHBhdGgsIGtleVBhdGhGcm9tUm9vdCwgaW5kaXJlY3Rpb25zLCBpbnZlbnRvcnksICRyZWZzLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNyYXdsKG9iaiwga2V5LCBrZXlQYXRoLCBrZXlQYXRoRnJvbVJvb3QsIGluZGlyZWN0aW9ucywgaW52ZW50b3J5LCAkcmVmcywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBJbnZlbnRvcmllcyB0aGUgZ2l2ZW4gSlNPTiBSZWZlcmVuY2UgKGkuZS4gcmVjb3JkcyBkZXRhaWxlZCBpbmZvcm1hdGlvbiBhYm91dCBpdCBzbyB3ZSBjYW5cbiAqIG9wdGltaXplIGFsbCAkcmVmcyBpbiB0aGUgc2NoZW1hKSwgYW5kIHRoZW4gY3Jhd2xzIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gJHJlZlBhcmVudCAtIFRoZSBvYmplY3QgdGhhdCBjb250YWlucyBhIEpTT04gUmVmZXJlbmNlIGFzIG9uZSBvZiBpdHMga2V5c1xuICogQHBhcmFtICRyZWZLZXkgLSBUaGUga2V5IGluIGAkcmVmUGFyZW50YCB0aGF0IGlzIGEgSlNPTiBSZWZlcmVuY2VcbiAqIEBwYXJhbSBwYXRoIC0gVGhlIGZ1bGwgcGF0aCBvZiB0aGUgSlNPTiBSZWZlcmVuY2UgYXQgYCRyZWZLZXlgLCBwb3NzaWJseSB3aXRoIGEgSlNPTiBQb2ludGVyIGluIHRoZSBoYXNoXG4gKiBAcGFyYW0gaW5kaXJlY3Rpb25zIC0gdW5rbm93blxuICogQHBhcmFtIHBhdGhGcm9tUm9vdCAtIFRoZSBwYXRoIG9mIHRoZSBKU09OIFJlZmVyZW5jZSBhdCBgJHJlZktleWAsIGZyb20gdGhlIHNjaGVtYSByb290XG4gKiBAcGFyYW0gaW52ZW50b3J5IC0gQW4gYXJyYXkgb2YgYWxyZWFkeS1pbnZlbnRvcmllZCAkcmVmIHBvaW50ZXJzXG4gKiBAcGFyYW0gJHJlZnNcbiAqIEBwYXJhbSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGludmVudG9yeSRSZWYoJHJlZlBhcmVudCwgJHJlZktleSwgcGF0aCwgcGF0aEZyb21Sb290LCBpbmRpcmVjdGlvbnMsIGludmVudG9yeSwgJHJlZnMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCAkcmVmID0gJHJlZktleSA9PT0gbnVsbCA/ICRyZWZQYXJlbnQgOiAkcmVmUGFyZW50WyRyZWZLZXldO1xuICAgIGNvbnN0ICRyZWZQYXRoID0gdXJsLnJlc29sdmUocGF0aCwgJHJlZi4kcmVmKTtcbiAgICBjb25zdCBwb2ludGVyID0gJHJlZnMuX3Jlc29sdmUoJHJlZlBhdGgsIHBhdGhGcm9tUm9vdCwgb3B0aW9ucyk7XG4gICAgaWYgKHBvaW50ZXIgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWQgPSBwb2ludGVyX2pzXzEuZGVmYXVsdC5wYXJzZShwYXRoRnJvbVJvb3QpO1xuICAgIGNvbnN0IGRlcHRoID0gcGFyc2VkLmxlbmd0aDtcbiAgICBjb25zdCBmaWxlID0gdXJsLnN0cmlwSGFzaChwb2ludGVyLnBhdGgpO1xuICAgIGNvbnN0IGhhc2ggPSB1cmwuZ2V0SGFzaChwb2ludGVyLnBhdGgpO1xuICAgIGNvbnN0IGV4dGVybmFsID0gZmlsZSAhPT0gJHJlZnMuX3Jvb3QkUmVmLnBhdGg7XG4gICAgY29uc3QgZXh0ZW5kZWQgPSByZWZfanNfMS5kZWZhdWx0LmlzRXh0ZW5kZWQkUmVmKCRyZWYpO1xuICAgIGluZGlyZWN0aW9ucyArPSBwb2ludGVyLmluZGlyZWN0aW9ucztcbiAgICBjb25zdCBleGlzdGluZ0VudHJ5ID0gZmluZEluSW52ZW50b3J5KGludmVudG9yeSwgJHJlZlBhcmVudCwgJHJlZktleSk7XG4gICAgaWYgKGV4aXN0aW5nRW50cnkpIHtcbiAgICAgICAgLy8gVGhpcyAkUmVmIGhhcyBhbHJlYWR5IGJlZW4gaW52ZW50b3JpZWQsIHNvIHdlIGRvbid0IG5lZWQgdG8gcHJvY2VzcyBpdCBhZ2FpblxuICAgICAgICBpZiAoZGVwdGggPCBleGlzdGluZ0VudHJ5LmRlcHRoIHx8IGluZGlyZWN0aW9ucyA8IGV4aXN0aW5nRW50cnkuaW5kaXJlY3Rpb25zKSB7XG4gICAgICAgICAgICByZW1vdmVGcm9tSW52ZW50b3J5KGludmVudG9yeSwgZXhpc3RpbmdFbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW52ZW50b3J5LnB1c2goe1xuICAgICAgICAkcmVmLCAvLyBUaGUgSlNPTiBSZWZlcmVuY2UgKGUuZy4geyRyZWY6IHN0cmluZ30pXG4gICAgICAgIHBhcmVudDogJHJlZlBhcmVudCwgLy8gVGhlIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoaXMgJHJlZiBwb2ludGVyXG4gICAgICAgIGtleTogJHJlZktleSwgLy8gVGhlIGtleSBpbiBgcGFyZW50YCB0aGF0IGlzIHRoZSAkcmVmIHBvaW50ZXJcbiAgICAgICAgcGF0aEZyb21Sb290LCAvLyBUaGUgcGF0aCB0byB0aGUgJHJlZiBwb2ludGVyLCBmcm9tIHRoZSBKU09OIFNjaGVtYSByb290XG4gICAgICAgIGRlcHRoLCAvLyBIb3cgZmFyIGZyb20gdGhlIEpTT04gU2NoZW1hIHJvb3QgaXMgdGhpcyAkcmVmIHBvaW50ZXI/XG4gICAgICAgIGZpbGUsIC8vIFRoZSBmaWxlIHRoYXQgdGhlICRyZWYgcG9pbnRlciByZXNvbHZlcyB0b1xuICAgICAgICBoYXNoLCAvLyBUaGUgaGFzaCB3aXRoaW4gYGZpbGVgIHRoYXQgdGhlICRyZWYgcG9pbnRlciByZXNvbHZlcyB0b1xuICAgICAgICB2YWx1ZTogcG9pbnRlci52YWx1ZSwgLy8gVGhlIHJlc29sdmVkIHZhbHVlIG9mIHRoZSAkcmVmIHBvaW50ZXJcbiAgICAgICAgY2lyY3VsYXI6IHBvaW50ZXIuY2lyY3VsYXIsIC8vIElzIHRoaXMgJHJlZiBwb2ludGVyIERJUkVDVExZIGNpcmN1bGFyPyAoaS5lLiBpdCByZWZlcmVuY2VzIGl0c2VsZilcbiAgICAgICAgZXh0ZW5kZWQsIC8vIERvZXMgdGhpcyAkcmVmIGV4dGVuZCBpdHMgcmVzb2x2ZWQgdmFsdWU/IChpLmUuIGl0IGhhcyBleHRyYSBwcm9wZXJ0aWVzLCBpbiBhZGRpdGlvbiB0byBcIiRyZWZcIilcbiAgICAgICAgZXh0ZXJuYWwsIC8vIERvZXMgdGhpcyAkcmVmIHBvaW50ZXIgcG9pbnQgdG8gYSBmaWxlIG90aGVyIHRoYW4gdGhlIG1haW4gSlNPTiBTY2hlbWEgZmlsZT9cbiAgICAgICAgaW5kaXJlY3Rpb25zLCAvLyBUaGUgbnVtYmVyIG9mIGluZGlyZWN0IHJlZmVyZW5jZXMgdGhhdCB3ZXJlIHRyYXZlcnNlZCB0byByZXNvbHZlIHRoZSB2YWx1ZVxuICAgIH0pO1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNyYXdsIHRoZSByZXNvbHZlZCB2YWx1ZVxuICAgIGlmICghZXhpc3RpbmdFbnRyeSB8fCBleHRlcm5hbCkge1xuICAgICAgICBjcmF3bChwb2ludGVyLnZhbHVlLCBudWxsLCBwb2ludGVyLnBhdGgsIHBhdGhGcm9tUm9vdCwgaW5kaXJlY3Rpb25zICsgMSwgaW52ZW50b3J5LCAkcmVmcywgb3B0aW9ucyk7XG4gICAgfVxufVxuLyoqXG4gKiBSZS1tYXBzIGV2ZXJ5ICRyZWYgcG9pbnRlciwgc28gdGhhdCB0aGV5J3JlIGFsbCByZWxhdGl2ZSB0byB0aGUgcm9vdCBvZiB0aGUgSlNPTiBTY2hlbWEuXG4gKiBFYWNoIHJlZmVyZW5jZWQgdmFsdWUgaXMgZGVyZWZlcmVuY2VkIEVYQUNUTFkgT05DRS4gIEFsbCBzdWJzZXF1ZW50IHJlZmVyZW5jZXMgdG8gdGhlIHNhbWVcbiAqIHZhbHVlIGFyZSByZS1tYXBwZWQgdG8gcG9pbnQgdG8gdGhlIGZpcnN0IHJlZmVyZW5jZS5cbiAqXG4gKiBAZXhhbXBsZToge1xuICogICAgZmlyc3Q6IHsgJHJlZjogc29tZWZpbGUuanNvbiMvc29tZS9wYXJ0IH0sXG4gKiAgICBzZWNvbmQ6IHsgJHJlZjogc29tZWZpbGUuanNvbiMvYW5vdGhlci9wYXJ0IH0sXG4gKiAgICB0aGlyZDogeyAkcmVmOiBzb21lZmlsZS5qc29uIH0sXG4gKiAgICBmb3VydGg6IHsgJHJlZjogc29tZWZpbGUuanNvbiMvc29tZS9wYXJ0L3N1Yi9wYXJ0IH1cbiAqICB9XG4gKlxuICogSW4gdGhpcyBleGFtcGxlLCB0aGVyZSBhcmUgZm91ciByZWZlcmVuY2VzIHRvIHRoZSBzYW1lIGZpbGUsIGJ1dCBzaW5jZSB0aGUgdGhpcmQgcmVmZXJlbmNlIHBvaW50c1xuICogdG8gdGhlIEVOVElSRSBmaWxlLCB0aGF0J3MgdGhlIG9ubHkgb25lIHdlIG5lZWQgdG8gZGVyZWZlcmVuY2UuICBUaGUgb3RoZXIgdGhyZWUgY2FuIGp1c3QgYmVcbiAqIHJlbWFwcGVkIHRvIHBvaW50IGluc2lkZSB0aGUgdGhpcmQgb25lLlxuICpcbiAqIE9uIHRoZSBvdGhlciBoYW5kLCBpZiB0aGUgdGhpcmQgcmVmZXJlbmNlIERJRE4nVCBleGlzdCwgdGhlbiB0aGUgZmlyc3QgYW5kIHNlY29uZCB3b3VsZCBib3RoIG5lZWRcbiAqIHRvIGJlIGRlcmVmZXJlbmNlZCwgc2luY2UgdGhleSBwb2ludCB0byBkaWZmZXJlbnQgcGFydHMgb2YgdGhlIGZpbGUuIFRoZSBmb3VydGggcmVmZXJlbmNlIGRvZXMgTk9UXG4gKiBuZWVkIHRvIGJlIGRlcmVmZXJlbmNlZCwgYmVjYXVzZSBpdCBjYW4gYmUgcmVtYXBwZWQgdG8gcG9pbnQgaW5zaWRlIHRoZSBmaXJzdCBvbmUuXG4gKlxuICogQHBhcmFtIGludmVudG9yeVxuICovXG5mdW5jdGlvbiByZW1hcChpbnZlbnRvcnkpIHtcbiAgICAvLyBHcm91cCAmIHNvcnQgYWxsIHRoZSAkcmVmIHBvaW50ZXJzLCBzbyB0aGV5J3JlIGluIHRoZSBvcmRlciB0aGF0IHdlIG5lZWQgdG8gZGVyZWZlcmVuY2UvcmVtYXAgdGhlbVxuICAgIGludmVudG9yeS5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgIGlmIChhLmZpbGUgIT09IGIuZmlsZSkge1xuICAgICAgICAgICAgLy8gR3JvdXAgYWxsIHRoZSAkcmVmcyB0aGF0IHBvaW50IHRvIHRoZSBzYW1lIGZpbGVcbiAgICAgICAgICAgIHJldHVybiBhLmZpbGUgPCBiLmZpbGUgPyAtMSA6ICsxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGEuaGFzaCAhPT0gYi5oYXNoKSB7XG4gICAgICAgICAgICAvLyBHcm91cCBhbGwgdGhlICRyZWZzIHRoYXQgcG9pbnQgdG8gdGhlIHNhbWUgcGFydCBvZiB0aGUgZmlsZVxuICAgICAgICAgICAgcmV0dXJuIGEuaGFzaCA8IGIuaGFzaCA/IC0xIDogKzE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYS5jaXJjdWxhciAhPT0gYi5jaXJjdWxhcikge1xuICAgICAgICAgICAgLy8gSWYgdGhlICRyZWYgcG9pbnRzIHRvIGl0c2VsZiwgdGhlbiBzb3J0IGl0IGhpZ2hlciB0aGFuIG90aGVyICRyZWZzIHRoYXQgcG9pbnQgdG8gdGhpcyAkcmVmXG4gICAgICAgICAgICByZXR1cm4gYS5jaXJjdWxhciA/IC0xIDogKzE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYS5leHRlbmRlZCAhPT0gYi5leHRlbmRlZCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlICRyZWYgZXh0ZW5kcyB0aGUgcmVzb2x2ZWQgdmFsdWUsIHRoZW4gc29ydCBpdCBsb3dlciB0aGFuIG90aGVyICRyZWZzIHRoYXQgZG9uJ3QgZXh0ZW5kIHRoZSB2YWx1ZVxuICAgICAgICAgICAgcmV0dXJuIGEuZXh0ZW5kZWQgPyArMSA6IC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGEuaW5kaXJlY3Rpb25zICE9PSBiLmluZGlyZWN0aW9ucykge1xuICAgICAgICAgICAgLy8gU29ydCBkaXJlY3QgcmVmZXJlbmNlcyBoaWdoZXIgdGhhbiBpbmRpcmVjdCByZWZlcmVuY2VzXG4gICAgICAgICAgICByZXR1cm4gYS5pbmRpcmVjdGlvbnMgLSBiLmluZGlyZWN0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhLmRlcHRoICE9PSBiLmRlcHRoKSB7XG4gICAgICAgICAgICAvLyBTb3J0ICRyZWZzIGJ5IGhvdyBjbG9zZSB0aGV5IGFyZSB0byB0aGUgSlNPTiBTY2hlbWEgcm9vdFxuICAgICAgICAgICAgcmV0dXJuIGEuZGVwdGggLSBiLmRlcHRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIGhvdyBmYXIgZWFjaCAkcmVmIGlzIGZyb20gdGhlIFwiZGVmaW5pdGlvbnNcIiBwcm9wZXJ0eS5cbiAgICAgICAgICAgIC8vIE1vc3QgcGVvcGxlIHdpbGwgZXhwZWN0IHJlZmVyZW5jZXMgdG8gYmUgYnVuZGxlZCBpbnRvIHRoZSB0aGUgXCJkZWZpbml0aW9uc1wiIHByb3BlcnR5IGlmIHBvc3NpYmxlLlxuICAgICAgICAgICAgY29uc3QgYURlZmluaXRpb25zSW5kZXggPSBhLnBhdGhGcm9tUm9vdC5sYXN0SW5kZXhPZihcIi9kZWZpbml0aW9uc1wiKTtcbiAgICAgICAgICAgIGNvbnN0IGJEZWZpbml0aW9uc0luZGV4ID0gYi5wYXRoRnJvbVJvb3QubGFzdEluZGV4T2YoXCIvZGVmaW5pdGlvbnNcIik7XG4gICAgICAgICAgICBpZiAoYURlZmluaXRpb25zSW5kZXggIT09IGJEZWZpbml0aW9uc0luZGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gR2l2ZSBoaWdoZXIgcHJpb3JpdHkgdG8gdGhlICRyZWYgdGhhdCdzIGNsb3NlciB0byB0aGUgXCJkZWZpbml0aW9uc1wiIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJEZWZpbml0aW9uc0luZGV4IC0gYURlZmluaXRpb25zSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBBbGwgZWxzZSBpcyBlcXVhbCwgc28gdXNlIHRoZSBzaG9ydGVyIHBhdGgsIHdoaWNoIHdpbGwgcHJvZHVjZSB0aGUgc2hvcnRlc3QgcG9zc2libGUgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGEucGF0aEZyb21Sb290Lmxlbmd0aCAtIGIucGF0aEZyb21Sb290Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGxldCBmaWxlLCBoYXNoLCBwYXRoRnJvbVJvb3Q7XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBpbnZlbnRvcnkpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ1JlLW1hcHBpbmcgJHJlZiBwb2ludGVyIFwiJXNcIiBhdCAlcycsIGVudHJ5LiRyZWYuJHJlZiwgZW50cnkucGF0aEZyb21Sb290KTtcbiAgICAgICAgaWYgKCFlbnRyeS5leHRlcm5hbCkge1xuICAgICAgICAgICAgLy8gVGhpcyAkcmVmIGFscmVhZHkgcmVzb2x2ZXMgdG8gdGhlIG1haW4gSlNPTiBTY2hlbWEgZmlsZVxuICAgICAgICAgICAgZW50cnkuJHJlZi4kcmVmID0gZW50cnkuaGFzaDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbnRyeS5maWxlID09PSBmaWxlICYmIGVudHJ5Lmhhc2ggPT09IGhhc2gpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgJHJlZiBwb2ludHMgdG8gdGhlIHNhbWUgdmFsdWUgYXMgdGhlIHByZXZvdXMgJHJlZiwgc28gcmVtYXAgaXQgdG8gdGhlIHNhbWUgcGF0aFxuICAgICAgICAgICAgZW50cnkuJHJlZi4kcmVmID0gcGF0aEZyb21Sb290O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVudHJ5LmZpbGUgPT09IGZpbGUgJiYgZW50cnkuaGFzaC5pbmRleE9mKGhhc2ggKyBcIi9cIikgPT09IDApIHtcbiAgICAgICAgICAgIC8vIFRoaXMgJHJlZiBwb2ludHMgdG8gYSBzdWItdmFsdWUgb2YgdGhlIHByZXZvdXMgJHJlZiwgc28gcmVtYXAgaXQgYmVuZWF0aCB0aGF0IHBhdGhcbiAgICAgICAgICAgIGVudHJ5LiRyZWYuJHJlZiA9IHBvaW50ZXJfanNfMS5kZWZhdWx0LmpvaW4ocGF0aEZyb21Sb290LCBwb2ludGVyX2pzXzEuZGVmYXVsdC5wYXJzZShlbnRyeS5oYXNoLnJlcGxhY2UoaGFzaCwgXCIjXCIpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSd2ZSBtb3ZlZCB0byBhIG5ldyBmaWxlIG9yIG5ldyBoYXNoXG4gICAgICAgICAgICBmaWxlID0gZW50cnkuZmlsZTtcbiAgICAgICAgICAgIGhhc2ggPSBlbnRyeS5oYXNoO1xuICAgICAgICAgICAgcGF0aEZyb21Sb290ID0gZW50cnkucGF0aEZyb21Sb290O1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgJHJlZiB0byBwb2ludCB0byB0aGlzIHZhbHVlLCBzbyBkZXJlZmVyZW5jZSB0aGUgdmFsdWUuXG4gICAgICAgICAgICAvLyBBbnkgb3RoZXIgJHJlZnMgdGhhdCBwb2ludCB0byB0aGUgc2FtZSB2YWx1ZSB3aWxsIHBvaW50IHRvIHRoaXMgJHJlZiBpbnN0ZWFkXG4gICAgICAgICAgICBlbnRyeS4kcmVmID0gZW50cnkucGFyZW50W2VudHJ5LmtleV0gPSByZWZfanNfMS5kZWZhdWx0LmRlcmVmZXJlbmNlKGVudHJ5LiRyZWYsIGVudHJ5LnZhbHVlKTtcbiAgICAgICAgICAgIGlmIChlbnRyeS5jaXJjdWxhcikge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgJHJlZiBwb2ludHMgdG8gaXRzZWxmXG4gICAgICAgICAgICAgICAgZW50cnkuJHJlZi4kcmVmID0gZW50cnkucGF0aEZyb21Sb290O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHdlIHdhbnQgdG8gZW5zdXJlIHRoYXQgYW55ICRyZWZzIHRoYXQgcG9pbnQgdG8gYW5vdGhlciAkcmVmIGFyZSByZW1hcHBlZCB0byBwb2ludCB0byB0aGUgZmluYWwgdmFsdWVcbiAgICAvLyBsZXQgaGFkQ2hhbmdlID0gdHJ1ZTtcbiAgICAvLyB3aGlsZSAoaGFkQ2hhbmdlKSB7XG4gICAgLy8gICBoYWRDaGFuZ2UgPSBmYWxzZTtcbiAgICAvLyAgIGZvciAoY29uc3QgZW50cnkgb2YgaW52ZW50b3J5KSB7XG4gICAgLy8gICAgIGlmIChlbnRyeS4kcmVmICYmIHR5cGVvZiBlbnRyeS4kcmVmID09PSBcIm9iamVjdFwiICYmIFwiJHJlZlwiIGluIGVudHJ5LiRyZWYpIHtcbiAgICAvLyAgICAgICBjb25zdCByZXNvbHZlZCA9IGludmVudG9yeS5maW5kKChlOiBJbnZlbnRvcnlFbnRyeSkgPT4gZS5wYXRoRnJvbVJvb3QgPT09IGVudHJ5LiRyZWYuJHJlZik7XG4gICAgLy8gICAgICAgaWYgKHJlc29sdmVkKSB7XG4gICAgLy8gICAgICAgICBjb25zdCByZXNvbHZlZFBvaW50c1RvQW5vdGhlclJlZiA9XG4gICAgLy8gICAgICAgICAgIHJlc29sdmVkLiRyZWYgJiYgdHlwZW9mIHJlc29sdmVkLiRyZWYgPT09IFwib2JqZWN0XCIgJiYgXCIkcmVmXCIgaW4gcmVzb2x2ZWQuJHJlZjtcbiAgICAvLyAgICAgICAgIGlmIChyZXNvbHZlZFBvaW50c1RvQW5vdGhlclJlZiAmJiBlbnRyeS4kcmVmLiRyZWYgIT09IHJlc29sdmVkLiRyZWYuJHJlZikge1xuICAgIC8vICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnUmUtbWFwcGluZyAkcmVmIHBvaW50ZXIgXCIlc1wiIGF0ICVzJywgZW50cnkuJHJlZi4kcmVmLCBlbnRyeS5wYXRoRnJvbVJvb3QpO1xuICAgIC8vICAgICAgICAgICBlbnRyeS4kcmVmLiRyZWYgPSByZXNvbHZlZC4kcmVmLiRyZWY7XG4gICAgLy8gICAgICAgICAgIGhhZENoYW5nZSA9IHRydWU7XG4gICAgLy8gICAgICAgICB9XG4gICAgLy8gICAgICAgfVxuICAgIC8vICAgICB9XG4gICAgLy8gICB9XG4gICAgLy8gfVxufVxuLyoqXG4gKiBUT0RPXG4gKi9cbmZ1bmN0aW9uIGZpbmRJbkludmVudG9yeShpbnZlbnRvcnksICRyZWZQYXJlbnQsICRyZWZLZXkpIHtcbiAgICBmb3IgKGNvbnN0IGV4aXN0aW5nRW50cnkgb2YgaW52ZW50b3J5KSB7XG4gICAgICAgIGlmIChleGlzdGluZ0VudHJ5ICYmIGV4aXN0aW5nRW50cnkucGFyZW50ID09PSAkcmVmUGFyZW50ICYmIGV4aXN0aW5nRW50cnkua2V5ID09PSAkcmVmS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdFbnRyeTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gcmVtb3ZlRnJvbUludmVudG9yeShpbnZlbnRvcnksIGVudHJ5KSB7XG4gICAgY29uc3QgaW5kZXggPSBpbnZlbnRvcnkuaW5kZXhPZihlbnRyeSk7XG4gICAgaW52ZW50b3J5LnNwbGljZShpbmRleCwgMSk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBidW5kbGU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/bundle.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/dereference.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/dereference.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst ref_js_1 = __importDefault(__webpack_require__(/*! ./ref.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/ref.js\"));\nconst pointer_js_1 = __importDefault(__webpack_require__(/*! ./pointer.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/pointer.js\"));\nconst ono_1 = __webpack_require__(/*! @jsdevtools/ono */ \"(ssr)/./node_modules/@jsdevtools/ono/esm/index.js\");\nconst url = __importStar(__webpack_require__(/*! ./util/url.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/url.js\"));\nconst errors_1 = __webpack_require__(/*! ./util/errors */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/errors.js\");\nexports[\"default\"] = dereference;\n/**\n * Crawls the JSON schema, finds all JSON references, and dereferences them.\n * This method mutates the JSON schema object, replacing JSON references with their resolved value.\n *\n * @param parser\n * @param options\n */\nfunction dereference(parser, options) {\n    const start = Date.now();\n    // console.log('Dereferencing $ref pointers in %s', parser.$refs._root$Ref.path);\n    const dereferenced = crawl(parser.schema, parser.$refs._root$Ref.path, \"#\", new Set(), new Set(), new Map(), parser.$refs, options, start);\n    parser.$refs.circular = dereferenced.circular;\n    parser.schema = dereferenced.value;\n}\n/**\n * Recursively crawls the given value, and dereferences any JSON references.\n *\n * @param obj - The value to crawl. If it's not an object or array, it will be ignored.\n * @param path - The full path of `obj`, possibly with a JSON Pointer in the hash\n * @param pathFromRoot - The path of `obj` from the schema root\n * @param parents - An array of the parent objects that have already been dereferenced\n * @param processedObjects - An array of all the objects that have already been processed\n * @param dereferencedCache - An map of all the dereferenced objects\n * @param $refs\n * @param options\n * @param startTime - The time when the dereferencing started\n * @returns\n */\nfunction crawl(obj, path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options, startTime) {\n    let dereferenced;\n    const result = {\n        value: obj,\n        circular: false,\n    };\n    if (options && options.timeoutMs) {\n        if (Date.now() - startTime > options.timeoutMs) {\n            throw new errors_1.TimeoutError(options.timeoutMs);\n        }\n    }\n    const derefOptions = (options.dereference || {});\n    const isExcludedPath = derefOptions.excludedPathMatcher || (() => false);\n    if (derefOptions?.circular === \"ignore\" || !processedObjects.has(obj)) {\n        if (obj && typeof obj === \"object\" && !ArrayBuffer.isView(obj) && !isExcludedPath(pathFromRoot)) {\n            parents.add(obj);\n            processedObjects.add(obj);\n            if (ref_js_1.default.isAllowed$Ref(obj, options)) {\n                dereferenced = dereference$Ref(obj, path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options, startTime);\n                result.circular = dereferenced.circular;\n                result.value = dereferenced.value;\n            }\n            else {\n                for (const key of Object.keys(obj)) {\n                    const keyPath = pointer_js_1.default.join(path, key);\n                    const keyPathFromRoot = pointer_js_1.default.join(pathFromRoot, key);\n                    if (isExcludedPath(keyPathFromRoot)) {\n                        continue;\n                    }\n                    const value = obj[key];\n                    let circular = false;\n                    if (ref_js_1.default.isAllowed$Ref(value, options)) {\n                        dereferenced = dereference$Ref(value, keyPath, keyPathFromRoot, parents, processedObjects, dereferencedCache, $refs, options, startTime);\n                        circular = dereferenced.circular;\n                        // Avoid pointless mutations; breaks frozen objects to no profit\n                        if (obj[key] !== dereferenced.value) {\n                            obj[key] = dereferenced.value;\n                            derefOptions?.onDereference?.(value.$ref, obj[key], obj, key);\n                        }\n                    }\n                    else {\n                        if (!parents.has(value)) {\n                            dereferenced = crawl(value, keyPath, keyPathFromRoot, parents, processedObjects, dereferencedCache, $refs, options, startTime);\n                            circular = dereferenced.circular;\n                            // Avoid pointless mutations; breaks frozen objects to no profit\n                            if (obj[key] !== dereferenced.value) {\n                                obj[key] = dereferenced.value;\n                            }\n                        }\n                        else {\n                            circular = foundCircularReference(keyPath, $refs, options);\n                        }\n                    }\n                    // Set the \"isCircular\" flag if this or any other property is circular\n                    result.circular = result.circular || circular;\n                }\n            }\n            parents.delete(obj);\n        }\n    }\n    return result;\n}\n/**\n * Dereferences the given JSON Reference, and then crawls the resulting value.\n *\n * @param $ref - The JSON Reference to resolve\n * @param path - The full path of `$ref`, possibly with a JSON Pointer in the hash\n * @param pathFromRoot - The path of `$ref` from the schema root\n * @param parents - An array of the parent objects that have already been dereferenced\n * @param processedObjects - An array of all the objects that have already been dereferenced\n * @param dereferencedCache - An map of all the dereferenced objects\n * @param $refs\n * @param options\n * @returns\n */\nfunction dereference$Ref($ref, path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options, startTime) {\n    const isExternalRef = ref_js_1.default.isExternal$Ref($ref);\n    const shouldResolveOnCwd = isExternalRef && options?.dereference?.externalReferenceResolution === \"root\";\n    const $refPath = url.resolve(shouldResolveOnCwd ? url.cwd() : path, $ref.$ref);\n    const cache = dereferencedCache.get($refPath);\n    if (cache) {\n        const refKeys = Object.keys($ref);\n        if (refKeys.length > 1) {\n            const extraKeys = {};\n            for (const key of refKeys) {\n                if (key !== \"$ref\" && !(key in cache.value)) {\n                    // @ts-expect-error TS(7053): Element implicitly has an 'any' type because expre... Remove this comment to see the full error message\n                    extraKeys[key] = $ref[key];\n                }\n            }\n            return {\n                circular: cache.circular,\n                value: Object.assign({}, cache.value, extraKeys),\n            };\n        }\n        return cache;\n    }\n    const pointer = $refs._resolve($refPath, path, options);\n    if (pointer === null) {\n        return {\n            circular: false,\n            value: null,\n        };\n    }\n    // Check for circular references\n    const directCircular = pointer.circular;\n    let circular = directCircular || parents.has(pointer.value);\n    if (circular) {\n        foundCircularReference(path, $refs, options);\n    }\n    // Dereference the JSON reference\n    let dereferencedValue = ref_js_1.default.dereference($ref, pointer.value);\n    // Crawl the dereferenced value (unless it's circular)\n    if (!circular) {\n        // Determine if the dereferenced value is circular\n        const dereferenced = crawl(dereferencedValue, pointer.path, pathFromRoot, parents, processedObjects, dereferencedCache, $refs, options, startTime);\n        circular = dereferenced.circular;\n        dereferencedValue = dereferenced.value;\n    }\n    if (circular && !directCircular && options.dereference?.circular === \"ignore\") {\n        // The user has chosen to \"ignore\" circular references, so don't change the value\n        dereferencedValue = $ref;\n    }\n    if (directCircular) {\n        // The pointer is a DIRECT circular reference (i.e. it references itself).\n        // So replace the $ref path with the absolute path from the JSON Schema root\n        dereferencedValue.$ref = pathFromRoot;\n    }\n    const dereferencedObject = {\n        circular,\n        value: dereferencedValue,\n    };\n    // only cache if no extra properties than $ref\n    if (Object.keys($ref).length === 1) {\n        dereferencedCache.set($refPath, dereferencedObject);\n    }\n    return dereferencedObject;\n}\n/**\n * Called when a circular reference is found.\n * It sets the {@link $Refs#circular} flag, and throws an error if options.dereference.circular is false.\n *\n * @param keyPath - The JSON Reference path of the circular reference\n * @param $refs\n * @param options\n * @returns - always returns true, to indicate that a circular reference was found\n */\nfunction foundCircularReference(keyPath, $refs, options) {\n    $refs.circular = true;\n    if (!options.dereference.circular) {\n        throw ono_1.ono.reference(`Circular $ref pointer found at ${keyPath}`);\n    }\n    return true;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvZGVyZWZlcmVuY2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUNBQWlDLG1CQUFPLENBQUMsMEZBQVU7QUFDbkQscUNBQXFDLG1CQUFPLENBQUMsa0dBQWM7QUFDM0QsY0FBYyxtQkFBTyxDQUFDLDBFQUFpQjtBQUN2Qyx5QkFBeUIsbUJBQU8sQ0FBQyxvR0FBZTtBQUNoRCxpQkFBaUIsbUJBQU8sQ0FBQyx1R0FBZTtBQUN4QyxrQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNCQUFzQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsUUFBUTtBQUM1RTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaGF0Ym90LXVpLy4vbm9kZV9tb2R1bGVzL0BhcGlkZXZ0b29scy9qc29uLXNjaGVtYS1yZWYtcGFyc2VyL2Rpc3QvbGliL2RlcmVmZXJlbmNlLmpzPzU3OTIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHJlZl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3JlZi5qc1wiKSk7XG5jb25zdCBwb2ludGVyX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcG9pbnRlci5qc1wiKSk7XG5jb25zdCBvbm9fMSA9IHJlcXVpcmUoXCJAanNkZXZ0b29scy9vbm9cIik7XG5jb25zdCB1cmwgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdXRpbC91cmwuanNcIikpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi91dGlsL2Vycm9yc1wiKTtcbmV4cG9ydHMuZGVmYXVsdCA9IGRlcmVmZXJlbmNlO1xuLyoqXG4gKiBDcmF3bHMgdGhlIEpTT04gc2NoZW1hLCBmaW5kcyBhbGwgSlNPTiByZWZlcmVuY2VzLCBhbmQgZGVyZWZlcmVuY2VzIHRoZW0uXG4gKiBUaGlzIG1ldGhvZCBtdXRhdGVzIHRoZSBKU09OIHNjaGVtYSBvYmplY3QsIHJlcGxhY2luZyBKU09OIHJlZmVyZW5jZXMgd2l0aCB0aGVpciByZXNvbHZlZCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0gcGFyc2VyXG4gKiBAcGFyYW0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBkZXJlZmVyZW5jZShwYXJzZXIsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzdGFydCA9IERhdGUubm93KCk7XG4gICAgLy8gY29uc29sZS5sb2coJ0RlcmVmZXJlbmNpbmcgJHJlZiBwb2ludGVycyBpbiAlcycsIHBhcnNlci4kcmVmcy5fcm9vdCRSZWYucGF0aCk7XG4gICAgY29uc3QgZGVyZWZlcmVuY2VkID0gY3Jhd2wocGFyc2VyLnNjaGVtYSwgcGFyc2VyLiRyZWZzLl9yb290JFJlZi5wYXRoLCBcIiNcIiwgbmV3IFNldCgpLCBuZXcgU2V0KCksIG5ldyBNYXAoKSwgcGFyc2VyLiRyZWZzLCBvcHRpb25zLCBzdGFydCk7XG4gICAgcGFyc2VyLiRyZWZzLmNpcmN1bGFyID0gZGVyZWZlcmVuY2VkLmNpcmN1bGFyO1xuICAgIHBhcnNlci5zY2hlbWEgPSBkZXJlZmVyZW5jZWQudmFsdWU7XG59XG4vKipcbiAqIFJlY3Vyc2l2ZWx5IGNyYXdscyB0aGUgZ2l2ZW4gdmFsdWUsIGFuZCBkZXJlZmVyZW5jZXMgYW55IEpTT04gcmVmZXJlbmNlcy5cbiAqXG4gKiBAcGFyYW0gb2JqIC0gVGhlIHZhbHVlIHRvIGNyYXdsLiBJZiBpdCdzIG5vdCBhbiBvYmplY3Qgb3IgYXJyYXksIGl0IHdpbGwgYmUgaWdub3JlZC5cbiAqIEBwYXJhbSBwYXRoIC0gVGhlIGZ1bGwgcGF0aCBvZiBgb2JqYCwgcG9zc2libHkgd2l0aCBhIEpTT04gUG9pbnRlciBpbiB0aGUgaGFzaFxuICogQHBhcmFtIHBhdGhGcm9tUm9vdCAtIFRoZSBwYXRoIG9mIGBvYmpgIGZyb20gdGhlIHNjaGVtYSByb290XG4gKiBAcGFyYW0gcGFyZW50cyAtIEFuIGFycmF5IG9mIHRoZSBwYXJlbnQgb2JqZWN0cyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGRlcmVmZXJlbmNlZFxuICogQHBhcmFtIHByb2Nlc3NlZE9iamVjdHMgLSBBbiBhcnJheSBvZiBhbGwgdGhlIG9iamVjdHMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBwcm9jZXNzZWRcbiAqIEBwYXJhbSBkZXJlZmVyZW5jZWRDYWNoZSAtIEFuIG1hcCBvZiBhbGwgdGhlIGRlcmVmZXJlbmNlZCBvYmplY3RzXG4gKiBAcGFyYW0gJHJlZnNcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcGFyYW0gc3RhcnRUaW1lIC0gVGhlIHRpbWUgd2hlbiB0aGUgZGVyZWZlcmVuY2luZyBzdGFydGVkXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBjcmF3bChvYmosIHBhdGgsIHBhdGhGcm9tUm9vdCwgcGFyZW50cywgcHJvY2Vzc2VkT2JqZWN0cywgZGVyZWZlcmVuY2VkQ2FjaGUsICRyZWZzLCBvcHRpb25zLCBzdGFydFRpbWUpIHtcbiAgICBsZXQgZGVyZWZlcmVuY2VkO1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgdmFsdWU6IG9iaixcbiAgICAgICAgY2lyY3VsYXI6IGZhbHNlLFxuICAgIH07XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy50aW1lb3V0TXMpIHtcbiAgICAgICAgaWYgKERhdGUubm93KCkgLSBzdGFydFRpbWUgPiBvcHRpb25zLnRpbWVvdXRNcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlRpbWVvdXRFcnJvcihvcHRpb25zLnRpbWVvdXRNcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZGVyZWZPcHRpb25zID0gKG9wdGlvbnMuZGVyZWZlcmVuY2UgfHwge30pO1xuICAgIGNvbnN0IGlzRXhjbHVkZWRQYXRoID0gZGVyZWZPcHRpb25zLmV4Y2x1ZGVkUGF0aE1hdGNoZXIgfHwgKCgpID0+IGZhbHNlKTtcbiAgICBpZiAoZGVyZWZPcHRpb25zPy5jaXJjdWxhciA9PT0gXCJpZ25vcmVcIiB8fCAhcHJvY2Vzc2VkT2JqZWN0cy5oYXMob2JqKSkge1xuICAgICAgICBpZiAob2JqICYmIHR5cGVvZiBvYmogPT09IFwib2JqZWN0XCIgJiYgIUFycmF5QnVmZmVyLmlzVmlldyhvYmopICYmICFpc0V4Y2x1ZGVkUGF0aChwYXRoRnJvbVJvb3QpKSB7XG4gICAgICAgICAgICBwYXJlbnRzLmFkZChvYmopO1xuICAgICAgICAgICAgcHJvY2Vzc2VkT2JqZWN0cy5hZGQob2JqKTtcbiAgICAgICAgICAgIGlmIChyZWZfanNfMS5kZWZhdWx0LmlzQWxsb3dlZCRSZWYob2JqLCBvcHRpb25zKSkge1xuICAgICAgICAgICAgICAgIGRlcmVmZXJlbmNlZCA9IGRlcmVmZXJlbmNlJFJlZihvYmosIHBhdGgsIHBhdGhGcm9tUm9vdCwgcGFyZW50cywgcHJvY2Vzc2VkT2JqZWN0cywgZGVyZWZlcmVuY2VkQ2FjaGUsICRyZWZzLCBvcHRpb25zLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5jaXJjdWxhciA9IGRlcmVmZXJlbmNlZC5jaXJjdWxhcjtcbiAgICAgICAgICAgICAgICByZXN1bHQudmFsdWUgPSBkZXJlZmVyZW5jZWQudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvYmopKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleVBhdGggPSBwb2ludGVyX2pzXzEuZGVmYXVsdC5qb2luKHBhdGgsIGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleVBhdGhGcm9tUm9vdCA9IHBvaW50ZXJfanNfMS5kZWZhdWx0LmpvaW4ocGF0aEZyb21Sb290LCBrZXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNFeGNsdWRlZFBhdGgoa2V5UGF0aEZyb21Sb290KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNpcmN1bGFyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWZfanNfMS5kZWZhdWx0LmlzQWxsb3dlZCRSZWYodmFsdWUsIG9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXJlZmVyZW5jZWQgPSBkZXJlZmVyZW5jZSRSZWYodmFsdWUsIGtleVBhdGgsIGtleVBhdGhGcm9tUm9vdCwgcGFyZW50cywgcHJvY2Vzc2VkT2JqZWN0cywgZGVyZWZlcmVuY2VkQ2FjaGUsICRyZWZzLCBvcHRpb25zLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2lyY3VsYXIgPSBkZXJlZmVyZW5jZWQuY2lyY3VsYXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBdm9pZCBwb2ludGxlc3MgbXV0YXRpb25zOyBicmVha3MgZnJvemVuIG9iamVjdHMgdG8gbm8gcHJvZml0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob2JqW2tleV0gIT09IGRlcmVmZXJlbmNlZC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9ialtrZXldID0gZGVyZWZlcmVuY2VkLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlcmVmT3B0aW9ucz8ub25EZXJlZmVyZW5jZT8uKHZhbHVlLiRyZWYsIG9ialtrZXldLCBvYmosIGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmVudHMuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlcmVmZXJlbmNlZCA9IGNyYXdsKHZhbHVlLCBrZXlQYXRoLCBrZXlQYXRoRnJvbVJvb3QsIHBhcmVudHMsIHByb2Nlc3NlZE9iamVjdHMsIGRlcmVmZXJlbmNlZENhY2hlLCAkcmVmcywgb3B0aW9ucywgc3RhcnRUaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaXJjdWxhciA9IGRlcmVmZXJlbmNlZC5jaXJjdWxhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBdm9pZCBwb2ludGxlc3MgbXV0YXRpb25zOyBicmVha3MgZnJvemVuIG9iamVjdHMgdG8gbm8gcHJvZml0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9ialtrZXldICE9PSBkZXJlZmVyZW5jZWQudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqW2tleV0gPSBkZXJlZmVyZW5jZWQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2lyY3VsYXIgPSBmb3VuZENpcmN1bGFyUmVmZXJlbmNlKGtleVBhdGgsICRyZWZzLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIFwiaXNDaXJjdWxhclwiIGZsYWcgaWYgdGhpcyBvciBhbnkgb3RoZXIgcHJvcGVydHkgaXMgY2lyY3VsYXJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmNpcmN1bGFyID0gcmVzdWx0LmNpcmN1bGFyIHx8IGNpcmN1bGFyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmVudHMuZGVsZXRlKG9iaik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogRGVyZWZlcmVuY2VzIHRoZSBnaXZlbiBKU09OIFJlZmVyZW5jZSwgYW5kIHRoZW4gY3Jhd2xzIHRoZSByZXN1bHRpbmcgdmFsdWUuXG4gKlxuICogQHBhcmFtICRyZWYgLSBUaGUgSlNPTiBSZWZlcmVuY2UgdG8gcmVzb2x2ZVxuICogQHBhcmFtIHBhdGggLSBUaGUgZnVsbCBwYXRoIG9mIGAkcmVmYCwgcG9zc2libHkgd2l0aCBhIEpTT04gUG9pbnRlciBpbiB0aGUgaGFzaFxuICogQHBhcmFtIHBhdGhGcm9tUm9vdCAtIFRoZSBwYXRoIG9mIGAkcmVmYCBmcm9tIHRoZSBzY2hlbWEgcm9vdFxuICogQHBhcmFtIHBhcmVudHMgLSBBbiBhcnJheSBvZiB0aGUgcGFyZW50IG9iamVjdHMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBkZXJlZmVyZW5jZWRcbiAqIEBwYXJhbSBwcm9jZXNzZWRPYmplY3RzIC0gQW4gYXJyYXkgb2YgYWxsIHRoZSBvYmplY3RzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gZGVyZWZlcmVuY2VkXG4gKiBAcGFyYW0gZGVyZWZlcmVuY2VkQ2FjaGUgLSBBbiBtYXAgb2YgYWxsIHRoZSBkZXJlZmVyZW5jZWQgb2JqZWN0c1xuICogQHBhcmFtICRyZWZzXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gZGVyZWZlcmVuY2UkUmVmKCRyZWYsIHBhdGgsIHBhdGhGcm9tUm9vdCwgcGFyZW50cywgcHJvY2Vzc2VkT2JqZWN0cywgZGVyZWZlcmVuY2VkQ2FjaGUsICRyZWZzLCBvcHRpb25zLCBzdGFydFRpbWUpIHtcbiAgICBjb25zdCBpc0V4dGVybmFsUmVmID0gcmVmX2pzXzEuZGVmYXVsdC5pc0V4dGVybmFsJFJlZigkcmVmKTtcbiAgICBjb25zdCBzaG91bGRSZXNvbHZlT25Dd2QgPSBpc0V4dGVybmFsUmVmICYmIG9wdGlvbnM/LmRlcmVmZXJlbmNlPy5leHRlcm5hbFJlZmVyZW5jZVJlc29sdXRpb24gPT09IFwicm9vdFwiO1xuICAgIGNvbnN0ICRyZWZQYXRoID0gdXJsLnJlc29sdmUoc2hvdWxkUmVzb2x2ZU9uQ3dkID8gdXJsLmN3ZCgpIDogcGF0aCwgJHJlZi4kcmVmKTtcbiAgICBjb25zdCBjYWNoZSA9IGRlcmVmZXJlbmNlZENhY2hlLmdldCgkcmVmUGF0aCk7XG4gICAgaWYgKGNhY2hlKSB7XG4gICAgICAgIGNvbnN0IHJlZktleXMgPSBPYmplY3Qua2V5cygkcmVmKTtcbiAgICAgICAgaWYgKHJlZktleXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgY29uc3QgZXh0cmFLZXlzID0ge307XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiByZWZLZXlzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gXCIkcmVmXCIgJiYgIShrZXkgaW4gY2FjaGUudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVFMoNzA1Myk6IEVsZW1lbnQgaW1wbGljaXRseSBoYXMgYW4gJ2FueScgdHlwZSBiZWNhdXNlIGV4cHJlLi4uIFJlbW92ZSB0aGlzIGNvbW1lbnQgdG8gc2VlIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFLZXlzW2tleV0gPSAkcmVmW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjaXJjdWxhcjogY2FjaGUuY2lyY3VsYXIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IE9iamVjdC5hc3NpZ24oe30sIGNhY2hlLnZhbHVlLCBleHRyYUtleXMpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FjaGU7XG4gICAgfVxuICAgIGNvbnN0IHBvaW50ZXIgPSAkcmVmcy5fcmVzb2x2ZSgkcmVmUGF0aCwgcGF0aCwgb3B0aW9ucyk7XG4gICAgaWYgKHBvaW50ZXIgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNpcmN1bGFyOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBDaGVjayBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlc1xuICAgIGNvbnN0IGRpcmVjdENpcmN1bGFyID0gcG9pbnRlci5jaXJjdWxhcjtcbiAgICBsZXQgY2lyY3VsYXIgPSBkaXJlY3RDaXJjdWxhciB8fCBwYXJlbnRzLmhhcyhwb2ludGVyLnZhbHVlKTtcbiAgICBpZiAoY2lyY3VsYXIpIHtcbiAgICAgICAgZm91bmRDaXJjdWxhclJlZmVyZW5jZShwYXRoLCAkcmVmcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8vIERlcmVmZXJlbmNlIHRoZSBKU09OIHJlZmVyZW5jZVxuICAgIGxldCBkZXJlZmVyZW5jZWRWYWx1ZSA9IHJlZl9qc18xLmRlZmF1bHQuZGVyZWZlcmVuY2UoJHJlZiwgcG9pbnRlci52YWx1ZSk7XG4gICAgLy8gQ3Jhd2wgdGhlIGRlcmVmZXJlbmNlZCB2YWx1ZSAodW5sZXNzIGl0J3MgY2lyY3VsYXIpXG4gICAgaWYgKCFjaXJjdWxhcikge1xuICAgICAgICAvLyBEZXRlcm1pbmUgaWYgdGhlIGRlcmVmZXJlbmNlZCB2YWx1ZSBpcyBjaXJjdWxhclxuICAgICAgICBjb25zdCBkZXJlZmVyZW5jZWQgPSBjcmF3bChkZXJlZmVyZW5jZWRWYWx1ZSwgcG9pbnRlci5wYXRoLCBwYXRoRnJvbVJvb3QsIHBhcmVudHMsIHByb2Nlc3NlZE9iamVjdHMsIGRlcmVmZXJlbmNlZENhY2hlLCAkcmVmcywgb3B0aW9ucywgc3RhcnRUaW1lKTtcbiAgICAgICAgY2lyY3VsYXIgPSBkZXJlZmVyZW5jZWQuY2lyY3VsYXI7XG4gICAgICAgIGRlcmVmZXJlbmNlZFZhbHVlID0gZGVyZWZlcmVuY2VkLnZhbHVlO1xuICAgIH1cbiAgICBpZiAoY2lyY3VsYXIgJiYgIWRpcmVjdENpcmN1bGFyICYmIG9wdGlvbnMuZGVyZWZlcmVuY2U/LmNpcmN1bGFyID09PSBcImlnbm9yZVwiKSB7XG4gICAgICAgIC8vIFRoZSB1c2VyIGhhcyBjaG9zZW4gdG8gXCJpZ25vcmVcIiBjaXJjdWxhciByZWZlcmVuY2VzLCBzbyBkb24ndCBjaGFuZ2UgdGhlIHZhbHVlXG4gICAgICAgIGRlcmVmZXJlbmNlZFZhbHVlID0gJHJlZjtcbiAgICB9XG4gICAgaWYgKGRpcmVjdENpcmN1bGFyKSB7XG4gICAgICAgIC8vIFRoZSBwb2ludGVyIGlzIGEgRElSRUNUIGNpcmN1bGFyIHJlZmVyZW5jZSAoaS5lLiBpdCByZWZlcmVuY2VzIGl0c2VsZikuXG4gICAgICAgIC8vIFNvIHJlcGxhY2UgdGhlICRyZWYgcGF0aCB3aXRoIHRoZSBhYnNvbHV0ZSBwYXRoIGZyb20gdGhlIEpTT04gU2NoZW1hIHJvb3RcbiAgICAgICAgZGVyZWZlcmVuY2VkVmFsdWUuJHJlZiA9IHBhdGhGcm9tUm9vdDtcbiAgICB9XG4gICAgY29uc3QgZGVyZWZlcmVuY2VkT2JqZWN0ID0ge1xuICAgICAgICBjaXJjdWxhcixcbiAgICAgICAgdmFsdWU6IGRlcmVmZXJlbmNlZFZhbHVlLFxuICAgIH07XG4gICAgLy8gb25seSBjYWNoZSBpZiBubyBleHRyYSBwcm9wZXJ0aWVzIHRoYW4gJHJlZlxuICAgIGlmIChPYmplY3Qua2V5cygkcmVmKS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZGVyZWZlcmVuY2VkQ2FjaGUuc2V0KCRyZWZQYXRoLCBkZXJlZmVyZW5jZWRPYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gZGVyZWZlcmVuY2VkT2JqZWN0O1xufVxuLyoqXG4gKiBDYWxsZWQgd2hlbiBhIGNpcmN1bGFyIHJlZmVyZW5jZSBpcyBmb3VuZC5cbiAqIEl0IHNldHMgdGhlIHtAbGluayAkUmVmcyNjaXJjdWxhcn0gZmxhZywgYW5kIHRocm93cyBhbiBlcnJvciBpZiBvcHRpb25zLmRlcmVmZXJlbmNlLmNpcmN1bGFyIGlzIGZhbHNlLlxuICpcbiAqIEBwYXJhbSBrZXlQYXRoIC0gVGhlIEpTT04gUmVmZXJlbmNlIHBhdGggb2YgdGhlIGNpcmN1bGFyIHJlZmVyZW5jZVxuICogQHBhcmFtICRyZWZzXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHJldHVybnMgLSBhbHdheXMgcmV0dXJucyB0cnVlLCB0byBpbmRpY2F0ZSB0aGF0IGEgY2lyY3VsYXIgcmVmZXJlbmNlIHdhcyBmb3VuZFxuICovXG5mdW5jdGlvbiBmb3VuZENpcmN1bGFyUmVmZXJlbmNlKGtleVBhdGgsICRyZWZzLCBvcHRpb25zKSB7XG4gICAgJHJlZnMuY2lyY3VsYXIgPSB0cnVlO1xuICAgIGlmICghb3B0aW9ucy5kZXJlZmVyZW5jZS5jaXJjdWxhcikge1xuICAgICAgICB0aHJvdyBvbm9fMS5vbm8ucmVmZXJlbmNlKGBDaXJjdWxhciAkcmVmIHBvaW50ZXIgZm91bmQgYXQgJHtrZXlQYXRofWApO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/dereference.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/index.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.JSONParserErrorGroup = exports.isHandledError = exports.UnmatchedParserError = exports.ParserError = exports.ResolverError = exports.MissingPointerError = exports.InvalidPointerError = exports.JSONParserError = exports.UnmatchedResolverError = exports.dereference = exports.bundle = exports.resolve = exports.parse = exports.$RefParser = void 0;\nconst refs_js_1 = __importDefault(__webpack_require__(/*! ./refs.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/refs.js\"));\nconst parse_js_1 = __importDefault(__webpack_require__(/*! ./parse.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parse.js\"));\nconst normalize_args_js_1 = __importDefault(__webpack_require__(/*! ./normalize-args.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/normalize-args.js\"));\nconst resolve_external_js_1 = __importDefault(__webpack_require__(/*! ./resolve-external.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/resolve-external.js\"));\nconst bundle_js_1 = __importDefault(__webpack_require__(/*! ./bundle.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/bundle.js\"));\nconst dereference_js_1 = __importDefault(__webpack_require__(/*! ./dereference.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/dereference.js\"));\nconst url = __importStar(__webpack_require__(/*! ./util/url.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/url.js\"));\nconst errors_js_1 = __webpack_require__(/*! ./util/errors.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/errors.js\");\nObject.defineProperty(exports, \"JSONParserError\", ({ enumerable: true, get: function () { return errors_js_1.JSONParserError; } }));\nObject.defineProperty(exports, \"InvalidPointerError\", ({ enumerable: true, get: function () { return errors_js_1.InvalidPointerError; } }));\nObject.defineProperty(exports, \"MissingPointerError\", ({ enumerable: true, get: function () { return errors_js_1.MissingPointerError; } }));\nObject.defineProperty(exports, \"ResolverError\", ({ enumerable: true, get: function () { return errors_js_1.ResolverError; } }));\nObject.defineProperty(exports, \"ParserError\", ({ enumerable: true, get: function () { return errors_js_1.ParserError; } }));\nObject.defineProperty(exports, \"UnmatchedParserError\", ({ enumerable: true, get: function () { return errors_js_1.UnmatchedParserError; } }));\nObject.defineProperty(exports, \"UnmatchedResolverError\", ({ enumerable: true, get: function () { return errors_js_1.UnmatchedResolverError; } }));\nObject.defineProperty(exports, \"isHandledError\", ({ enumerable: true, get: function () { return errors_js_1.isHandledError; } }));\nObject.defineProperty(exports, \"JSONParserErrorGroup\", ({ enumerable: true, get: function () { return errors_js_1.JSONParserErrorGroup; } }));\nconst ono_1 = __webpack_require__(/*! @jsdevtools/ono */ \"(ssr)/./node_modules/@jsdevtools/ono/esm/index.js\");\nconst maybe_js_1 = __importDefault(__webpack_require__(/*! ./util/maybe.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/maybe.js\"));\n/**\n * This class parses a JSON schema, builds a map of its JSON references and their resolved values,\n * and provides methods for traversing, manipulating, and dereferencing those references.\n *\n * @class\n */\nclass $RefParser {\n    constructor() {\n        /**\n         * The parsed (and possibly dereferenced) JSON schema object\n         *\n         * @type {object}\n         * @readonly\n         */\n        this.schema = null;\n        /**\n         * The resolved JSON references\n         *\n         * @type {$Refs}\n         * @readonly\n         */\n        this.$refs = new refs_js_1.default();\n    }\n    async parse() {\n        const args = (0, normalize_args_js_1.default)(arguments);\n        let promise;\n        if (!args.path && !args.schema) {\n            const err = (0, ono_1.ono)(`Expected a file path, URL, or object. Got ${args.path || args.schema}`);\n            return (0, maybe_js_1.default)(args.callback, Promise.reject(err));\n        }\n        // Reset everything\n        this.schema = null;\n        this.$refs = new refs_js_1.default();\n        // If the path is a filesystem path, then convert it to a URL.\n        // NOTE: According to the JSON Reference spec, these should already be URLs,\n        // but, in practice, many people use local filesystem paths instead.\n        // So we're being generous here and doing the conversion automatically.\n        // This is not intended to be a 100% bulletproof solution.\n        // If it doesn't work for your use-case, then use a URL instead.\n        let pathType = \"http\";\n        if (url.isFileSystemPath(args.path)) {\n            args.path = url.fromFileSystemPath(args.path);\n            pathType = \"file\";\n        }\n        else if (!args.path && args.schema && \"$id\" in args.schema && args.schema.$id) {\n            // when schema id has defined an URL should use that hostname to request the references,\n            // instead of using the current page URL\n            const params = url.parse(args.schema.$id);\n            const port = params.protocol === \"https:\" ? 443 : 80;\n            args.path = `${params.protocol}//${params.hostname}:${port}`;\n        }\n        // Resolve the absolute path of the schema\n        args.path = url.resolve(url.cwd(), args.path);\n        if (args.schema && typeof args.schema === \"object\") {\n            // A schema object was passed-in.\n            // So immediately add a new $Ref with the schema object as its value\n            const $ref = this.$refs._add(args.path);\n            $ref.value = args.schema;\n            $ref.pathType = pathType;\n            promise = Promise.resolve(args.schema);\n        }\n        else {\n            // Parse the schema file/url\n            promise = (0, parse_js_1.default)(args.path, this.$refs, args.options);\n        }\n        try {\n            const result = await promise;\n            if (result !== null && typeof result === \"object\" && !Buffer.isBuffer(result)) {\n                this.schema = result;\n                return (0, maybe_js_1.default)(args.callback, Promise.resolve(this.schema));\n            }\n            else if (args.options.continueOnError) {\n                this.schema = null; // it's already set to null at line 79, but let's set it again for the sake of readability\n                return (0, maybe_js_1.default)(args.callback, Promise.resolve(this.schema));\n            }\n            else {\n                throw ono_1.ono.syntax(`\"${this.$refs._root$Ref.path || result}\" is not a valid JSON Schema`);\n            }\n        }\n        catch (err) {\n            if (!args.options.continueOnError || !(0, errors_js_1.isHandledError)(err)) {\n                return (0, maybe_js_1.default)(args.callback, Promise.reject(err));\n            }\n            if (this.$refs._$refs[url.stripHash(args.path)]) {\n                this.$refs._$refs[url.stripHash(args.path)].addError(err);\n            }\n            return (0, maybe_js_1.default)(args.callback, Promise.resolve(null));\n        }\n    }\n    static parse() {\n        const parser = new $RefParser();\n        return parser.parse.apply(parser, arguments);\n    }\n    async resolve() {\n        const args = (0, normalize_args_js_1.default)(arguments);\n        try {\n            await this.parse(args.path, args.schema, args.options);\n            await (0, resolve_external_js_1.default)(this, args.options);\n            finalize(this);\n            return (0, maybe_js_1.default)(args.callback, Promise.resolve(this.$refs));\n        }\n        catch (err) {\n            return (0, maybe_js_1.default)(args.callback, Promise.reject(err));\n        }\n    }\n    static resolve() {\n        const instance = new $RefParser();\n        return instance.resolve.apply(instance, arguments);\n    }\n    static bundle() {\n        const instance = new $RefParser();\n        return instance.bundle.apply(instance, arguments);\n    }\n    async bundle() {\n        const args = (0, normalize_args_js_1.default)(arguments);\n        try {\n            await this.resolve(args.path, args.schema, args.options);\n            (0, bundle_js_1.default)(this, args.options);\n            finalize(this);\n            return (0, maybe_js_1.default)(args.callback, Promise.resolve(this.schema));\n        }\n        catch (err) {\n            return (0, maybe_js_1.default)(args.callback, Promise.reject(err));\n        }\n    }\n    static dereference() {\n        const instance = new $RefParser();\n        return instance.dereference.apply(instance, arguments);\n    }\n    async dereference() {\n        const args = (0, normalize_args_js_1.default)(arguments);\n        try {\n            await this.resolve(args.path, args.schema, args.options);\n            (0, dereference_js_1.default)(this, args.options);\n            finalize(this);\n            return (0, maybe_js_1.default)(args.callback, Promise.resolve(this.schema));\n        }\n        catch (err) {\n            return (0, maybe_js_1.default)(args.callback, Promise.reject(err));\n        }\n    }\n}\nexports.$RefParser = $RefParser;\nexports[\"default\"] = $RefParser;\nfunction finalize(parser) {\n    const errors = errors_js_1.JSONParserErrorGroup.getParserErrors(parser);\n    if (errors.length > 0) {\n        throw new errors_js_1.JSONParserErrorGroup(parser);\n    }\n}\nexports.parse = $RefParser.parse;\nexports.resolve = $RefParser.resolve;\nexports.bundle = $RefParser.bundle;\nexports.dereference = $RefParser.dereference;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNEJBQTRCLEdBQUcsc0JBQXNCLEdBQUcsNEJBQTRCLEdBQUcsbUJBQW1CLEdBQUcscUJBQXFCLEdBQUcsMkJBQTJCLEdBQUcsMkJBQTJCLEdBQUcsdUJBQXVCLEdBQUcsOEJBQThCLEdBQUcsbUJBQW1CLEdBQUcsY0FBYyxHQUFHLGVBQWUsR0FBRyxhQUFhLEdBQUcsa0JBQWtCO0FBQ3ZWLGtDQUFrQyxtQkFBTyxDQUFDLDRGQUFXO0FBQ3JELG1DQUFtQyxtQkFBTyxDQUFDLDhGQUFZO0FBQ3ZELDRDQUE0QyxtQkFBTyxDQUFDLGdIQUFxQjtBQUN6RSw4Q0FBOEMsbUJBQU8sQ0FBQyxvSEFBdUI7QUFDN0Usb0NBQW9DLG1CQUFPLENBQUMsZ0dBQWE7QUFDekQseUNBQXlDLG1CQUFPLENBQUMsMEdBQWtCO0FBQ25FLHlCQUF5QixtQkFBTyxDQUFDLG9HQUFlO0FBQ2hELG9CQUFvQixtQkFBTyxDQUFDLDBHQUFrQjtBQUM5QyxtREFBa0QsRUFBRSxxQ0FBcUMsdUNBQXVDLEVBQUM7QUFDakksdURBQXNELEVBQUUscUNBQXFDLDJDQUEyQyxFQUFDO0FBQ3pJLHVEQUFzRCxFQUFFLHFDQUFxQywyQ0FBMkMsRUFBQztBQUN6SSxpREFBZ0QsRUFBRSxxQ0FBcUMscUNBQXFDLEVBQUM7QUFDN0gsK0NBQThDLEVBQUUscUNBQXFDLG1DQUFtQyxFQUFDO0FBQ3pILHdEQUF1RCxFQUFFLHFDQUFxQyw0Q0FBNEMsRUFBQztBQUMzSSwwREFBeUQsRUFBRSxxQ0FBcUMsOENBQThDLEVBQUM7QUFDL0ksa0RBQWlELEVBQUUscUNBQXFDLHNDQUFzQyxFQUFDO0FBQy9ILHdEQUF1RCxFQUFFLHFDQUFxQyw0Q0FBNEMsRUFBQztBQUMzSSxjQUFjLG1CQUFPLENBQUMsMEVBQWlCO0FBQ3ZDLG1DQUFtQyxtQkFBTyxDQUFDLHdHQUFpQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLHlCQUF5QjtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsZ0JBQWdCLElBQUksZ0JBQWdCLEdBQUcsS0FBSztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsb0NBQW9DO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsZUFBZTtBQUNmLGNBQWM7QUFDZCxtQkFBbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaGF0Ym90LXVpLy4vbm9kZV9tb2R1bGVzL0BhcGlkZXZ0b29scy9qc29uLXNjaGVtYS1yZWYtcGFyc2VyL2Rpc3QvbGliL2luZGV4LmpzPzk0MjIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSlNPTlBhcnNlckVycm9yR3JvdXAgPSBleHBvcnRzLmlzSGFuZGxlZEVycm9yID0gZXhwb3J0cy5Vbm1hdGNoZWRQYXJzZXJFcnJvciA9IGV4cG9ydHMuUGFyc2VyRXJyb3IgPSBleHBvcnRzLlJlc29sdmVyRXJyb3IgPSBleHBvcnRzLk1pc3NpbmdQb2ludGVyRXJyb3IgPSBleHBvcnRzLkludmFsaWRQb2ludGVyRXJyb3IgPSBleHBvcnRzLkpTT05QYXJzZXJFcnJvciA9IGV4cG9ydHMuVW5tYXRjaGVkUmVzb2x2ZXJFcnJvciA9IGV4cG9ydHMuZGVyZWZlcmVuY2UgPSBleHBvcnRzLmJ1bmRsZSA9IGV4cG9ydHMucmVzb2x2ZSA9IGV4cG9ydHMucGFyc2UgPSBleHBvcnRzLiRSZWZQYXJzZXIgPSB2b2lkIDA7XG5jb25zdCByZWZzX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcmVmcy5qc1wiKSk7XG5jb25zdCBwYXJzZV9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3BhcnNlLmpzXCIpKTtcbmNvbnN0IG5vcm1hbGl6ZV9hcmdzX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vbm9ybWFsaXplLWFyZ3MuanNcIikpO1xuY29uc3QgcmVzb2x2ZV9leHRlcm5hbF9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3Jlc29sdmUtZXh0ZXJuYWwuanNcIikpO1xuY29uc3QgYnVuZGxlX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vYnVuZGxlLmpzXCIpKTtcbmNvbnN0IGRlcmVmZXJlbmNlX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vZGVyZWZlcmVuY2UuanNcIikpO1xuY29uc3QgdXJsID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWwvdXJsLmpzXCIpKTtcbmNvbnN0IGVycm9yc19qc18xID0gcmVxdWlyZShcIi4vdXRpbC9lcnJvcnMuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJKU09OUGFyc2VyRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVycm9yc19qc18xLkpTT05QYXJzZXJFcnJvcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkludmFsaWRQb2ludGVyRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVycm9yc19qc18xLkludmFsaWRQb2ludGVyRXJyb3I7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNaXNzaW5nUG9pbnRlckVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlcnJvcnNfanNfMS5NaXNzaW5nUG9pbnRlckVycm9yOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVzb2x2ZXJFcnJvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXJyb3JzX2pzXzEuUmVzb2x2ZXJFcnJvcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBhcnNlckVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlcnJvcnNfanNfMS5QYXJzZXJFcnJvcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVubWF0Y2hlZFBhcnNlckVycm9yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlcnJvcnNfanNfMS5Vbm1hdGNoZWRQYXJzZXJFcnJvcjsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVubWF0Y2hlZFJlc29sdmVyRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVycm9yc19qc18xLlVubWF0Y2hlZFJlc29sdmVyRXJyb3I7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0hhbmRsZWRFcnJvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXJyb3JzX2pzXzEuaXNIYW5kbGVkRXJyb3I7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJKU09OUGFyc2VyRXJyb3JHcm91cFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZXJyb3JzX2pzXzEuSlNPTlBhcnNlckVycm9yR3JvdXA7IH0gfSk7XG5jb25zdCBvbm9fMSA9IHJlcXVpcmUoXCJAanNkZXZ0b29scy9vbm9cIik7XG5jb25zdCBtYXliZV9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWwvbWF5YmUuanNcIikpO1xuLyoqXG4gKiBUaGlzIGNsYXNzIHBhcnNlcyBhIEpTT04gc2NoZW1hLCBidWlsZHMgYSBtYXAgb2YgaXRzIEpTT04gcmVmZXJlbmNlcyBhbmQgdGhlaXIgcmVzb2x2ZWQgdmFsdWVzLFxuICogYW5kIHByb3ZpZGVzIG1ldGhvZHMgZm9yIHRyYXZlcnNpbmcsIG1hbmlwdWxhdGluZywgYW5kIGRlcmVmZXJlbmNpbmcgdGhvc2UgcmVmZXJlbmNlcy5cbiAqXG4gKiBAY2xhc3NcbiAqL1xuY2xhc3MgJFJlZlBhcnNlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcGFyc2VkIChhbmQgcG9zc2libHkgZGVyZWZlcmVuY2VkKSBKU09OIHNjaGVtYSBvYmplY3RcbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge29iamVjdH1cbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNjaGVtYSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgcmVzb2x2ZWQgSlNPTiByZWZlcmVuY2VzXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHskUmVmc31cbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLiRyZWZzID0gbmV3IHJlZnNfanNfMS5kZWZhdWx0KCk7XG4gICAgfVxuICAgIGFzeW5jIHBhcnNlKCkge1xuICAgICAgICBjb25zdCBhcmdzID0gKDAsIG5vcm1hbGl6ZV9hcmdzX2pzXzEuZGVmYXVsdCkoYXJndW1lbnRzKTtcbiAgICAgICAgbGV0IHByb21pc2U7XG4gICAgICAgIGlmICghYXJncy5wYXRoICYmICFhcmdzLnNjaGVtYSkge1xuICAgICAgICAgICAgY29uc3QgZXJyID0gKDAsIG9ub18xLm9ubykoYEV4cGVjdGVkIGEgZmlsZSBwYXRoLCBVUkwsIG9yIG9iamVjdC4gR290ICR7YXJncy5wYXRoIHx8IGFyZ3Muc2NoZW1hfWApO1xuICAgICAgICAgICAgcmV0dXJuICgwLCBtYXliZV9qc18xLmRlZmF1bHQpKGFyZ3MuY2FsbGJhY2ssIFByb21pc2UucmVqZWN0KGVycikpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlc2V0IGV2ZXJ5dGhpbmdcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBudWxsO1xuICAgICAgICB0aGlzLiRyZWZzID0gbmV3IHJlZnNfanNfMS5kZWZhdWx0KCk7XG4gICAgICAgIC8vIElmIHRoZSBwYXRoIGlzIGEgZmlsZXN5c3RlbSBwYXRoLCB0aGVuIGNvbnZlcnQgaXQgdG8gYSBVUkwuXG4gICAgICAgIC8vIE5PVEU6IEFjY29yZGluZyB0byB0aGUgSlNPTiBSZWZlcmVuY2Ugc3BlYywgdGhlc2Ugc2hvdWxkIGFscmVhZHkgYmUgVVJMcyxcbiAgICAgICAgLy8gYnV0LCBpbiBwcmFjdGljZSwgbWFueSBwZW9wbGUgdXNlIGxvY2FsIGZpbGVzeXN0ZW0gcGF0aHMgaW5zdGVhZC5cbiAgICAgICAgLy8gU28gd2UncmUgYmVpbmcgZ2VuZXJvdXMgaGVyZSBhbmQgZG9pbmcgdGhlIGNvbnZlcnNpb24gYXV0b21hdGljYWxseS5cbiAgICAgICAgLy8gVGhpcyBpcyBub3QgaW50ZW5kZWQgdG8gYmUgYSAxMDAlIGJ1bGxldHByb29mIHNvbHV0aW9uLlxuICAgICAgICAvLyBJZiBpdCBkb2Vzbid0IHdvcmsgZm9yIHlvdXIgdXNlLWNhc2UsIHRoZW4gdXNlIGEgVVJMIGluc3RlYWQuXG4gICAgICAgIGxldCBwYXRoVHlwZSA9IFwiaHR0cFwiO1xuICAgICAgICBpZiAodXJsLmlzRmlsZVN5c3RlbVBhdGgoYXJncy5wYXRoKSkge1xuICAgICAgICAgICAgYXJncy5wYXRoID0gdXJsLmZyb21GaWxlU3lzdGVtUGF0aChhcmdzLnBhdGgpO1xuICAgICAgICAgICAgcGF0aFR5cGUgPSBcImZpbGVcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghYXJncy5wYXRoICYmIGFyZ3Muc2NoZW1hICYmIFwiJGlkXCIgaW4gYXJncy5zY2hlbWEgJiYgYXJncy5zY2hlbWEuJGlkKSB7XG4gICAgICAgICAgICAvLyB3aGVuIHNjaGVtYSBpZCBoYXMgZGVmaW5lZCBhbiBVUkwgc2hvdWxkIHVzZSB0aGF0IGhvc3RuYW1lIHRvIHJlcXVlc3QgdGhlIHJlZmVyZW5jZXMsXG4gICAgICAgICAgICAvLyBpbnN0ZWFkIG9mIHVzaW5nIHRoZSBjdXJyZW50IHBhZ2UgVVJMXG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSB1cmwucGFyc2UoYXJncy5zY2hlbWEuJGlkKTtcbiAgICAgICAgICAgIGNvbnN0IHBvcnQgPSBwYXJhbXMucHJvdG9jb2wgPT09IFwiaHR0cHM6XCIgPyA0NDMgOiA4MDtcbiAgICAgICAgICAgIGFyZ3MucGF0aCA9IGAke3BhcmFtcy5wcm90b2NvbH0vLyR7cGFyYW1zLmhvc3RuYW1lfToke3BvcnR9YDtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXNvbHZlIHRoZSBhYnNvbHV0ZSBwYXRoIG9mIHRoZSBzY2hlbWFcbiAgICAgICAgYXJncy5wYXRoID0gdXJsLnJlc29sdmUodXJsLmN3ZCgpLCBhcmdzLnBhdGgpO1xuICAgICAgICBpZiAoYXJncy5zY2hlbWEgJiYgdHlwZW9mIGFyZ3Muc2NoZW1hID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAvLyBBIHNjaGVtYSBvYmplY3Qgd2FzIHBhc3NlZC1pbi5cbiAgICAgICAgICAgIC8vIFNvIGltbWVkaWF0ZWx5IGFkZCBhIG5ldyAkUmVmIHdpdGggdGhlIHNjaGVtYSBvYmplY3QgYXMgaXRzIHZhbHVlXG4gICAgICAgICAgICBjb25zdCAkcmVmID0gdGhpcy4kcmVmcy5fYWRkKGFyZ3MucGF0aCk7XG4gICAgICAgICAgICAkcmVmLnZhbHVlID0gYXJncy5zY2hlbWE7XG4gICAgICAgICAgICAkcmVmLnBhdGhUeXBlID0gcGF0aFR5cGU7XG4gICAgICAgICAgICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGFyZ3Muc2NoZW1hKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBzY2hlbWEgZmlsZS91cmxcbiAgICAgICAgICAgIHByb21pc2UgPSAoMCwgcGFyc2VfanNfMS5kZWZhdWx0KShhcmdzLnBhdGgsIHRoaXMuJHJlZnMsIGFyZ3Mub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHByb21pc2U7XG4gICAgICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsICYmIHR5cGVvZiByZXN1bHQgPT09IFwib2JqZWN0XCIgJiYgIUJ1ZmZlci5pc0J1ZmZlcihyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2hlbWEgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBtYXliZV9qc18xLmRlZmF1bHQpKGFyZ3MuY2FsbGJhY2ssIFByb21pc2UucmVzb2x2ZSh0aGlzLnNjaGVtYSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYXJncy5vcHRpb25zLmNvbnRpbnVlT25FcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuc2NoZW1hID0gbnVsbDsgLy8gaXQncyBhbHJlYWR5IHNldCB0byBudWxsIGF0IGxpbmUgNzksIGJ1dCBsZXQncyBzZXQgaXQgYWdhaW4gZm9yIHRoZSBzYWtlIG9mIHJlYWRhYmlsaXR5XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBtYXliZV9qc18xLmRlZmF1bHQpKGFyZ3MuY2FsbGJhY2ssIFByb21pc2UucmVzb2x2ZSh0aGlzLnNjaGVtYSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgb25vXzEub25vLnN5bnRheChgXCIke3RoaXMuJHJlZnMuX3Jvb3QkUmVmLnBhdGggfHwgcmVzdWx0fVwiIGlzIG5vdCBhIHZhbGlkIEpTT04gU2NoZW1hYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKCFhcmdzLm9wdGlvbnMuY29udGludWVPbkVycm9yIHx8ICEoMCwgZXJyb3JzX2pzXzEuaXNIYW5kbGVkRXJyb3IpKGVycikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIG1heWJlX2pzXzEuZGVmYXVsdCkoYXJncy5jYWxsYmFjaywgUHJvbWlzZS5yZWplY3QoZXJyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy4kcmVmcy5fJHJlZnNbdXJsLnN0cmlwSGFzaChhcmdzLnBhdGgpXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJHJlZnMuXyRyZWZzW3VybC5zdHJpcEhhc2goYXJncy5wYXRoKV0uYWRkRXJyb3IoZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoMCwgbWF5YmVfanNfMS5kZWZhdWx0KShhcmdzLmNhbGxiYWNrLCBQcm9taXNlLnJlc29sdmUobnVsbCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZSgpIHtcbiAgICAgICAgY29uc3QgcGFyc2VyID0gbmV3ICRSZWZQYXJzZXIoKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlci5wYXJzZS5hcHBseShwYXJzZXIsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGFzeW5jIHJlc29sdmUoKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSAoMCwgbm9ybWFsaXplX2FyZ3NfanNfMS5kZWZhdWx0KShhcmd1bWVudHMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wYXJzZShhcmdzLnBhdGgsIGFyZ3Muc2NoZW1hLCBhcmdzLm9wdGlvbnMpO1xuICAgICAgICAgICAgYXdhaXQgKDAsIHJlc29sdmVfZXh0ZXJuYWxfanNfMS5kZWZhdWx0KSh0aGlzLCBhcmdzLm9wdGlvbnMpO1xuICAgICAgICAgICAgZmluYWxpemUodGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gKDAsIG1heWJlX2pzXzEuZGVmYXVsdCkoYXJncy5jYWxsYmFjaywgUHJvbWlzZS5yZXNvbHZlKHRoaXMuJHJlZnMpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIG1heWJlX2pzXzEuZGVmYXVsdCkoYXJncy5jYWxsYmFjaywgUHJvbWlzZS5yZWplY3QoZXJyKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIHJlc29sdmUoKSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gbmV3ICRSZWZQYXJzZXIoKTtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLnJlc29sdmUuYXBwbHkoaW5zdGFuY2UsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIHN0YXRpYyBidW5kbGUoKSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gbmV3ICRSZWZQYXJzZXIoKTtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLmJ1bmRsZS5hcHBseShpbnN0YW5jZSwgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgYXN5bmMgYnVuZGxlKCkge1xuICAgICAgICBjb25zdCBhcmdzID0gKDAsIG5vcm1hbGl6ZV9hcmdzX2pzXzEuZGVmYXVsdCkoYXJndW1lbnRzKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMucmVzb2x2ZShhcmdzLnBhdGgsIGFyZ3Muc2NoZW1hLCBhcmdzLm9wdGlvbnMpO1xuICAgICAgICAgICAgKDAsIGJ1bmRsZV9qc18xLmRlZmF1bHQpKHRoaXMsIGFyZ3Mub3B0aW9ucyk7XG4gICAgICAgICAgICBmaW5hbGl6ZSh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgbWF5YmVfanNfMS5kZWZhdWx0KShhcmdzLmNhbGxiYWNrLCBQcm9taXNlLnJlc29sdmUodGhpcy5zY2hlbWEpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIG1heWJlX2pzXzEuZGVmYXVsdCkoYXJncy5jYWxsYmFjaywgUHJvbWlzZS5yZWplY3QoZXJyKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGRlcmVmZXJlbmNlKCkge1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IG5ldyAkUmVmUGFyc2VyKCk7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZS5kZXJlZmVyZW5jZS5hcHBseShpbnN0YW5jZSwgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgYXN5bmMgZGVyZWZlcmVuY2UoKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSAoMCwgbm9ybWFsaXplX2FyZ3NfanNfMS5kZWZhdWx0KShhcmd1bWVudHMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5yZXNvbHZlKGFyZ3MucGF0aCwgYXJncy5zY2hlbWEsIGFyZ3Mub3B0aW9ucyk7XG4gICAgICAgICAgICAoMCwgZGVyZWZlcmVuY2VfanNfMS5kZWZhdWx0KSh0aGlzLCBhcmdzLm9wdGlvbnMpO1xuICAgICAgICAgICAgZmluYWxpemUodGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gKDAsIG1heWJlX2pzXzEuZGVmYXVsdCkoYXJncy5jYWxsYmFjaywgUHJvbWlzZS5yZXNvbHZlKHRoaXMuc2NoZW1hKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuICgwLCBtYXliZV9qc18xLmRlZmF1bHQpKGFyZ3MuY2FsbGJhY2ssIFByb21pc2UucmVqZWN0KGVycikpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy4kUmVmUGFyc2VyID0gJFJlZlBhcnNlcjtcbmV4cG9ydHMuZGVmYXVsdCA9ICRSZWZQYXJzZXI7XG5mdW5jdGlvbiBmaW5hbGl6ZShwYXJzZXIpIHtcbiAgICBjb25zdCBlcnJvcnMgPSBlcnJvcnNfanNfMS5KU09OUGFyc2VyRXJyb3JHcm91cC5nZXRQYXJzZXJFcnJvcnMocGFyc2VyKTtcbiAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc19qc18xLkpTT05QYXJzZXJFcnJvckdyb3VwKHBhcnNlcik7XG4gICAgfVxufVxuZXhwb3J0cy5wYXJzZSA9ICRSZWZQYXJzZXIucGFyc2U7XG5leHBvcnRzLnJlc29sdmUgPSAkUmVmUGFyc2VyLnJlc29sdmU7XG5leHBvcnRzLmJ1bmRsZSA9ICRSZWZQYXJzZXIuYnVuZGxlO1xuZXhwb3J0cy5kZXJlZmVyZW5jZSA9ICRSZWZQYXJzZXIuZGVyZWZlcmVuY2U7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/normalize-args.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/normalize-args.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.normalizeArgs = normalizeArgs;\nconst options_js_1 = __webpack_require__(/*! ./options.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/options.js\");\n/**\n * Normalizes the given arguments, accounting for optional args.\n */\nfunction normalizeArgs(_args) {\n    let path;\n    let schema;\n    let options;\n    let callback;\n    const args = Array.prototype.slice.call(_args);\n    if (typeof args[args.length - 1] === \"function\") {\n        // The last parameter is a callback function\n        callback = args.pop();\n    }\n    if (typeof args[0] === \"string\") {\n        // The first parameter is the path\n        path = args[0];\n        if (typeof args[2] === \"object\") {\n            // The second parameter is the schema, and the third parameter is the options\n            schema = args[1];\n            options = args[2];\n        }\n        else {\n            // The second parameter is the options\n            schema = undefined;\n            options = args[1];\n        }\n    }\n    else {\n        // The first parameter is the schema\n        path = \"\";\n        schema = args[0];\n        options = args[1];\n    }\n    try {\n        options = (0, options_js_1.getNewOptions)(options);\n    }\n    catch (e) {\n        console.error(`JSON Schema Ref Parser: Error normalizing options: ${e}`);\n    }\n    if (!options.mutateInputSchema && typeof schema === \"object\") {\n        // Make a deep clone of the schema, so that we don't alter the original object\n        schema = JSON.parse(JSON.stringify(schema));\n    }\n    return {\n        path,\n        schema,\n        options,\n        callback,\n    };\n}\nexports[\"default\"] = normalizeArgs;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvbm9ybWFsaXplLWFyZ3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCO0FBQ3JCLHFCQUFxQixtQkFBTyxDQUFDLGtHQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLEVBQUU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaGF0Ym90LXVpLy4vbm9kZV9tb2R1bGVzL0BhcGlkZXZ0b29scy9qc29uLXNjaGVtYS1yZWYtcGFyc2VyL2Rpc3QvbGliL25vcm1hbGl6ZS1hcmdzLmpzP2YwN2IiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm5vcm1hbGl6ZUFyZ3MgPSBub3JtYWxpemVBcmdzO1xuY29uc3Qgb3B0aW9uc19qc18xID0gcmVxdWlyZShcIi4vb3B0aW9ucy5qc1wiKTtcbi8qKlxuICogTm9ybWFsaXplcyB0aGUgZ2l2ZW4gYXJndW1lbnRzLCBhY2NvdW50aW5nIGZvciBvcHRpb25hbCBhcmdzLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVBcmdzKF9hcmdzKSB7XG4gICAgbGV0IHBhdGg7XG4gICAgbGV0IHNjaGVtYTtcbiAgICBsZXQgb3B0aW9ucztcbiAgICBsZXQgY2FsbGJhY2s7XG4gICAgY29uc3QgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKF9hcmdzKTtcbiAgICBpZiAodHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIC8vIFRoZSBsYXN0IHBhcmFtZXRlciBpcyBhIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhcmdzWzBdID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIC8vIFRoZSBmaXJzdCBwYXJhbWV0ZXIgaXMgdGhlIHBhdGhcbiAgICAgICAgcGF0aCA9IGFyZ3NbMF07XG4gICAgICAgIGlmICh0eXBlb2YgYXJnc1syXSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgLy8gVGhlIHNlY29uZCBwYXJhbWV0ZXIgaXMgdGhlIHNjaGVtYSwgYW5kIHRoZSB0aGlyZCBwYXJhbWV0ZXIgaXMgdGhlIG9wdGlvbnNcbiAgICAgICAgICAgIHNjaGVtYSA9IGFyZ3NbMV07XG4gICAgICAgICAgICBvcHRpb25zID0gYXJnc1syXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoZSBzZWNvbmQgcGFyYW1ldGVyIGlzIHRoZSBvcHRpb25zXG4gICAgICAgICAgICBzY2hlbWEgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBvcHRpb25zID0gYXJnc1sxXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gVGhlIGZpcnN0IHBhcmFtZXRlciBpcyB0aGUgc2NoZW1hXG4gICAgICAgIHBhdGggPSBcIlwiO1xuICAgICAgICBzY2hlbWEgPSBhcmdzWzBdO1xuICAgICAgICBvcHRpb25zID0gYXJnc1sxXTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgb3B0aW9ucyA9ICgwLCBvcHRpb25zX2pzXzEuZ2V0TmV3T3B0aW9ucykob3B0aW9ucyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEpTT04gU2NoZW1hIFJlZiBQYXJzZXI6IEVycm9yIG5vcm1hbGl6aW5nIG9wdGlvbnM6ICR7ZX1gKTtcbiAgICB9XG4gICAgaWYgKCFvcHRpb25zLm11dGF0ZUlucHV0U2NoZW1hICYmIHR5cGVvZiBzY2hlbWEgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgLy8gTWFrZSBhIGRlZXAgY2xvbmUgb2YgdGhlIHNjaGVtYSwgc28gdGhhdCB3ZSBkb24ndCBhbHRlciB0aGUgb3JpZ2luYWwgb2JqZWN0XG4gICAgICAgIHNjaGVtYSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc2NoZW1hKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHBhdGgsXG4gICAgICAgIHNjaGVtYSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgY2FsbGJhY2ssXG4gICAgfTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IG5vcm1hbGl6ZUFyZ3M7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/normalize-args.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/options.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/options.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getNewOptions = exports.getJsonSchemaRefParserDefaultOptions = void 0;\nconst json_js_1 = __importDefault(__webpack_require__(/*! ./parsers/json.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/json.js\"));\nconst yaml_js_1 = __importDefault(__webpack_require__(/*! ./parsers/yaml.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/yaml.js\"));\nconst text_js_1 = __importDefault(__webpack_require__(/*! ./parsers/text.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/text.js\"));\nconst binary_js_1 = __importDefault(__webpack_require__(/*! ./parsers/binary.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/binary.js\"));\nconst file_js_1 = __importDefault(__webpack_require__(/*! ./resolvers/file.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/resolvers/file.js\"));\nconst http_js_1 = __importDefault(__webpack_require__(/*! ./resolvers/http.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/resolvers/http.js\"));\nconst getJsonSchemaRefParserDefaultOptions = () => {\n    const defaults = {\n        /**\n         * Determines how different types of files will be parsed.\n         *\n         * You can add additional parsers of your own, replace an existing one with\n         * your own implementation, or disable any parser by setting it to false.\n         */\n        parse: {\n            json: { ...json_js_1.default },\n            yaml: { ...yaml_js_1.default },\n            text: { ...text_js_1.default },\n            binary: { ...binary_js_1.default },\n        },\n        /**\n         * Determines how JSON References will be resolved.\n         *\n         * You can add additional resolvers of your own, replace an existing one with\n         * your own implementation, or disable any resolver by setting it to false.\n         */\n        resolve: {\n            file: { ...file_js_1.default },\n            http: { ...http_js_1.default },\n            /**\n             * Determines whether external $ref pointers will be resolved.\n             * If this option is disabled, then none of above resolvers will be called.\n             * Instead, external $ref pointers will simply be ignored.\n             *\n             * @type {boolean}\n             */\n            external: true,\n        },\n        /**\n         * By default, JSON Schema $Ref Parser throws the first error it encounters. Setting `continueOnError` to `true`\n         * causes it to keep processing as much as possible and then throw a single error that contains all errors\n         * that were encountered.\n         */\n        continueOnError: false,\n        /**\n         * Determines the types of JSON references that are allowed.\n         */\n        dereference: {\n            /**\n             * Dereference circular (recursive) JSON references?\n             * If false, then a {@link ReferenceError} will be thrown if a circular reference is found.\n             * If \"ignore\", then circular references will not be dereferenced.\n             *\n             * @type {boolean|string}\n             */\n            circular: true,\n            /**\n             * A function, called for each path, which can return true to stop this path and all\n             * subpaths from being dereferenced further. This is useful in schemas where some\n             * subpaths contain literal $ref keys that should not be dereferenced.\n             *\n             * @type {function}\n             */\n            excludedPathMatcher: () => false,\n            referenceResolution: \"relative\",\n        },\n        mutateInputSchema: true,\n    };\n    return defaults;\n};\nexports.getJsonSchemaRefParserDefaultOptions = getJsonSchemaRefParserDefaultOptions;\nconst getNewOptions = (options) => {\n    const newOptions = (0, exports.getJsonSchemaRefParserDefaultOptions)();\n    if (options) {\n        merge(newOptions, options);\n    }\n    return newOptions;\n};\nexports.getNewOptions = getNewOptions;\n/**\n * Merges the properties of the source object into the target object.\n *\n * @param target - The object that we're populating\n * @param source - The options that are being merged\n * @returns\n */\nfunction merge(target, source) {\n    if (isMergeable(source)) {\n        // prevent prototype pollution\n        const keys = Object.keys(source).filter((key) => ![\"__proto__\", \"constructor\", \"prototype\"].includes(key));\n        for (let i = 0; i < keys.length; i++) {\n            const key = keys[i];\n            const sourceSetting = source[key];\n            const targetSetting = target[key];\n            if (isMergeable(sourceSetting)) {\n                // It's a nested object, so merge it recursively\n                target[key] = merge(targetSetting || {}, sourceSetting);\n            }\n            else if (sourceSetting !== undefined) {\n                // It's a scalar value, function, or array. No merging necessary. Just overwrite the target value.\n                target[key] = sourceSetting;\n            }\n        }\n    }\n    return target;\n}\n/**\n * Determines whether the given value can be merged,\n * or if it is a scalar value that should just override the target value.\n *\n * @param val\n * @returns\n */\nfunction isMergeable(val) {\n    return val && typeof val === \"object\" && !Array.isArray(val) && !(val instanceof RegExp) && !(val instanceof Date);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvb3B0aW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQixHQUFHLDRDQUE0QztBQUNwRSxrQ0FBa0MsbUJBQU8sQ0FBQyw0R0FBbUI7QUFDN0Qsa0NBQWtDLG1CQUFPLENBQUMsNEdBQW1CO0FBQzdELGtDQUFrQyxtQkFBTyxDQUFDLDRHQUFtQjtBQUM3RCxvQ0FBb0MsbUJBQU8sQ0FBQyxnSEFBcUI7QUFDakUsa0NBQWtDLG1CQUFPLENBQUMsZ0hBQXFCO0FBQy9ELGtDQUFrQyxtQkFBTyxDQUFDLGdIQUFxQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDLG9CQUFvQixzQkFBc0I7QUFDMUMsb0JBQW9CLHNCQUFzQjtBQUMxQyxzQkFBc0Isd0JBQXdCO0FBQzlDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUMsb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHNCQUFzQjtBQUN2RDtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2hhdGJvdC11aS8uL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kaXN0L2xpYi9vcHRpb25zLmpzPzlhNTEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldE5ld09wdGlvbnMgPSBleHBvcnRzLmdldEpzb25TY2hlbWFSZWZQYXJzZXJEZWZhdWx0T3B0aW9ucyA9IHZvaWQgMDtcbmNvbnN0IGpzb25fanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9wYXJzZXJzL2pzb24uanNcIikpO1xuY29uc3QgeWFtbF9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3BhcnNlcnMveWFtbC5qc1wiKSk7XG5jb25zdCB0ZXh0X2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcGFyc2Vycy90ZXh0LmpzXCIpKTtcbmNvbnN0IGJpbmFyeV9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3BhcnNlcnMvYmluYXJ5LmpzXCIpKTtcbmNvbnN0IGZpbGVfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9yZXNvbHZlcnMvZmlsZS5qc1wiKSk7XG5jb25zdCBodHRwX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcmVzb2x2ZXJzL2h0dHAuanNcIikpO1xuY29uc3QgZ2V0SnNvblNjaGVtYVJlZlBhcnNlckRlZmF1bHRPcHRpb25zID0gKCkgPT4ge1xuICAgIGNvbnN0IGRlZmF1bHRzID0ge1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lcyBob3cgZGlmZmVyZW50IHR5cGVzIG9mIGZpbGVzIHdpbGwgYmUgcGFyc2VkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBZb3UgY2FuIGFkZCBhZGRpdGlvbmFsIHBhcnNlcnMgb2YgeW91ciBvd24sIHJlcGxhY2UgYW4gZXhpc3Rpbmcgb25lIHdpdGhcbiAgICAgICAgICogeW91ciBvd24gaW1wbGVtZW50YXRpb24sIG9yIGRpc2FibGUgYW55IHBhcnNlciBieSBzZXR0aW5nIGl0IHRvIGZhbHNlLlxuICAgICAgICAgKi9cbiAgICAgICAgcGFyc2U6IHtcbiAgICAgICAgICAgIGpzb246IHsgLi4uanNvbl9qc18xLmRlZmF1bHQgfSxcbiAgICAgICAgICAgIHlhbWw6IHsgLi4ueWFtbF9qc18xLmRlZmF1bHQgfSxcbiAgICAgICAgICAgIHRleHQ6IHsgLi4udGV4dF9qc18xLmRlZmF1bHQgfSxcbiAgICAgICAgICAgIGJpbmFyeTogeyAuLi5iaW5hcnlfanNfMS5kZWZhdWx0IH0sXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXRlcm1pbmVzIGhvdyBKU09OIFJlZmVyZW5jZXMgd2lsbCBiZSByZXNvbHZlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogWW91IGNhbiBhZGQgYWRkaXRpb25hbCByZXNvbHZlcnMgb2YgeW91ciBvd24sIHJlcGxhY2UgYW4gZXhpc3Rpbmcgb25lIHdpdGhcbiAgICAgICAgICogeW91ciBvd24gaW1wbGVtZW50YXRpb24sIG9yIGRpc2FibGUgYW55IHJlc29sdmVyIGJ5IHNldHRpbmcgaXQgdG8gZmFsc2UuXG4gICAgICAgICAqL1xuICAgICAgICByZXNvbHZlOiB7XG4gICAgICAgICAgICBmaWxlOiB7IC4uLmZpbGVfanNfMS5kZWZhdWx0IH0sXG4gICAgICAgICAgICBodHRwOiB7IC4uLmh0dHBfanNfMS5kZWZhdWx0IH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERldGVybWluZXMgd2hldGhlciBleHRlcm5hbCAkcmVmIHBvaW50ZXJzIHdpbGwgYmUgcmVzb2x2ZWQuXG4gICAgICAgICAgICAgKiBJZiB0aGlzIG9wdGlvbiBpcyBkaXNhYmxlZCwgdGhlbiBub25lIG9mIGFib3ZlIHJlc29sdmVycyB3aWxsIGJlIGNhbGxlZC5cbiAgICAgICAgICAgICAqIEluc3RlYWQsIGV4dGVybmFsICRyZWYgcG9pbnRlcnMgd2lsbCBzaW1wbHkgYmUgaWdub3JlZC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZXh0ZXJuYWw6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCeSBkZWZhdWx0LCBKU09OIFNjaGVtYSAkUmVmIFBhcnNlciB0aHJvd3MgdGhlIGZpcnN0IGVycm9yIGl0IGVuY291bnRlcnMuIFNldHRpbmcgYGNvbnRpbnVlT25FcnJvcmAgdG8gYHRydWVgXG4gICAgICAgICAqIGNhdXNlcyBpdCB0byBrZWVwIHByb2Nlc3NpbmcgYXMgbXVjaCBhcyBwb3NzaWJsZSBhbmQgdGhlbiB0aHJvdyBhIHNpbmdsZSBlcnJvciB0aGF0IGNvbnRhaW5zIGFsbCBlcnJvcnNcbiAgICAgICAgICogdGhhdCB3ZXJlIGVuY291bnRlcmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgY29udGludWVPbkVycm9yOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZXMgdGhlIHR5cGVzIG9mIEpTT04gcmVmZXJlbmNlcyB0aGF0IGFyZSBhbGxvd2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgZGVyZWZlcmVuY2U6IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRGVyZWZlcmVuY2UgY2lyY3VsYXIgKHJlY3Vyc2l2ZSkgSlNPTiByZWZlcmVuY2VzP1xuICAgICAgICAgICAgICogSWYgZmFsc2UsIHRoZW4gYSB7QGxpbmsgUmVmZXJlbmNlRXJyb3J9IHdpbGwgYmUgdGhyb3duIGlmIGEgY2lyY3VsYXIgcmVmZXJlbmNlIGlzIGZvdW5kLlxuICAgICAgICAgICAgICogSWYgXCJpZ25vcmVcIiwgdGhlbiBjaXJjdWxhciByZWZlcmVuY2VzIHdpbGwgbm90IGJlIGRlcmVmZXJlbmNlZC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbnxzdHJpbmd9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNpcmN1bGFyOiB0cnVlLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBIGZ1bmN0aW9uLCBjYWxsZWQgZm9yIGVhY2ggcGF0aCwgd2hpY2ggY2FuIHJldHVybiB0cnVlIHRvIHN0b3AgdGhpcyBwYXRoIGFuZCBhbGxcbiAgICAgICAgICAgICAqIHN1YnBhdGhzIGZyb20gYmVpbmcgZGVyZWZlcmVuY2VkIGZ1cnRoZXIuIFRoaXMgaXMgdXNlZnVsIGluIHNjaGVtYXMgd2hlcmUgc29tZVxuICAgICAgICAgICAgICogc3VicGF0aHMgY29udGFpbiBsaXRlcmFsICRyZWYga2V5cyB0aGF0IHNob3VsZCBub3QgYmUgZGVyZWZlcmVuY2VkLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZXhjbHVkZWRQYXRoTWF0Y2hlcjogKCkgPT4gZmFsc2UsXG4gICAgICAgICAgICByZWZlcmVuY2VSZXNvbHV0aW9uOiBcInJlbGF0aXZlXCIsXG4gICAgICAgIH0sXG4gICAgICAgIG11dGF0ZUlucHV0U2NoZW1hOiB0cnVlLFxuICAgIH07XG4gICAgcmV0dXJuIGRlZmF1bHRzO1xufTtcbmV4cG9ydHMuZ2V0SnNvblNjaGVtYVJlZlBhcnNlckRlZmF1bHRPcHRpb25zID0gZ2V0SnNvblNjaGVtYVJlZlBhcnNlckRlZmF1bHRPcHRpb25zO1xuY29uc3QgZ2V0TmV3T3B0aW9ucyA9IChvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgbmV3T3B0aW9ucyA9ICgwLCBleHBvcnRzLmdldEpzb25TY2hlbWFSZWZQYXJzZXJEZWZhdWx0T3B0aW9ucykoKTtcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgICBtZXJnZShuZXdPcHRpb25zLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld09wdGlvbnM7XG59O1xuZXhwb3J0cy5nZXROZXdPcHRpb25zID0gZ2V0TmV3T3B0aW9ucztcbi8qKlxuICogTWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBzb3VyY2Ugb2JqZWN0IGludG8gdGhlIHRhcmdldCBvYmplY3QuXG4gKlxuICogQHBhcmFtIHRhcmdldCAtIFRoZSBvYmplY3QgdGhhdCB3ZSdyZSBwb3B1bGF0aW5nXG4gKiBAcGFyYW0gc291cmNlIC0gVGhlIG9wdGlvbnMgdGhhdCBhcmUgYmVpbmcgbWVyZ2VkXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBtZXJnZSh0YXJnZXQsIHNvdXJjZSkge1xuICAgIGlmIChpc01lcmdlYWJsZShzb3VyY2UpKSB7XG4gICAgICAgIC8vIHByZXZlbnQgcHJvdG90eXBlIHBvbGx1dGlvblxuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKS5maWx0ZXIoKGtleSkgPT4gIVtcIl9fcHJvdG9fX1wiLCBcImNvbnN0cnVjdG9yXCIsIFwicHJvdG90eXBlXCJdLmluY2x1ZGVzKGtleSkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VTZXR0aW5nID0gc291cmNlW2tleV07XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRTZXR0aW5nID0gdGFyZ2V0W2tleV07XG4gICAgICAgICAgICBpZiAoaXNNZXJnZWFibGUoc291cmNlU2V0dGluZykpIHtcbiAgICAgICAgICAgICAgICAvLyBJdCdzIGEgbmVzdGVkIG9iamVjdCwgc28gbWVyZ2UgaXQgcmVjdXJzaXZlbHlcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IG1lcmdlKHRhcmdldFNldHRpbmcgfHwge30sIHNvdXJjZVNldHRpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc291cmNlU2V0dGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gSXQncyBhIHNjYWxhciB2YWx1ZSwgZnVuY3Rpb24sIG9yIGFycmF5LiBObyBtZXJnaW5nIG5lY2Vzc2FyeS4gSnVzdCBvdmVyd3JpdGUgdGhlIHRhcmdldCB2YWx1ZS5cbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVNldHRpbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBjYW4gYmUgbWVyZ2VkLFxuICogb3IgaWYgaXQgaXMgYSBzY2FsYXIgdmFsdWUgdGhhdCBzaG91bGQganVzdCBvdmVycmlkZSB0aGUgdGFyZ2V0IHZhbHVlLlxuICpcbiAqIEBwYXJhbSB2YWxcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGlzTWVyZ2VhYmxlKHZhbCkge1xuICAgIHJldHVybiB2YWwgJiYgdHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSh2YWwpICYmICEodmFsIGluc3RhbmNlb2YgUmVnRXhwKSAmJiAhKHZhbCBpbnN0YW5jZW9mIERhdGUpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/options.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parse.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parse.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst ono_1 = __webpack_require__(/*! @jsdevtools/ono */ \"(ssr)/./node_modules/@jsdevtools/ono/esm/index.js\");\nconst url = __importStar(__webpack_require__(/*! ./util/url.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/url.js\"));\nconst plugins = __importStar(__webpack_require__(/*! ./util/plugins.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/plugins.js\"));\nconst errors_js_1 = __webpack_require__(/*! ./util/errors.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/errors.js\");\n/**\n * Reads and parses the specified file path or URL.\n */\nasync function parse(path, $refs, options) {\n    // Remove the URL fragment, if any\n    const hashIndex = path.indexOf(\"#\");\n    let hash = \"\";\n    if (hashIndex >= 0) {\n        hash = path.substring(hashIndex);\n        // Remove the URL fragment, if any\n        path = path.substring(0, hashIndex);\n    }\n    // Add a new $Ref for this file, even though we don't have the value yet.\n    // This ensures that we don't simultaneously read & parse the same file multiple times\n    const $ref = $refs._add(path);\n    // This \"file object\" will be passed to all resolvers and parsers.\n    const file = {\n        url: path,\n        hash,\n        extension: url.getExtension(path),\n    };\n    // Read the file and then parse the data\n    try {\n        const resolver = await readFile(file, options, $refs);\n        $ref.pathType = resolver.plugin.name;\n        file.data = resolver.result;\n        const parser = await parseFile(file, options, $refs);\n        $ref.value = parser.result;\n        return parser.result;\n    }\n    catch (err) {\n        if ((0, errors_js_1.isHandledError)(err)) {\n            $ref.value = err;\n        }\n        throw err;\n    }\n}\n/**\n * Reads the given file, using the configured resolver plugins\n *\n * @param file           - An object containing information about the referenced file\n * @param file.url       - The full URL of the referenced file\n * @param file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n * @param options\n * @param $refs\n * @returns\n * The promise resolves with the raw file contents and the resolver that was used.\n */\nasync function readFile(file, options, $refs) {\n    // console.log('Reading %s', file.url);\n    // Find the resolvers that can read this file\n    let resolvers = plugins.all(options.resolve);\n    resolvers = plugins.filter(resolvers, \"canRead\", file);\n    // Run the resolvers, in order, until one of them succeeds\n    plugins.sort(resolvers);\n    try {\n        const data = await plugins.run(resolvers, \"read\", file, $refs);\n        return data;\n    }\n    catch (err) {\n        if (!err && options.continueOnError) {\n            // No resolver could be matched\n            throw new errors_js_1.UnmatchedResolverError(file.url);\n        }\n        else if (!err || !(\"error\" in err)) {\n            // Throw a generic, friendly error.\n            throw ono_1.ono.syntax(`Unable to resolve $ref pointer \"${file.url}\"`);\n        }\n        // Throw the original error, if it's one of our own (user-friendly) errors.\n        else if (err.error instanceof errors_js_1.ResolverError) {\n            throw err.error;\n        }\n        else {\n            throw new errors_js_1.ResolverError(err, file.url);\n        }\n    }\n}\n/**\n * Parses the given file's contents, using the configured parser plugins.\n *\n * @param file           - An object containing information about the referenced file\n * @param file.url       - The full URL of the referenced file\n * @param file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n * @param file.data      - The file contents. This will be whatever data type was returned by the resolver\n * @param options\n * @param $refs\n *\n * @returns\n * The promise resolves with the parsed file contents and the parser that was used.\n */\nasync function parseFile(file, options, $refs) {\n    // Find the parsers that can read this file type.\n    // If none of the parsers are an exact match for this file, then we'll try ALL of them.\n    // This handles situations where the file IS a supported type, just with an unknown extension.\n    const allParsers = plugins.all(options.parse);\n    const filteredParsers = plugins.filter(allParsers, \"canParse\", file);\n    const parsers = filteredParsers.length > 0 ? filteredParsers : allParsers;\n    // Run the parsers, in order, until one of them succeeds\n    plugins.sort(parsers);\n    try {\n        const parser = await plugins.run(parsers, \"parse\", file, $refs);\n        if (!parser.plugin.allowEmpty && isEmpty(parser.result)) {\n            throw ono_1.ono.syntax(`Error parsing \"${file.url}\" as ${parser.plugin.name}. \\nParsed value is empty`);\n        }\n        else {\n            return parser;\n        }\n    }\n    catch (err) {\n        if (!err && options.continueOnError) {\n            // No resolver could be matched\n            throw new errors_js_1.UnmatchedParserError(file.url);\n        }\n        else if (err && err.message && err.message.startsWith(\"Error parsing\")) {\n            throw err;\n        }\n        else if (!err || !(\"error\" in err)) {\n            throw ono_1.ono.syntax(`Unable to parse ${file.url}`);\n        }\n        else if (err.error instanceof errors_js_1.ParserError) {\n            throw err.error;\n        }\n        else {\n            throw new errors_js_1.ParserError(err.error.message, file.url);\n        }\n    }\n}\n/**\n * Determines whether the parsed value is \"empty\".\n *\n * @param value\n * @returns\n */\nfunction isEmpty(value) {\n    return (value === undefined ||\n        (typeof value === \"object\" && Object.keys(value).length === 0) ||\n        (typeof value === \"string\" && value.trim().length === 0) ||\n        (Buffer.isBuffer(value) && value.length === 0));\n}\nexports[\"default\"] = parse;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvcGFyc2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWMsbUJBQU8sQ0FBQywwRUFBaUI7QUFDdkMseUJBQXlCLG1CQUFPLENBQUMsb0dBQWU7QUFDaEQsNkJBQTZCLG1CQUFPLENBQUMsNEdBQW1CO0FBQ3hELG9CQUFvQixtQkFBTyxDQUFDLDBHQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsU0FBUztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFNBQVMsT0FBTyxtQkFBbUI7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxTQUFTO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2hhdGJvdC11aS8uL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kaXN0L2xpYi9wYXJzZS5qcz9iYjBlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBvbm9fMSA9IHJlcXVpcmUoXCJAanNkZXZ0b29scy9vbm9cIik7XG5jb25zdCB1cmwgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdXRpbC91cmwuanNcIikpO1xuY29uc3QgcGx1Z2lucyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi91dGlsL3BsdWdpbnMuanNcIikpO1xuY29uc3QgZXJyb3JzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlsL2Vycm9ycy5qc1wiKTtcbi8qKlxuICogUmVhZHMgYW5kIHBhcnNlcyB0aGUgc3BlY2lmaWVkIGZpbGUgcGF0aCBvciBVUkwuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHBhcnNlKHBhdGgsICRyZWZzLCBvcHRpb25zKSB7XG4gICAgLy8gUmVtb3ZlIHRoZSBVUkwgZnJhZ21lbnQsIGlmIGFueVxuICAgIGNvbnN0IGhhc2hJbmRleCA9IHBhdGguaW5kZXhPZihcIiNcIik7XG4gICAgbGV0IGhhc2ggPSBcIlwiO1xuICAgIGlmIChoYXNoSW5kZXggPj0gMCkge1xuICAgICAgICBoYXNoID0gcGF0aC5zdWJzdHJpbmcoaGFzaEluZGV4KTtcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBVUkwgZnJhZ21lbnQsIGlmIGFueVxuICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcoMCwgaGFzaEluZGV4KTtcbiAgICB9XG4gICAgLy8gQWRkIGEgbmV3ICRSZWYgZm9yIHRoaXMgZmlsZSwgZXZlbiB0aG91Z2ggd2UgZG9uJ3QgaGF2ZSB0aGUgdmFsdWUgeWV0LlxuICAgIC8vIFRoaXMgZW5zdXJlcyB0aGF0IHdlIGRvbid0IHNpbXVsdGFuZW91c2x5IHJlYWQgJiBwYXJzZSB0aGUgc2FtZSBmaWxlIG11bHRpcGxlIHRpbWVzXG4gICAgY29uc3QgJHJlZiA9ICRyZWZzLl9hZGQocGF0aCk7XG4gICAgLy8gVGhpcyBcImZpbGUgb2JqZWN0XCIgd2lsbCBiZSBwYXNzZWQgdG8gYWxsIHJlc29sdmVycyBhbmQgcGFyc2Vycy5cbiAgICBjb25zdCBmaWxlID0ge1xuICAgICAgICB1cmw6IHBhdGgsXG4gICAgICAgIGhhc2gsXG4gICAgICAgIGV4dGVuc2lvbjogdXJsLmdldEV4dGVuc2lvbihwYXRoKSxcbiAgICB9O1xuICAgIC8vIFJlYWQgdGhlIGZpbGUgYW5kIHRoZW4gcGFyc2UgdGhlIGRhdGFcbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNvbHZlciA9IGF3YWl0IHJlYWRGaWxlKGZpbGUsIG9wdGlvbnMsICRyZWZzKTtcbiAgICAgICAgJHJlZi5wYXRoVHlwZSA9IHJlc29sdmVyLnBsdWdpbi5uYW1lO1xuICAgICAgICBmaWxlLmRhdGEgPSByZXNvbHZlci5yZXN1bHQ7XG4gICAgICAgIGNvbnN0IHBhcnNlciA9IGF3YWl0IHBhcnNlRmlsZShmaWxlLCBvcHRpb25zLCAkcmVmcyk7XG4gICAgICAgICRyZWYudmFsdWUgPSBwYXJzZXIucmVzdWx0O1xuICAgICAgICByZXR1cm4gcGFyc2VyLnJlc3VsdDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoKDAsIGVycm9yc19qc18xLmlzSGFuZGxlZEVycm9yKShlcnIpKSB7XG4gICAgICAgICAgICAkcmVmLnZhbHVlID0gZXJyO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycjtcbiAgICB9XG59XG4vKipcbiAqIFJlYWRzIHRoZSBnaXZlbiBmaWxlLCB1c2luZyB0aGUgY29uZmlndXJlZCByZXNvbHZlciBwbHVnaW5zXG4gKlxuICogQHBhcmFtIGZpbGUgICAgICAgICAgIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJlZmVyZW5jZWQgZmlsZVxuICogQHBhcmFtIGZpbGUudXJsICAgICAgIC0gVGhlIGZ1bGwgVVJMIG9mIHRoZSByZWZlcmVuY2VkIGZpbGVcbiAqIEBwYXJhbSBmaWxlLmV4dGVuc2lvbiAtIFRoZSBsb3dlcmNhc2VkIGZpbGUgZXh0ZW5zaW9uIChlLmcuIFwiLnR4dFwiLCBcIi5odG1sXCIsIGV0Yy4pXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHBhcmFtICRyZWZzXG4gKiBAcmV0dXJuc1xuICogVGhlIHByb21pc2UgcmVzb2x2ZXMgd2l0aCB0aGUgcmF3IGZpbGUgY29udGVudHMgYW5kIHRoZSByZXNvbHZlciB0aGF0IHdhcyB1c2VkLlxuICovXG5hc3luYyBmdW5jdGlvbiByZWFkRmlsZShmaWxlLCBvcHRpb25zLCAkcmVmcykge1xuICAgIC8vIGNvbnNvbGUubG9nKCdSZWFkaW5nICVzJywgZmlsZS51cmwpO1xuICAgIC8vIEZpbmQgdGhlIHJlc29sdmVycyB0aGF0IGNhbiByZWFkIHRoaXMgZmlsZVxuICAgIGxldCByZXNvbHZlcnMgPSBwbHVnaW5zLmFsbChvcHRpb25zLnJlc29sdmUpO1xuICAgIHJlc29sdmVycyA9IHBsdWdpbnMuZmlsdGVyKHJlc29sdmVycywgXCJjYW5SZWFkXCIsIGZpbGUpO1xuICAgIC8vIFJ1biB0aGUgcmVzb2x2ZXJzLCBpbiBvcmRlciwgdW50aWwgb25lIG9mIHRoZW0gc3VjY2VlZHNcbiAgICBwbHVnaW5zLnNvcnQocmVzb2x2ZXJzKTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcGx1Z2lucy5ydW4ocmVzb2x2ZXJzLCBcInJlYWRcIiwgZmlsZSwgJHJlZnMpO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoIWVyciAmJiBvcHRpb25zLmNvbnRpbnVlT25FcnJvcikge1xuICAgICAgICAgICAgLy8gTm8gcmVzb2x2ZXIgY291bGQgYmUgbWF0Y2hlZFxuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc19qc18xLlVubWF0Y2hlZFJlc29sdmVyRXJyb3IoZmlsZS51cmwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFlcnIgfHwgIShcImVycm9yXCIgaW4gZXJyKSkge1xuICAgICAgICAgICAgLy8gVGhyb3cgYSBnZW5lcmljLCBmcmllbmRseSBlcnJvci5cbiAgICAgICAgICAgIHRocm93IG9ub18xLm9uby5zeW50YXgoYFVuYWJsZSB0byByZXNvbHZlICRyZWYgcG9pbnRlciBcIiR7ZmlsZS51cmx9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaHJvdyB0aGUgb3JpZ2luYWwgZXJyb3IsIGlmIGl0J3Mgb25lIG9mIG91ciBvd24gKHVzZXItZnJpZW5kbHkpIGVycm9ycy5cbiAgICAgICAgZWxzZSBpZiAoZXJyLmVycm9yIGluc3RhbmNlb2YgZXJyb3JzX2pzXzEuUmVzb2x2ZXJFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgZXJyLmVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc19qc18xLlJlc29sdmVyRXJyb3IoZXJyLCBmaWxlLnVybCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFBhcnNlcyB0aGUgZ2l2ZW4gZmlsZSdzIGNvbnRlbnRzLCB1c2luZyB0aGUgY29uZmlndXJlZCBwYXJzZXIgcGx1Z2lucy5cbiAqXG4gKiBAcGFyYW0gZmlsZSAgICAgICAgICAgLSBBbiBvYmplY3QgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcmVmZXJlbmNlZCBmaWxlXG4gKiBAcGFyYW0gZmlsZS51cmwgICAgICAgLSBUaGUgZnVsbCBVUkwgb2YgdGhlIHJlZmVyZW5jZWQgZmlsZVxuICogQHBhcmFtIGZpbGUuZXh0ZW5zaW9uIC0gVGhlIGxvd2VyY2FzZWQgZmlsZSBleHRlbnNpb24gKGUuZy4gXCIudHh0XCIsIFwiLmh0bWxcIiwgZXRjLilcbiAqIEBwYXJhbSBmaWxlLmRhdGEgICAgICAtIFRoZSBmaWxlIGNvbnRlbnRzLiBUaGlzIHdpbGwgYmUgd2hhdGV2ZXIgZGF0YSB0eXBlIHdhcyByZXR1cm5lZCBieSB0aGUgcmVzb2x2ZXJcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcGFyYW0gJHJlZnNcbiAqXG4gKiBAcmV0dXJuc1xuICogVGhlIHByb21pc2UgcmVzb2x2ZXMgd2l0aCB0aGUgcGFyc2VkIGZpbGUgY29udGVudHMgYW5kIHRoZSBwYXJzZXIgdGhhdCB3YXMgdXNlZC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gcGFyc2VGaWxlKGZpbGUsIG9wdGlvbnMsICRyZWZzKSB7XG4gICAgLy8gRmluZCB0aGUgcGFyc2VycyB0aGF0IGNhbiByZWFkIHRoaXMgZmlsZSB0eXBlLlxuICAgIC8vIElmIG5vbmUgb2YgdGhlIHBhcnNlcnMgYXJlIGFuIGV4YWN0IG1hdGNoIGZvciB0aGlzIGZpbGUsIHRoZW4gd2UnbGwgdHJ5IEFMTCBvZiB0aGVtLlxuICAgIC8vIFRoaXMgaGFuZGxlcyBzaXR1YXRpb25zIHdoZXJlIHRoZSBmaWxlIElTIGEgc3VwcG9ydGVkIHR5cGUsIGp1c3Qgd2l0aCBhbiB1bmtub3duIGV4dGVuc2lvbi5cbiAgICBjb25zdCBhbGxQYXJzZXJzID0gcGx1Z2lucy5hbGwob3B0aW9ucy5wYXJzZSk7XG4gICAgY29uc3QgZmlsdGVyZWRQYXJzZXJzID0gcGx1Z2lucy5maWx0ZXIoYWxsUGFyc2VycywgXCJjYW5QYXJzZVwiLCBmaWxlKTtcbiAgICBjb25zdCBwYXJzZXJzID0gZmlsdGVyZWRQYXJzZXJzLmxlbmd0aCA+IDAgPyBmaWx0ZXJlZFBhcnNlcnMgOiBhbGxQYXJzZXJzO1xuICAgIC8vIFJ1biB0aGUgcGFyc2VycywgaW4gb3JkZXIsIHVudGlsIG9uZSBvZiB0aGVtIHN1Y2NlZWRzXG4gICAgcGx1Z2lucy5zb3J0KHBhcnNlcnMpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBhcnNlciA9IGF3YWl0IHBsdWdpbnMucnVuKHBhcnNlcnMsIFwicGFyc2VcIiwgZmlsZSwgJHJlZnMpO1xuICAgICAgICBpZiAoIXBhcnNlci5wbHVnaW4uYWxsb3dFbXB0eSAmJiBpc0VtcHR5KHBhcnNlci5yZXN1bHQpKSB7XG4gICAgICAgICAgICB0aHJvdyBvbm9fMS5vbm8uc3ludGF4KGBFcnJvciBwYXJzaW5nIFwiJHtmaWxlLnVybH1cIiBhcyAke3BhcnNlci5wbHVnaW4ubmFtZX0uIFxcblBhcnNlZCB2YWx1ZSBpcyBlbXB0eWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmICghZXJyICYmIG9wdGlvbnMuY29udGludWVPbkVycm9yKSB7XG4gICAgICAgICAgICAvLyBObyByZXNvbHZlciBjb3VsZCBiZSBtYXRjaGVkXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzX2pzXzEuVW5tYXRjaGVkUGFyc2VyRXJyb3IoZmlsZS51cmwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVyciAmJiBlcnIubWVzc2FnZSAmJiBlcnIubWVzc2FnZS5zdGFydHNXaXRoKFwiRXJyb3IgcGFyc2luZ1wiKSkge1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFlcnIgfHwgIShcImVycm9yXCIgaW4gZXJyKSkge1xuICAgICAgICAgICAgdGhyb3cgb25vXzEub25vLnN5bnRheChgVW5hYmxlIHRvIHBhcnNlICR7ZmlsZS51cmx9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXJyLmVycm9yIGluc3RhbmNlb2YgZXJyb3JzX2pzXzEuUGFyc2VyRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGVyci5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfanNfMS5QYXJzZXJFcnJvcihlcnIuZXJyb3IubWVzc2FnZSwgZmlsZS51cmwpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHBhcnNlZCB2YWx1ZSBpcyBcImVtcHR5XCIuXG4gKlxuICogQHBhcmFtIHZhbHVlXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCA9PT0gMCkgfHxcbiAgICAgICAgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS50cmltKCkubGVuZ3RoID09PSAwKSB8fFxuICAgICAgICAoQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDApKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHBhcnNlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parse.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/binary.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/binary.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst BINARY_REGEXP = /\\.(jpeg|jpg|gif|png|bmp|ico)$/i;\nexports[\"default\"] = {\n    /**\n     * The order that this parser will run, in relation to other parsers.\n     */\n    order: 400,\n    /**\n     * Whether to allow \"empty\" files (zero bytes).\n     */\n    allowEmpty: true,\n    /**\n     * Determines whether this parser can parse a given file reference.\n     * Parsers that return true will be tried, in order, until one successfully parses the file.\n     * Parsers that return false will be skipped, UNLESS all parsers returned false, in which case\n     * every parser will be tried.\n     */\n    canParse(file) {\n        // Use this parser if the file is a Buffer, and has a known binary extension\n        return Buffer.isBuffer(file.data) && BINARY_REGEXP.test(file.url);\n    },\n    /**\n     * Parses the given data as a Buffer (byte array).\n     */\n    parse(file) {\n        if (Buffer.isBuffer(file.data)) {\n            return file.data;\n        }\n        else {\n            // This will reject if data is anything other than a string or typed array\n            return Buffer.from(file.data);\n        }\n    },\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvcGFyc2Vycy9iaW5hcnkuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQSxrQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCIsInNvdXJjZXMiOlsid2VicGFjazovL2NoYXRib3QtdWkvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvcGFyc2Vycy9iaW5hcnkuanM/NGM4YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IEJJTkFSWV9SRUdFWFAgPSAvXFwuKGpwZWd8anBnfGdpZnxwbmd8Ym1wfGljbykkL2k7XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gICAgLyoqXG4gICAgICogVGhlIG9yZGVyIHRoYXQgdGhpcyBwYXJzZXIgd2lsbCBydW4sIGluIHJlbGF0aW9uIHRvIG90aGVyIHBhcnNlcnMuXG4gICAgICovXG4gICAgb3JkZXI6IDQwMCxcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIGFsbG93IFwiZW1wdHlcIiBmaWxlcyAoemVybyBieXRlcykuXG4gICAgICovXG4gICAgYWxsb3dFbXB0eTogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhpcyBwYXJzZXIgY2FuIHBhcnNlIGEgZ2l2ZW4gZmlsZSByZWZlcmVuY2UuXG4gICAgICogUGFyc2VycyB0aGF0IHJldHVybiB0cnVlIHdpbGwgYmUgdHJpZWQsIGluIG9yZGVyLCB1bnRpbCBvbmUgc3VjY2Vzc2Z1bGx5IHBhcnNlcyB0aGUgZmlsZS5cbiAgICAgKiBQYXJzZXJzIHRoYXQgcmV0dXJuIGZhbHNlIHdpbGwgYmUgc2tpcHBlZCwgVU5MRVNTIGFsbCBwYXJzZXJzIHJldHVybmVkIGZhbHNlLCBpbiB3aGljaCBjYXNlXG4gICAgICogZXZlcnkgcGFyc2VyIHdpbGwgYmUgdHJpZWQuXG4gICAgICovXG4gICAgY2FuUGFyc2UoZmlsZSkge1xuICAgICAgICAvLyBVc2UgdGhpcyBwYXJzZXIgaWYgdGhlIGZpbGUgaXMgYSBCdWZmZXIsIGFuZCBoYXMgYSBrbm93biBiaW5hcnkgZXh0ZW5zaW9uXG4gICAgICAgIHJldHVybiBCdWZmZXIuaXNCdWZmZXIoZmlsZS5kYXRhKSAmJiBCSU5BUllfUkVHRVhQLnRlc3QoZmlsZS51cmwpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHRoZSBnaXZlbiBkYXRhIGFzIGEgQnVmZmVyIChieXRlIGFycmF5KS5cbiAgICAgKi9cbiAgICBwYXJzZShmaWxlKSB7XG4gICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoZmlsZS5kYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZpbGUuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoaXMgd2lsbCByZWplY3QgaWYgZGF0YSBpcyBhbnl0aGluZyBvdGhlciB0aGFuIGEgc3RyaW5nIG9yIHR5cGVkIGFycmF5XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oZmlsZS5kYXRhKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/binary.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/json.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/json.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst errors_js_1 = __webpack_require__(/*! ../util/errors.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/errors.js\");\nexports[\"default\"] = {\n    /**\n     * The order that this parser will run, in relation to other parsers.\n     */\n    order: 100,\n    /**\n     * Whether to allow \"empty\" files. This includes zero-byte files, as well as empty JSON objects.\n     */\n    allowEmpty: true,\n    /**\n     * Determines whether this parser can parse a given file reference.\n     * Parsers that match will be tried, in order, until one successfully parses the file.\n     * Parsers that don't match will be skipped, UNLESS none of the parsers match, in which case\n     * every parser will be tried.\n     */\n    canParse: \".json\",\n    /**\n     * Allow JSON files with byte order marks (BOM)\n     */\n    allowBOM: true,\n    /**\n     * Parses the given file as JSON\n     */\n    async parse(file) {\n        let data = file.data;\n        if (Buffer.isBuffer(data)) {\n            data = data.toString();\n        }\n        if (typeof data === \"string\") {\n            if (data.trim().length === 0) {\n                return; // This mirrors the YAML behavior\n            }\n            else {\n                try {\n                    return JSON.parse(data);\n                }\n                catch (e) {\n                    if (this.allowBOM) {\n                        try {\n                            // find the first curly brace\n                            const firstCurlyBrace = data.indexOf(\"{\");\n                            // remove any characters before the first curly brace\n                            data = data.slice(firstCurlyBrace);\n                            return JSON.parse(data);\n                        }\n                        catch (e) {\n                            throw new errors_js_1.ParserError(e.message, file.url);\n                        }\n                    }\n                    throw new errors_js_1.ParserError(e.message, file.url);\n                }\n            }\n        }\n        else {\n            // data is already a JavaScript value (object, array, number, null, NaN, etc.)\n            return data;\n        }\n    },\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvcGFyc2Vycy9qc29uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixtQkFBTyxDQUFDLDJHQUFtQjtBQUMvQyxrQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2hhdGJvdC11aS8uL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kaXN0L2xpYi9wYXJzZXJzL2pzb24uanM/OTc0MSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGVycm9yc19qc18xID0gcmVxdWlyZShcIi4uL3V0aWwvZXJyb3JzLmpzXCIpO1xuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICAgIC8qKlxuICAgICAqIFRoZSBvcmRlciB0aGF0IHRoaXMgcGFyc2VyIHdpbGwgcnVuLCBpbiByZWxhdGlvbiB0byBvdGhlciBwYXJzZXJzLlxuICAgICAqL1xuICAgIG9yZGVyOiAxMDAsXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0byBhbGxvdyBcImVtcHR5XCIgZmlsZXMuIFRoaXMgaW5jbHVkZXMgemVyby1ieXRlIGZpbGVzLCBhcyB3ZWxsIGFzIGVtcHR5IEpTT04gb2JqZWN0cy5cbiAgICAgKi9cbiAgICBhbGxvd0VtcHR5OiB0cnVlLFxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGlzIHBhcnNlciBjYW4gcGFyc2UgYSBnaXZlbiBmaWxlIHJlZmVyZW5jZS5cbiAgICAgKiBQYXJzZXJzIHRoYXQgbWF0Y2ggd2lsbCBiZSB0cmllZCwgaW4gb3JkZXIsIHVudGlsIG9uZSBzdWNjZXNzZnVsbHkgcGFyc2VzIHRoZSBmaWxlLlxuICAgICAqIFBhcnNlcnMgdGhhdCBkb24ndCBtYXRjaCB3aWxsIGJlIHNraXBwZWQsIFVOTEVTUyBub25lIG9mIHRoZSBwYXJzZXJzIG1hdGNoLCBpbiB3aGljaCBjYXNlXG4gICAgICogZXZlcnkgcGFyc2VyIHdpbGwgYmUgdHJpZWQuXG4gICAgICovXG4gICAgY2FuUGFyc2U6IFwiLmpzb25cIixcbiAgICAvKipcbiAgICAgKiBBbGxvdyBKU09OIGZpbGVzIHdpdGggYnl0ZSBvcmRlciBtYXJrcyAoQk9NKVxuICAgICAqL1xuICAgIGFsbG93Qk9NOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB0aGUgZ2l2ZW4gZmlsZSBhcyBKU09OXG4gICAgICovXG4gICAgYXN5bmMgcGFyc2UoZmlsZSkge1xuICAgICAgICBsZXQgZGF0YSA9IGZpbGUuZGF0YTtcbiAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgICAgICAgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmIChkYXRhLnRyaW0oKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIFRoaXMgbWlycm9ycyB0aGUgWUFNTCBiZWhhdmlvclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFsbG93Qk9NKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZpbmQgdGhlIGZpcnN0IGN1cmx5IGJyYWNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlyc3RDdXJseUJyYWNlID0gZGF0YS5pbmRleE9mKFwie1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgYW55IGNoYXJhY3RlcnMgYmVmb3JlIHRoZSBmaXJzdCBjdXJseSBicmFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLnNsaWNlKGZpcnN0Q3VybHlCcmFjZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfanNfMS5QYXJzZXJFcnJvcihlLm1lc3NhZ2UsIGZpbGUudXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzX2pzXzEuUGFyc2VyRXJyb3IoZS5tZXNzYWdlLCBmaWxlLnVybCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZGF0YSBpcyBhbHJlYWR5IGEgSmF2YVNjcmlwdCB2YWx1ZSAob2JqZWN0LCBhcnJheSwgbnVtYmVyLCBudWxsLCBOYU4sIGV0Yy4pXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/json.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/text.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/text.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst errors_js_1 = __webpack_require__(/*! ../util/errors.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/errors.js\");\nconst TEXT_REGEXP = /\\.(txt|htm|html|md|xml|js|min|map|css|scss|less|svg)$/i;\nexports[\"default\"] = {\n    /**\n     * The order that this parser will run, in relation to other parsers.\n     */\n    order: 300,\n    /**\n     * Whether to allow \"empty\" files (zero bytes).\n     */\n    allowEmpty: true,\n    /**\n     * The encoding that the text is expected to be in.\n     */\n    encoding: \"utf8\",\n    /**\n     * Determines whether this parser can parse a given file reference.\n     * Parsers that return true will be tried, in order, until one successfully parses the file.\n     * Parsers that return false will be skipped, UNLESS all parsers returned false, in which case\n     * every parser will be tried.\n     */\n    canParse(file) {\n        // Use this parser if the file is a string or Buffer, and has a known text-based extension\n        return (typeof file.data === \"string\" || Buffer.isBuffer(file.data)) && TEXT_REGEXP.test(file.url);\n    },\n    /**\n     * Parses the given file as text\n     */\n    parse(file) {\n        if (typeof file.data === \"string\") {\n            return file.data;\n        }\n        else if (Buffer.isBuffer(file.data)) {\n            return file.data.toString(this.encoding);\n        }\n        else {\n            throw new errors_js_1.ParserError(\"data is not text\", file.url);\n        }\n    },\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvcGFyc2Vycy90ZXh0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixtQkFBTyxDQUFDLDJHQUFtQjtBQUMvQztBQUNBLGtCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2hhdGJvdC11aS8uL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kaXN0L2xpYi9wYXJzZXJzL3RleHQuanM/YTVkNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGVycm9yc19qc18xID0gcmVxdWlyZShcIi4uL3V0aWwvZXJyb3JzLmpzXCIpO1xuY29uc3QgVEVYVF9SRUdFWFAgPSAvXFwuKHR4dHxodG18aHRtbHxtZHx4bWx8anN8bWlufG1hcHxjc3N8c2Nzc3xsZXNzfHN2ZykkL2k7XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gICAgLyoqXG4gICAgICogVGhlIG9yZGVyIHRoYXQgdGhpcyBwYXJzZXIgd2lsbCBydW4sIGluIHJlbGF0aW9uIHRvIG90aGVyIHBhcnNlcnMuXG4gICAgICovXG4gICAgb3JkZXI6IDMwMCxcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIGFsbG93IFwiZW1wdHlcIiBmaWxlcyAoemVybyBieXRlcykuXG4gICAgICovXG4gICAgYWxsb3dFbXB0eTogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBUaGUgZW5jb2RpbmcgdGhhdCB0aGUgdGV4dCBpcyBleHBlY3RlZCB0byBiZSBpbi5cbiAgICAgKi9cbiAgICBlbmNvZGluZzogXCJ1dGY4XCIsXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoaXMgcGFyc2VyIGNhbiBwYXJzZSBhIGdpdmVuIGZpbGUgcmVmZXJlbmNlLlxuICAgICAqIFBhcnNlcnMgdGhhdCByZXR1cm4gdHJ1ZSB3aWxsIGJlIHRyaWVkLCBpbiBvcmRlciwgdW50aWwgb25lIHN1Y2Nlc3NmdWxseSBwYXJzZXMgdGhlIGZpbGUuXG4gICAgICogUGFyc2VycyB0aGF0IHJldHVybiBmYWxzZSB3aWxsIGJlIHNraXBwZWQsIFVOTEVTUyBhbGwgcGFyc2VycyByZXR1cm5lZCBmYWxzZSwgaW4gd2hpY2ggY2FzZVxuICAgICAqIGV2ZXJ5IHBhcnNlciB3aWxsIGJlIHRyaWVkLlxuICAgICAqL1xuICAgIGNhblBhcnNlKGZpbGUpIHtcbiAgICAgICAgLy8gVXNlIHRoaXMgcGFyc2VyIGlmIHRoZSBmaWxlIGlzIGEgc3RyaW5nIG9yIEJ1ZmZlciwgYW5kIGhhcyBhIGtub3duIHRleHQtYmFzZWQgZXh0ZW5zaW9uXG4gICAgICAgIHJldHVybiAodHlwZW9mIGZpbGUuZGF0YSA9PT0gXCJzdHJpbmdcIiB8fCBCdWZmZXIuaXNCdWZmZXIoZmlsZS5kYXRhKSkgJiYgVEVYVF9SRUdFWFAudGVzdChmaWxlLnVybCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdGhlIGdpdmVuIGZpbGUgYXMgdGV4dFxuICAgICAqL1xuICAgIHBhcnNlKGZpbGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWxlLmRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWxlLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKGZpbGUuZGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWxlLmRhdGEudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzX2pzXzEuUGFyc2VyRXJyb3IoXCJkYXRhIGlzIG5vdCB0ZXh0XCIsIGZpbGUudXJsKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/text.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/yaml.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/yaml.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst errors_js_1 = __webpack_require__(/*! ../util/errors.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/errors.js\");\nconst js_yaml_1 = __importDefault(__webpack_require__(/*! js-yaml */ \"(ssr)/./node_modules/js-yaml/index.js\"));\nconst js_yaml_2 = __webpack_require__(/*! js-yaml */ \"(ssr)/./node_modules/js-yaml/index.js\");\nexports[\"default\"] = {\n    /**\n     * The order that this parser will run, in relation to other parsers.\n     */\n    order: 200,\n    /**\n     * Whether to allow \"empty\" files. This includes zero-byte files, as well as empty JSON objects.\n     */\n    allowEmpty: true,\n    /**\n     * Determines whether this parser can parse a given file reference.\n     * Parsers that match will be tried, in order, until one successfully parses the file.\n     * Parsers that don't match will be skipped, UNLESS none of the parsers match, in which case\n     * every parser will be tried.\n     */\n    canParse: [\".yaml\", \".yml\", \".json\"], // JSON is valid YAML\n    /**\n     * Parses the given file as YAML\n     *\n     * @param file           - An object containing information about the referenced file\n     * @param file.url       - The full URL of the referenced file\n     * @param file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n     * @param file.data      - The file contents. This will be whatever data type was returned by the resolver\n     * @returns\n     */\n    async parse(file) {\n        let data = file.data;\n        if (Buffer.isBuffer(data)) {\n            data = data.toString();\n        }\n        if (typeof data === \"string\") {\n            try {\n                return js_yaml_1.default.load(data, { schema: js_yaml_2.JSON_SCHEMA });\n            }\n            catch (e) {\n                throw new errors_js_1.ParserError(e?.message || \"Parser Error\", file.url);\n            }\n        }\n        else {\n            // data is already a JavaScript value (object, array, number, null, NaN, etc.)\n            return data;\n        }\n    },\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvcGFyc2Vycy95YW1sLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CLG1CQUFPLENBQUMsMkdBQW1CO0FBQy9DLGtDQUFrQyxtQkFBTyxDQUFDLHNEQUFTO0FBQ25ELGtCQUFrQixtQkFBTyxDQUFDLHNEQUFTO0FBQ25DLGtCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsK0JBQStCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCIsInNvdXJjZXMiOlsid2VicGFjazovL2NoYXRib3QtdWkvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvcGFyc2Vycy95YW1sLmpzP2ZmMTgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBlcnJvcnNfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlsL2Vycm9ycy5qc1wiKTtcbmNvbnN0IGpzX3lhbWxfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwianMteWFtbFwiKSk7XG5jb25zdCBqc195YW1sXzIgPSByZXF1aXJlKFwianMteWFtbFwiKTtcbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgICAvKipcbiAgICAgKiBUaGUgb3JkZXIgdGhhdCB0aGlzIHBhcnNlciB3aWxsIHJ1biwgaW4gcmVsYXRpb24gdG8gb3RoZXIgcGFyc2Vycy5cbiAgICAgKi9cbiAgICBvcmRlcjogMjAwLFxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gYWxsb3cgXCJlbXB0eVwiIGZpbGVzLiBUaGlzIGluY2x1ZGVzIHplcm8tYnl0ZSBmaWxlcywgYXMgd2VsbCBhcyBlbXB0eSBKU09OIG9iamVjdHMuXG4gICAgICovXG4gICAgYWxsb3dFbXB0eTogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhpcyBwYXJzZXIgY2FuIHBhcnNlIGEgZ2l2ZW4gZmlsZSByZWZlcmVuY2UuXG4gICAgICogUGFyc2VycyB0aGF0IG1hdGNoIHdpbGwgYmUgdHJpZWQsIGluIG9yZGVyLCB1bnRpbCBvbmUgc3VjY2Vzc2Z1bGx5IHBhcnNlcyB0aGUgZmlsZS5cbiAgICAgKiBQYXJzZXJzIHRoYXQgZG9uJ3QgbWF0Y2ggd2lsbCBiZSBza2lwcGVkLCBVTkxFU1Mgbm9uZSBvZiB0aGUgcGFyc2VycyBtYXRjaCwgaW4gd2hpY2ggY2FzZVxuICAgICAqIGV2ZXJ5IHBhcnNlciB3aWxsIGJlIHRyaWVkLlxuICAgICAqL1xuICAgIGNhblBhcnNlOiBbXCIueWFtbFwiLCBcIi55bWxcIiwgXCIuanNvblwiXSwgLy8gSlNPTiBpcyB2YWxpZCBZQU1MXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHRoZSBnaXZlbiBmaWxlIGFzIFlBTUxcbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWxlICAgICAgICAgICAtIEFuIG9iamVjdCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSByZWZlcmVuY2VkIGZpbGVcbiAgICAgKiBAcGFyYW0gZmlsZS51cmwgICAgICAgLSBUaGUgZnVsbCBVUkwgb2YgdGhlIHJlZmVyZW5jZWQgZmlsZVxuICAgICAqIEBwYXJhbSBmaWxlLmV4dGVuc2lvbiAtIFRoZSBsb3dlcmNhc2VkIGZpbGUgZXh0ZW5zaW9uIChlLmcuIFwiLnR4dFwiLCBcIi5odG1sXCIsIGV0Yy4pXG4gICAgICogQHBhcmFtIGZpbGUuZGF0YSAgICAgIC0gVGhlIGZpbGUgY29udGVudHMuIFRoaXMgd2lsbCBiZSB3aGF0ZXZlciBkYXRhIHR5cGUgd2FzIHJldHVybmVkIGJ5IHRoZSByZXNvbHZlclxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgYXN5bmMgcGFyc2UoZmlsZSkge1xuICAgICAgICBsZXQgZGF0YSA9IGZpbGUuZGF0YTtcbiAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgICAgICAgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpzX3lhbWxfMS5kZWZhdWx0LmxvYWQoZGF0YSwgeyBzY2hlbWE6IGpzX3lhbWxfMi5KU09OX1NDSEVNQSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc19qc18xLlBhcnNlckVycm9yKGU/Lm1lc3NhZ2UgfHwgXCJQYXJzZXIgRXJyb3JcIiwgZmlsZS51cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gZGF0YSBpcyBhbHJlYWR5IGEgSmF2YVNjcmlwdCB2YWx1ZSAob2JqZWN0LCBhcnJheSwgbnVtYmVyLCBudWxsLCBOYU4sIGV0Yy4pXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parsers/yaml.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/pointer.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/pointer.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst ref_js_1 = __importDefault(__webpack_require__(/*! ./ref.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/ref.js\"));\nconst url = __importStar(__webpack_require__(/*! ./util/url.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/url.js\"));\nconst errors_js_1 = __webpack_require__(/*! ./util/errors.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/errors.js\");\nconst slashes = /\\//g;\nconst tildes = /~/g;\nconst escapedSlash = /~1/g;\nconst escapedTilde = /~0/g;\nconst safeDecodeURIComponent = (encodedURIComponent) => {\n    try {\n        return decodeURIComponent(encodedURIComponent);\n    }\n    catch {\n        return encodedURIComponent;\n    }\n};\n/**\n * This class represents a single JSON pointer and its resolved value.\n *\n * @param $ref\n * @param path\n * @param [friendlyPath] - The original user-specified path (used for error messages)\n * @class\n */\nclass Pointer {\n    constructor($ref, path, friendlyPath) {\n        this.$ref = $ref;\n        this.path = path;\n        this.originalPath = friendlyPath || path;\n        this.value = undefined;\n        this.circular = false;\n        this.indirections = 0;\n    }\n    /**\n     * Resolves the value of a nested property within the given object.\n     *\n     * @param obj - The object that will be crawled\n     * @param options\n     * @param pathFromRoot - the path of place that initiated resolving\n     *\n     * @returns\n     * Returns a JSON pointer whose {@link Pointer#value} is the resolved value.\n     * If resolving this value required resolving other JSON references, then\n     * the {@link Pointer#$ref} and {@link Pointer#path} will reflect the resolution path\n     * of the resolved value.\n     */\n    resolve(obj, options, pathFromRoot) {\n        const tokens = Pointer.parse(this.path, this.originalPath);\n        // Crawl the object, one token at a time\n        this.value = unwrapOrThrow(obj);\n        for (let i = 0; i < tokens.length; i++) {\n            if (resolveIf$Ref(this, options, pathFromRoot)) {\n                // The $ref path has changed, so append the remaining tokens to the path\n                this.path = Pointer.join(this.path, tokens.slice(i));\n            }\n            if (typeof this.value === \"object\" && this.value !== null && !isRootPath(pathFromRoot) && \"$ref\" in this.value) {\n                return this;\n            }\n            const token = tokens[i];\n            if (this.value[token] === undefined || (this.value[token] === null && i === tokens.length - 1)) {\n                // one final case is if the entry itself includes slashes, and was parsed out as a token - we can join the remaining tokens and try again\n                let didFindSubstringSlashMatch = false;\n                for (let j = tokens.length - 1; j > i; j--) {\n                    const joinedToken = tokens.slice(i, j + 1).join(\"/\");\n                    if (this.value[joinedToken] !== undefined) {\n                        this.value = this.value[joinedToken];\n                        i = j;\n                        didFindSubstringSlashMatch = true;\n                        break;\n                    }\n                }\n                if (didFindSubstringSlashMatch) {\n                    continue;\n                }\n                this.value = null;\n                throw new errors_js_1.MissingPointerError(token, decodeURI(this.originalPath));\n            }\n            else {\n                this.value = this.value[token];\n            }\n        }\n        // Resolve the final value\n        if (!this.value || (this.value.$ref && url.resolve(this.path, this.value.$ref) !== pathFromRoot)) {\n            resolveIf$Ref(this, options, pathFromRoot);\n        }\n        return this;\n    }\n    /**\n     * Sets the value of a nested property within the given object.\n     *\n     * @param obj - The object that will be crawled\n     * @param value - the value to assign\n     * @param options\n     *\n     * @returns\n     * Returns the modified object, or an entirely new object if the entire object is overwritten.\n     */\n    set(obj, value, options) {\n        const tokens = Pointer.parse(this.path);\n        let token;\n        if (tokens.length === 0) {\n            // There are no tokens, replace the entire object with the new value\n            this.value = value;\n            return value;\n        }\n        // Crawl the object, one token at a time\n        this.value = unwrapOrThrow(obj);\n        for (let i = 0; i < tokens.length - 1; i++) {\n            resolveIf$Ref(this, options);\n            token = tokens[i];\n            if (this.value && this.value[token] !== undefined) {\n                // The token exists\n                this.value = this.value[token];\n            }\n            else {\n                // The token doesn't exist, so create it\n                this.value = setValue(this, token, {});\n            }\n        }\n        // Set the value of the final token\n        resolveIf$Ref(this, options);\n        token = tokens[tokens.length - 1];\n        setValue(this, token, value);\n        // Return the updated object\n        return obj;\n    }\n    /**\n     * Parses a JSON pointer (or a path containing a JSON pointer in the hash)\n     * and returns an array of the pointer's tokens.\n     * (e.g. \"schema.json#/definitions/person/name\" => [\"definitions\", \"person\", \"name\"])\n     *\n     * The pointer is parsed according to RFC 6901\n     * {@link https://tools.ietf.org/html/rfc6901#section-3}\n     *\n     * @param path\n     * @param [originalPath]\n     * @returns\n     */\n    static parse(path, originalPath) {\n        // Get the JSON pointer from the path's hash\n        const pointer = url.getHash(path).substring(1);\n        // If there's no pointer, then there are no tokens,\n        // so return an empty array\n        if (!pointer) {\n            return [];\n        }\n        // Split into an array\n        const split = pointer.split(\"/\");\n        // Decode each part, according to RFC 6901\n        for (let i = 0; i < split.length; i++) {\n            split[i] = safeDecodeURIComponent(split[i].replace(escapedSlash, \"/\").replace(escapedTilde, \"~\"));\n        }\n        if (split[0] !== \"\") {\n            throw new errors_js_1.InvalidPointerError(split, originalPath === undefined ? path : originalPath);\n        }\n        return split.slice(1);\n    }\n    /**\n     * Creates a JSON pointer path, by joining one or more tokens to a base path.\n     *\n     * @param base - The base path (e.g. \"schema.json#/definitions/person\")\n     * @param tokens - The token(s) to append (e.g. [\"name\", \"first\"])\n     * @returns\n     */\n    static join(base, tokens) {\n        // Ensure that the base path contains a hash\n        if (base.indexOf(\"#\") === -1) {\n            base += \"#\";\n        }\n        // Append each token to the base path\n        tokens = Array.isArray(tokens) ? tokens : [tokens];\n        for (let i = 0; i < tokens.length; i++) {\n            const token = tokens[i];\n            // Encode the token, according to RFC 6901\n            base += \"/\" + encodeURIComponent(token.replace(tildes, \"~0\").replace(slashes, \"~1\"));\n        }\n        return base;\n    }\n}\n/**\n * If the given pointer's {@link Pointer#value} is a JSON reference,\n * then the reference is resolved and {@link Pointer#value} is replaced with the resolved value.\n * In addition, {@link Pointer#path} and {@link Pointer#$ref} are updated to reflect the\n * resolution path of the new value.\n *\n * @param pointer\n * @param options\n * @param [pathFromRoot] - the path of place that initiated resolving\n * @returns - Returns `true` if the resolution path changed\n */\nfunction resolveIf$Ref(pointer, options, pathFromRoot) {\n    // Is the value a JSON reference? (and allowed?)\n    if (ref_js_1.default.isAllowed$Ref(pointer.value, options)) {\n        const $refPath = url.resolve(pointer.path, pointer.value.$ref);\n        if ($refPath === pointer.path && !isRootPath(pathFromRoot)) {\n            // The value is a reference to itself, so there's nothing to do.\n            pointer.circular = true;\n        }\n        else {\n            const resolved = pointer.$ref.$refs._resolve($refPath, pointer.path, options);\n            if (resolved === null) {\n                return false;\n            }\n            pointer.indirections += resolved.indirections + 1;\n            if (ref_js_1.default.isExtended$Ref(pointer.value)) {\n                // This JSON reference \"extends\" the resolved value, rather than simply pointing to it.\n                // So the resolved path does NOT change.  Just the value does.\n                pointer.value = ref_js_1.default.dereference(pointer.value, resolved.value);\n                return false;\n            }\n            else {\n                // Resolve the reference\n                pointer.$ref = resolved.$ref;\n                pointer.path = resolved.path;\n                pointer.value = resolved.value;\n            }\n            return true;\n        }\n    }\n    return undefined;\n}\nexports[\"default\"] = Pointer;\n/**\n * Sets the specified token value of the {@link Pointer#value}.\n *\n * The token is evaluated according to RFC 6901.\n * {@link https://tools.ietf.org/html/rfc6901#section-4}\n *\n * @param pointer - The JSON Pointer whose value will be modified\n * @param token - A JSON Pointer token that indicates how to modify `obj`\n * @param value - The value to assign\n * @returns - Returns the assigned value\n */\nfunction setValue(pointer, token, value) {\n    if (pointer.value && typeof pointer.value === \"object\") {\n        if (token === \"-\" && Array.isArray(pointer.value)) {\n            pointer.value.push(value);\n        }\n        else {\n            pointer.value[token] = value;\n        }\n    }\n    else {\n        throw new errors_js_1.JSONParserError(`Error assigning $ref pointer \"${pointer.path}\". \\nCannot set \"${token}\" of a non-object.`);\n    }\n    return value;\n}\nfunction unwrapOrThrow(value) {\n    if ((0, errors_js_1.isHandledError)(value)) {\n        throw value;\n    }\n    return value;\n}\nfunction isRootPath(pathFromRoot) {\n    return typeof pathFromRoot == \"string\" && Pointer.parse(pathFromRoot).length == 0;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvcG9pbnRlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQ0FBaUMsbUJBQU8sQ0FBQywwRkFBVTtBQUNuRCx5QkFBeUIsbUJBQU8sQ0FBQyxvR0FBZTtBQUNoRCxvQkFBb0IsbUJBQU8sQ0FBQywwR0FBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMscUJBQXFCO0FBQzFEO0FBQ0EsWUFBWSxvQkFBb0IsS0FBSyxvQkFBb0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixxQkFBcUI7QUFDaEQsdUNBQXVDLHFCQUFxQjtBQUM1RCxpQkFBaUIsb0JBQW9CLEtBQUssb0JBQW9CO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZTtBQUNmO0FBQ0EsMENBQTBDLG9CQUFvQjtBQUM5RDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLGFBQWEsbUJBQW1CLE1BQU07QUFDckg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2hhdGJvdC11aS8uL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kaXN0L2xpYi9wb2ludGVyLmpzPzQ4M2UiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHJlZl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3JlZi5qc1wiKSk7XG5jb25zdCB1cmwgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdXRpbC91cmwuanNcIikpO1xuY29uc3QgZXJyb3JzX2pzXzEgPSByZXF1aXJlKFwiLi91dGlsL2Vycm9ycy5qc1wiKTtcbmNvbnN0IHNsYXNoZXMgPSAvXFwvL2c7XG5jb25zdCB0aWxkZXMgPSAvfi9nO1xuY29uc3QgZXNjYXBlZFNsYXNoID0gL34xL2c7XG5jb25zdCBlc2NhcGVkVGlsZGUgPSAvfjAvZztcbmNvbnN0IHNhZmVEZWNvZGVVUklDb21wb25lbnQgPSAoZW5jb2RlZFVSSUNvbXBvbmVudCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZW5jb2RlZFVSSUNvbXBvbmVudCk7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZWRVUklDb21wb25lbnQ7XG4gICAgfVxufTtcbi8qKlxuICogVGhpcyBjbGFzcyByZXByZXNlbnRzIGEgc2luZ2xlIEpTT04gcG9pbnRlciBhbmQgaXRzIHJlc29sdmVkIHZhbHVlLlxuICpcbiAqIEBwYXJhbSAkcmVmXG4gKiBAcGFyYW0gcGF0aFxuICogQHBhcmFtIFtmcmllbmRseVBhdGhdIC0gVGhlIG9yaWdpbmFsIHVzZXItc3BlY2lmaWVkIHBhdGggKHVzZWQgZm9yIGVycm9yIG1lc3NhZ2VzKVxuICogQGNsYXNzXG4gKi9cbmNsYXNzIFBvaW50ZXIge1xuICAgIGNvbnN0cnVjdG9yKCRyZWYsIHBhdGgsIGZyaWVuZGx5UGF0aCkge1xuICAgICAgICB0aGlzLiRyZWYgPSAkcmVmO1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLm9yaWdpbmFsUGF0aCA9IGZyaWVuZGx5UGF0aCB8fCBwYXRoO1xuICAgICAgICB0aGlzLnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNpcmN1bGFyID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaW5kaXJlY3Rpb25zID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzb2x2ZXMgdGhlIHZhbHVlIG9mIGEgbmVzdGVkIHByb3BlcnR5IHdpdGhpbiB0aGUgZ2l2ZW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9iaiAtIFRoZSBvYmplY3QgdGhhdCB3aWxsIGJlIGNyYXdsZWRcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSBwYXRoRnJvbVJvb3QgLSB0aGUgcGF0aCBvZiBwbGFjZSB0aGF0IGluaXRpYXRlZCByZXNvbHZpbmdcbiAgICAgKlxuICAgICAqIEByZXR1cm5zXG4gICAgICogUmV0dXJucyBhIEpTT04gcG9pbnRlciB3aG9zZSB7QGxpbmsgUG9pbnRlciN2YWx1ZX0gaXMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqIElmIHJlc29sdmluZyB0aGlzIHZhbHVlIHJlcXVpcmVkIHJlc29sdmluZyBvdGhlciBKU09OIHJlZmVyZW5jZXMsIHRoZW5cbiAgICAgKiB0aGUge0BsaW5rIFBvaW50ZXIjJHJlZn0gYW5kIHtAbGluayBQb2ludGVyI3BhdGh9IHdpbGwgcmVmbGVjdCB0aGUgcmVzb2x1dGlvbiBwYXRoXG4gICAgICogb2YgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqL1xuICAgIHJlc29sdmUob2JqLCBvcHRpb25zLCBwYXRoRnJvbVJvb3QpIHtcbiAgICAgICAgY29uc3QgdG9rZW5zID0gUG9pbnRlci5wYXJzZSh0aGlzLnBhdGgsIHRoaXMub3JpZ2luYWxQYXRoKTtcbiAgICAgICAgLy8gQ3Jhd2wgdGhlIG9iamVjdCwgb25lIHRva2VuIGF0IGEgdGltZVxuICAgICAgICB0aGlzLnZhbHVlID0gdW53cmFwT3JUaHJvdyhvYmopO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHJlc29sdmVJZiRSZWYodGhpcywgb3B0aW9ucywgcGF0aEZyb21Sb290KSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSAkcmVmIHBhdGggaGFzIGNoYW5nZWQsIHNvIGFwcGVuZCB0aGUgcmVtYWluaW5nIHRva2VucyB0byB0aGUgcGF0aFxuICAgICAgICAgICAgICAgIHRoaXMucGF0aCA9IFBvaW50ZXIuam9pbih0aGlzLnBhdGgsIHRva2Vucy5zbGljZShpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMudmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdGhpcy52YWx1ZSAhPT0gbnVsbCAmJiAhaXNSb290UGF0aChwYXRoRnJvbVJvb3QpICYmIFwiJHJlZlwiIGluIHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgaWYgKHRoaXMudmFsdWVbdG9rZW5dID09PSB1bmRlZmluZWQgfHwgKHRoaXMudmFsdWVbdG9rZW5dID09PSBudWxsICYmIGkgPT09IHRva2Vucy5sZW5ndGggLSAxKSkge1xuICAgICAgICAgICAgICAgIC8vIG9uZSBmaW5hbCBjYXNlIGlzIGlmIHRoZSBlbnRyeSBpdHNlbGYgaW5jbHVkZXMgc2xhc2hlcywgYW5kIHdhcyBwYXJzZWQgb3V0IGFzIGEgdG9rZW4gLSB3ZSBjYW4gam9pbiB0aGUgcmVtYWluaW5nIHRva2VucyBhbmQgdHJ5IGFnYWluXG4gICAgICAgICAgICAgICAgbGV0IGRpZEZpbmRTdWJzdHJpbmdTbGFzaE1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IHRva2Vucy5sZW5ndGggLSAxOyBqID4gaTsgai0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGpvaW5lZFRva2VuID0gdG9rZW5zLnNsaWNlKGksIGogKyAxKS5qb2luKFwiL1wiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsdWVbam9pbmVkVG9rZW5dICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnZhbHVlW2pvaW5lZFRva2VuXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSBqO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlkRmluZFN1YnN0cmluZ1NsYXNoTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRpZEZpbmRTdWJzdHJpbmdTbGFzaE1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzX2pzXzEuTWlzc2luZ1BvaW50ZXJFcnJvcih0b2tlbiwgZGVjb2RlVVJJKHRoaXMub3JpZ2luYWxQYXRoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZVt0b2tlbl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzb2x2ZSB0aGUgZmluYWwgdmFsdWVcbiAgICAgICAgaWYgKCF0aGlzLnZhbHVlIHx8ICh0aGlzLnZhbHVlLiRyZWYgJiYgdXJsLnJlc29sdmUodGhpcy5wYXRoLCB0aGlzLnZhbHVlLiRyZWYpICE9PSBwYXRoRnJvbVJvb3QpKSB7XG4gICAgICAgICAgICByZXNvbHZlSWYkUmVmKHRoaXMsIG9wdGlvbnMsIHBhdGhGcm9tUm9vdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlIG9mIGEgbmVzdGVkIHByb3BlcnR5IHdpdGhpbiB0aGUgZ2l2ZW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG9iaiAtIFRoZSBvYmplY3QgdGhhdCB3aWxsIGJlIGNyYXdsZWRcbiAgICAgKiBAcGFyYW0gdmFsdWUgLSB0aGUgdmFsdWUgdG8gYXNzaWduXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zXG4gICAgICogUmV0dXJucyB0aGUgbW9kaWZpZWQgb2JqZWN0LCBvciBhbiBlbnRpcmVseSBuZXcgb2JqZWN0IGlmIHRoZSBlbnRpcmUgb2JqZWN0IGlzIG92ZXJ3cml0dGVuLlxuICAgICAqL1xuICAgIHNldChvYmosIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHRva2VucyA9IFBvaW50ZXIucGFyc2UodGhpcy5wYXRoKTtcbiAgICAgICAgbGV0IHRva2VuO1xuICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gVGhlcmUgYXJlIG5vIHRva2VucywgcmVwbGFjZSB0aGUgZW50aXJlIG9iamVjdCB3aXRoIHRoZSBuZXcgdmFsdWVcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmF3bCB0aGUgb2JqZWN0LCBvbmUgdG9rZW4gYXQgYSB0aW1lXG4gICAgICAgIHRoaXMudmFsdWUgPSB1bndyYXBPclRocm93KG9iaik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgcmVzb2x2ZUlmJFJlZih0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUgJiYgdGhpcy52YWx1ZVt0b2tlbl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSB0b2tlbiBleGlzdHNcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZVt0b2tlbl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgdG9rZW4gZG9lc24ndCBleGlzdCwgc28gY3JlYXRlIGl0XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHNldFZhbHVlKHRoaXMsIHRva2VuLCB7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IHRoZSB2YWx1ZSBvZiB0aGUgZmluYWwgdG9rZW5cbiAgICAgICAgcmVzb2x2ZUlmJFJlZih0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgdG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuICAgICAgICBzZXRWYWx1ZSh0aGlzLCB0b2tlbiwgdmFsdWUpO1xuICAgICAgICAvLyBSZXR1cm4gdGhlIHVwZGF0ZWQgb2JqZWN0XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIEpTT04gcG9pbnRlciAob3IgYSBwYXRoIGNvbnRhaW5pbmcgYSBKU09OIHBvaW50ZXIgaW4gdGhlIGhhc2gpXG4gICAgICogYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHBvaW50ZXIncyB0b2tlbnMuXG4gICAgICogKGUuZy4gXCJzY2hlbWEuanNvbiMvZGVmaW5pdGlvbnMvcGVyc29uL25hbWVcIiA9PiBbXCJkZWZpbml0aW9uc1wiLCBcInBlcnNvblwiLCBcIm5hbWVcIl0pXG4gICAgICpcbiAgICAgKiBUaGUgcG9pbnRlciBpcyBwYXJzZWQgYWNjb3JkaW5nIHRvIFJGQyA2OTAxXG4gICAgICoge0BsaW5rIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2OTAxI3NlY3Rpb24tM31cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoXG4gICAgICogQHBhcmFtIFtvcmlnaW5hbFBhdGhdXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBzdGF0aWMgcGFyc2UocGF0aCwgb3JpZ2luYWxQYXRoKSB7XG4gICAgICAgIC8vIEdldCB0aGUgSlNPTiBwb2ludGVyIGZyb20gdGhlIHBhdGgncyBoYXNoXG4gICAgICAgIGNvbnN0IHBvaW50ZXIgPSB1cmwuZ2V0SGFzaChwYXRoKS5zdWJzdHJpbmcoMSk7XG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gcG9pbnRlciwgdGhlbiB0aGVyZSBhcmUgbm8gdG9rZW5zLFxuICAgICAgICAvLyBzbyByZXR1cm4gYW4gZW1wdHkgYXJyYXlcbiAgICAgICAgaWYgKCFwb2ludGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3BsaXQgaW50byBhbiBhcnJheVxuICAgICAgICBjb25zdCBzcGxpdCA9IHBvaW50ZXIuc3BsaXQoXCIvXCIpO1xuICAgICAgICAvLyBEZWNvZGUgZWFjaCBwYXJ0LCBhY2NvcmRpbmcgdG8gUkZDIDY5MDFcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGxpdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc3BsaXRbaV0gPSBzYWZlRGVjb2RlVVJJQ29tcG9uZW50KHNwbGl0W2ldLnJlcGxhY2UoZXNjYXBlZFNsYXNoLCBcIi9cIikucmVwbGFjZShlc2NhcGVkVGlsZGUsIFwiflwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNwbGl0WzBdICE9PSBcIlwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzX2pzXzEuSW52YWxpZFBvaW50ZXJFcnJvcihzcGxpdCwgb3JpZ2luYWxQYXRoID09PSB1bmRlZmluZWQgPyBwYXRoIDogb3JpZ2luYWxQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BsaXQuc2xpY2UoMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBKU09OIHBvaW50ZXIgcGF0aCwgYnkgam9pbmluZyBvbmUgb3IgbW9yZSB0b2tlbnMgdG8gYSBiYXNlIHBhdGguXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYmFzZSAtIFRoZSBiYXNlIHBhdGggKGUuZy4gXCJzY2hlbWEuanNvbiMvZGVmaW5pdGlvbnMvcGVyc29uXCIpXG4gICAgICogQHBhcmFtIHRva2VucyAtIFRoZSB0b2tlbihzKSB0byBhcHBlbmQgKGUuZy4gW1wibmFtZVwiLCBcImZpcnN0XCJdKVxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgc3RhdGljIGpvaW4oYmFzZSwgdG9rZW5zKSB7XG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBiYXNlIHBhdGggY29udGFpbnMgYSBoYXNoXG4gICAgICAgIGlmIChiYXNlLmluZGV4T2YoXCIjXCIpID09PSAtMSkge1xuICAgICAgICAgICAgYmFzZSArPSBcIiNcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBBcHBlbmQgZWFjaCB0b2tlbiB0byB0aGUgYmFzZSBwYXRoXG4gICAgICAgIHRva2VucyA9IEFycmF5LmlzQXJyYXkodG9rZW5zKSA/IHRva2VucyA6IFt0b2tlbnNdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICAvLyBFbmNvZGUgdGhlIHRva2VuLCBhY2NvcmRpbmcgdG8gUkZDIDY5MDFcbiAgICAgICAgICAgIGJhc2UgKz0gXCIvXCIgKyBlbmNvZGVVUklDb21wb25lbnQodG9rZW4ucmVwbGFjZSh0aWxkZXMsIFwifjBcIikucmVwbGFjZShzbGFzaGVzLCBcIn4xXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzZTtcbiAgICB9XG59XG4vKipcbiAqIElmIHRoZSBnaXZlbiBwb2ludGVyJ3Mge0BsaW5rIFBvaW50ZXIjdmFsdWV9IGlzIGEgSlNPTiByZWZlcmVuY2UsXG4gKiB0aGVuIHRoZSByZWZlcmVuY2UgaXMgcmVzb2x2ZWQgYW5kIHtAbGluayBQb2ludGVyI3ZhbHVlfSBpcyByZXBsYWNlZCB3aXRoIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqIEluIGFkZGl0aW9uLCB7QGxpbmsgUG9pbnRlciNwYXRofSBhbmQge0BsaW5rIFBvaW50ZXIjJHJlZn0gYXJlIHVwZGF0ZWQgdG8gcmVmbGVjdCB0aGVcbiAqIHJlc29sdXRpb24gcGF0aCBvZiB0aGUgbmV3IHZhbHVlLlxuICpcbiAqIEBwYXJhbSBwb2ludGVyXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHBhcmFtIFtwYXRoRnJvbVJvb3RdIC0gdGhlIHBhdGggb2YgcGxhY2UgdGhhdCBpbml0aWF0ZWQgcmVzb2x2aW5nXG4gKiBAcmV0dXJucyAtIFJldHVybnMgYHRydWVgIGlmIHRoZSByZXNvbHV0aW9uIHBhdGggY2hhbmdlZFxuICovXG5mdW5jdGlvbiByZXNvbHZlSWYkUmVmKHBvaW50ZXIsIG9wdGlvbnMsIHBhdGhGcm9tUm9vdCkge1xuICAgIC8vIElzIHRoZSB2YWx1ZSBhIEpTT04gcmVmZXJlbmNlPyAoYW5kIGFsbG93ZWQ/KVxuICAgIGlmIChyZWZfanNfMS5kZWZhdWx0LmlzQWxsb3dlZCRSZWYocG9pbnRlci52YWx1ZSwgb3B0aW9ucykpIHtcbiAgICAgICAgY29uc3QgJHJlZlBhdGggPSB1cmwucmVzb2x2ZShwb2ludGVyLnBhdGgsIHBvaW50ZXIudmFsdWUuJHJlZik7XG4gICAgICAgIGlmICgkcmVmUGF0aCA9PT0gcG9pbnRlci5wYXRoICYmICFpc1Jvb3RQYXRoKHBhdGhGcm9tUm9vdCkpIHtcbiAgICAgICAgICAgIC8vIFRoZSB2YWx1ZSBpcyBhIHJlZmVyZW5jZSB0byBpdHNlbGYsIHNvIHRoZXJlJ3Mgbm90aGluZyB0byBkby5cbiAgICAgICAgICAgIHBvaW50ZXIuY2lyY3VsYXIgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWQgPSBwb2ludGVyLiRyZWYuJHJlZnMuX3Jlc29sdmUoJHJlZlBhdGgsIHBvaW50ZXIucGF0aCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAocmVzb2x2ZWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb2ludGVyLmluZGlyZWN0aW9ucyArPSByZXNvbHZlZC5pbmRpcmVjdGlvbnMgKyAxO1xuICAgICAgICAgICAgaWYgKHJlZl9qc18xLmRlZmF1bHQuaXNFeHRlbmRlZCRSZWYocG9pbnRlci52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIEpTT04gcmVmZXJlbmNlIFwiZXh0ZW5kc1wiIHRoZSByZXNvbHZlZCB2YWx1ZSwgcmF0aGVyIHRoYW4gc2ltcGx5IHBvaW50aW5nIHRvIGl0LlxuICAgICAgICAgICAgICAgIC8vIFNvIHRoZSByZXNvbHZlZCBwYXRoIGRvZXMgTk9UIGNoYW5nZS4gIEp1c3QgdGhlIHZhbHVlIGRvZXMuXG4gICAgICAgICAgICAgICAgcG9pbnRlci52YWx1ZSA9IHJlZl9qc18xLmRlZmF1bHQuZGVyZWZlcmVuY2UocG9pbnRlci52YWx1ZSwgcmVzb2x2ZWQudmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFJlc29sdmUgdGhlIHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgIHBvaW50ZXIuJHJlZiA9IHJlc29sdmVkLiRyZWY7XG4gICAgICAgICAgICAgICAgcG9pbnRlci5wYXRoID0gcmVzb2x2ZWQucGF0aDtcbiAgICAgICAgICAgICAgICBwb2ludGVyLnZhbHVlID0gcmVzb2x2ZWQudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gUG9pbnRlcjtcbi8qKlxuICogU2V0cyB0aGUgc3BlY2lmaWVkIHRva2VuIHZhbHVlIG9mIHRoZSB7QGxpbmsgUG9pbnRlciN2YWx1ZX0uXG4gKlxuICogVGhlIHRva2VuIGlzIGV2YWx1YXRlZCBhY2NvcmRpbmcgdG8gUkZDIDY5MDEuXG4gKiB7QGxpbmsgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY5MDEjc2VjdGlvbi00fVxuICpcbiAqIEBwYXJhbSBwb2ludGVyIC0gVGhlIEpTT04gUG9pbnRlciB3aG9zZSB2YWx1ZSB3aWxsIGJlIG1vZGlmaWVkXG4gKiBAcGFyYW0gdG9rZW4gLSBBIEpTT04gUG9pbnRlciB0b2tlbiB0aGF0IGluZGljYXRlcyBob3cgdG8gbW9kaWZ5IGBvYmpgXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gYXNzaWduXG4gKiBAcmV0dXJucyAtIFJldHVybnMgdGhlIGFzc2lnbmVkIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHNldFZhbHVlKHBvaW50ZXIsIHRva2VuLCB2YWx1ZSkge1xuICAgIGlmIChwb2ludGVyLnZhbHVlICYmIHR5cGVvZiBwb2ludGVyLnZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmICh0b2tlbiA9PT0gXCItXCIgJiYgQXJyYXkuaXNBcnJheShwb2ludGVyLnZhbHVlKSkge1xuICAgICAgICAgICAgcG9pbnRlci52YWx1ZS5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBvaW50ZXIudmFsdWVbdG9rZW5dID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfanNfMS5KU09OUGFyc2VyRXJyb3IoYEVycm9yIGFzc2lnbmluZyAkcmVmIHBvaW50ZXIgXCIke3BvaW50ZXIucGF0aH1cIi4gXFxuQ2Fubm90IHNldCBcIiR7dG9rZW59XCIgb2YgYSBub24tb2JqZWN0LmApO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiB1bndyYXBPclRocm93KHZhbHVlKSB7XG4gICAgaWYgKCgwLCBlcnJvcnNfanNfMS5pc0hhbmRsZWRFcnJvcikodmFsdWUpKSB7XG4gICAgICAgIHRocm93IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBpc1Jvb3RQYXRoKHBhdGhGcm9tUm9vdCkge1xuICAgIHJldHVybiB0eXBlb2YgcGF0aEZyb21Sb290ID09IFwic3RyaW5nXCIgJiYgUG9pbnRlci5wYXJzZShwYXRoRnJvbVJvb3QpLmxlbmd0aCA9PSAwO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/pointer.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/ref.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/ref.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst pointer_js_1 = __importDefault(__webpack_require__(/*! ./pointer.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/pointer.js\"));\nconst errors_js_1 = __webpack_require__(/*! ./util/errors.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/errors.js\");\nconst url_js_1 = __webpack_require__(/*! ./util/url.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/url.js\");\n/**\n * This class represents a single JSON reference and its resolved value.\n *\n * @class\n */\nclass $Ref {\n    constructor($refs) {\n        /**\n         * List of all errors. Undefined if no errors.\n         */\n        this.errors = [];\n        this.$refs = $refs;\n    }\n    /**\n     * Pushes an error to errors array.\n     *\n     * @param err - The error to be pushed\n     * @returns\n     */\n    addError(err) {\n        if (this.errors === undefined) {\n            this.errors = [];\n        }\n        const existingErrors = this.errors.map(({ footprint }) => footprint);\n        // the path has been almost certainly set at this point,\n        // but just in case something went wrong, normalizeError injects path if necessary\n        // moreover, certain errors might point at the same spot, so filter them out to reduce noise\n        if (\"errors\" in err && Array.isArray(err.errors)) {\n            this.errors.push(...err.errors.map(errors_js_1.normalizeError).filter(({ footprint }) => !existingErrors.includes(footprint)));\n        }\n        else if (!(\"footprint\" in err) || !existingErrors.includes(err.footprint)) {\n            this.errors.push((0, errors_js_1.normalizeError)(err));\n        }\n    }\n    /**\n     * Determines whether the given JSON reference exists within this {@link $Ref#value}.\n     *\n     * @param path - The full path being resolved, optionally with a JSON pointer in the hash\n     * @param options\n     * @returns\n     */\n    exists(path, options) {\n        try {\n            this.resolve(path, options);\n            return true;\n        }\n        catch {\n            return false;\n        }\n    }\n    /**\n     * Resolves the given JSON reference within this {@link $Ref#value} and returns the resolved value.\n     *\n     * @param path - The full path being resolved, optionally with a JSON pointer in the hash\n     * @param options\n     * @returns - Returns the resolved value\n     */\n    get(path, options) {\n        return this.resolve(path, options)?.value;\n    }\n    /**\n     * Resolves the given JSON reference within this {@link $Ref#value}.\n     *\n     * @param path - The full path being resolved, optionally with a JSON pointer in the hash\n     * @param options\n     * @param friendlyPath - The original user-specified path (used for error messages)\n     * @param pathFromRoot - The path of `obj` from the schema root\n     * @returns\n     */\n    resolve(path, options, friendlyPath, pathFromRoot) {\n        const pointer = new pointer_js_1.default(this, path, friendlyPath);\n        try {\n            return pointer.resolve(this.value, options, pathFromRoot);\n        }\n        catch (err) {\n            if (!options || !options.continueOnError || !(0, errors_js_1.isHandledError)(err)) {\n                throw err;\n            }\n            if (err.path === null) {\n                err.path = (0, url_js_1.safePointerToPath)((0, url_js_1.getHash)(pathFromRoot));\n            }\n            if (err instanceof errors_js_1.InvalidPointerError) {\n                err.source = decodeURI((0, url_js_1.stripHash)(pathFromRoot));\n            }\n            this.addError(err);\n            return null;\n        }\n    }\n    /**\n     * Sets the value of a nested property within this {@link $Ref#value}.\n     * If the property, or any of its parents don't exist, they will be created.\n     *\n     * @param path - The full path of the property to set, optionally with a JSON pointer in the hash\n     * @param value - The value to assign\n     */\n    set(path, value) {\n        const pointer = new pointer_js_1.default(this, path);\n        this.value = pointer.set(this.value, value);\n    }\n    /**\n     * Determines whether the given value is a JSON reference.\n     *\n     * @param value - The value to inspect\n     * @returns\n     */\n    static is$Ref(value) {\n        return (Boolean(value) &&\n            typeof value === \"object\" &&\n            value !== null &&\n            \"$ref\" in value &&\n            typeof value.$ref === \"string\" &&\n            value.$ref.length > 0);\n    }\n    /**\n     * Determines whether the given value is an external JSON reference.\n     *\n     * @param value - The value to inspect\n     * @returns\n     */\n    static isExternal$Ref(value) {\n        return $Ref.is$Ref(value) && value.$ref[0] !== \"#\";\n    }\n    /**\n     * Determines whether the given value is a JSON reference, and whether it is allowed by the options.\n     * For example, if it references an external file, then options.resolve.external must be true.\n     *\n     * @param value - The value to inspect\n     * @param options\n     * @returns\n     */\n    static isAllowed$Ref(value, options) {\n        if (this.is$Ref(value)) {\n            if (value.$ref.substring(0, 2) === \"#/\" || value.$ref === \"#\") {\n                // It's a JSON Pointer reference, which is always allowed\n                return true;\n            }\n            else if (value.$ref[0] !== \"#\" && (!options || options.resolve?.external)) {\n                // It's an external reference, which is allowed by the options\n                return true;\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Determines whether the given value is a JSON reference that \"extends\" its resolved value.\n     * That is, it has extra properties (in addition to \"$ref\"), so rather than simply pointing to\n     * an existing value, this $ref actually creates a NEW value that is a shallow copy of the resolved\n     * value, plus the extra properties.\n     *\n     * @example: {\n       person: {\n         properties: {\n           firstName: { type: string }\n           lastName: { type: string }\n         }\n       }\n       employee: {\n         properties: {\n           $ref: #/person/properties\n           salary: { type: number }\n         }\n       }\n     }\n     *  In this example, \"employee\" is an extended $ref, since it extends \"person\" with an additional\n     *  property (salary).  The result is a NEW value that looks like this:\n     *\n     *  {\n     *    properties: {\n     *      firstName: { type: string }\n     *      lastName: { type: string }\n     *      salary: { type: number }\n     *    }\n     *  }\n     *\n     * @param value - The value to inspect\n     * @returns\n     */\n    static isExtended$Ref(value) {\n        return $Ref.is$Ref(value) && Object.keys(value).length > 1;\n    }\n    /**\n     * Returns the resolved value of a JSON Reference.\n     * If necessary, the resolved value is merged with the JSON Reference to create a new object\n     *\n     * @example: {\n    person: {\n      properties: {\n        firstName: { type: string }\n        lastName: { type: string }\n      }\n    }\n    employee: {\n      properties: {\n        $ref: #/person/properties\n        salary: { type: number }\n      }\n    }\n    } When \"person\" and \"employee\" are merged, you end up with the following object:\n     *\n     *  {\n     *    properties: {\n     *      firstName: { type: string }\n     *      lastName: { type: string }\n     *      salary: { type: number }\n     *    }\n     *  }\n     *\n     * @param $ref - The JSON reference object (the one with the \"$ref\" property)\n     * @param resolvedValue - The resolved value, which can be any type\n     * @returns - Returns the dereferenced value\n     */\n    static dereference($ref, resolvedValue) {\n        if (resolvedValue && typeof resolvedValue === \"object\" && $Ref.isExtended$Ref($ref)) {\n            const merged = {};\n            for (const key of Object.keys($ref)) {\n                if (key !== \"$ref\") {\n                    // @ts-expect-error TS(7053): Element implicitly has an 'any' type because expre... Remove this comment to see the full error message\n                    merged[key] = $ref[key];\n                }\n            }\n            for (const key of Object.keys(resolvedValue)) {\n                if (!(key in merged)) {\n                    // @ts-expect-error TS(7053): Element implicitly has an 'any' type because expre... Remove this comment to see the full error message\n                    merged[key] = resolvedValue[key];\n                }\n            }\n            return merged;\n        }\n        else {\n            // Completely replace the original reference with the resolved value\n            return resolvedValue;\n        }\n    }\n}\nexports[\"default\"] = $Ref;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvcmVmLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUNBQXFDLG1CQUFPLENBQUMsa0dBQWM7QUFDM0Qsb0JBQW9CLG1CQUFPLENBQUMsMEdBQWtCO0FBQzlDLGlCQUFpQixtQkFBTyxDQUFDLG9HQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsV0FBVztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRixXQUFXO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxpQkFBaUI7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGtCQUFrQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsaUJBQWlCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxpQkFBaUI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qix1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHdCQUF3QjtBQUN4QixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsd0JBQXdCO0FBQ3hCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL2NoYXRib3QtdWkvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvcmVmLmpzPzRiNWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBwb2ludGVyX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcG9pbnRlci5qc1wiKSk7XG5jb25zdCBlcnJvcnNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWwvZXJyb3JzLmpzXCIpO1xuY29uc3QgdXJsX2pzXzEgPSByZXF1aXJlKFwiLi91dGlsL3VybC5qc1wiKTtcbi8qKlxuICogVGhpcyBjbGFzcyByZXByZXNlbnRzIGEgc2luZ2xlIEpTT04gcmVmZXJlbmNlIGFuZCBpdHMgcmVzb2x2ZWQgdmFsdWUuXG4gKlxuICogQGNsYXNzXG4gKi9cbmNsYXNzICRSZWYge1xuICAgIGNvbnN0cnVjdG9yKCRyZWZzKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaXN0IG9mIGFsbCBlcnJvcnMuIFVuZGVmaW5lZCBpZiBubyBlcnJvcnMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgICAgICB0aGlzLiRyZWZzID0gJHJlZnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1c2hlcyBhbiBlcnJvciB0byBlcnJvcnMgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXJyIC0gVGhlIGVycm9yIHRvIGJlIHB1c2hlZFxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgYWRkRXJyb3IoZXJyKSB7XG4gICAgICAgIGlmICh0aGlzLmVycm9ycyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nRXJyb3JzID0gdGhpcy5lcnJvcnMubWFwKCh7IGZvb3RwcmludCB9KSA9PiBmb290cHJpbnQpO1xuICAgICAgICAvLyB0aGUgcGF0aCBoYXMgYmVlbiBhbG1vc3QgY2VydGFpbmx5IHNldCBhdCB0aGlzIHBvaW50LFxuICAgICAgICAvLyBidXQganVzdCBpbiBjYXNlIHNvbWV0aGluZyB3ZW50IHdyb25nLCBub3JtYWxpemVFcnJvciBpbmplY3RzIHBhdGggaWYgbmVjZXNzYXJ5XG4gICAgICAgIC8vIG1vcmVvdmVyLCBjZXJ0YWluIGVycm9ycyBtaWdodCBwb2ludCBhdCB0aGUgc2FtZSBzcG90LCBzbyBmaWx0ZXIgdGhlbSBvdXQgdG8gcmVkdWNlIG5vaXNlXG4gICAgICAgIGlmIChcImVycm9yc1wiIGluIGVyciAmJiBBcnJheS5pc0FycmF5KGVyci5lcnJvcnMpKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKC4uLmVyci5lcnJvcnMubWFwKGVycm9yc19qc18xLm5vcm1hbGl6ZUVycm9yKS5maWx0ZXIoKHsgZm9vdHByaW50IH0pID0+ICFleGlzdGluZ0Vycm9ycy5pbmNsdWRlcyhmb290cHJpbnQpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIShcImZvb3RwcmludFwiIGluIGVycikgfHwgIWV4aXN0aW5nRXJyb3JzLmluY2x1ZGVzKGVyci5mb290cHJpbnQpKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKCgwLCBlcnJvcnNfanNfMS5ub3JtYWxpemVFcnJvcikoZXJyKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnaXZlbiBKU09OIHJlZmVyZW5jZSBleGlzdHMgd2l0aGluIHRoaXMge0BsaW5rICRSZWYjdmFsdWV9LlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhdGggLSBUaGUgZnVsbCBwYXRoIGJlaW5nIHJlc29sdmVkLCBvcHRpb25hbGx5IHdpdGggYSBKU09OIHBvaW50ZXIgaW4gdGhlIGhhc2hcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgZXhpc3RzKHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZShwYXRoLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyB0aGUgZ2l2ZW4gSlNPTiByZWZlcmVuY2Ugd2l0aGluIHRoaXMge0BsaW5rICRSZWYjdmFsdWV9IGFuZCByZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoIC0gVGhlIGZ1bGwgcGF0aCBiZWluZyByZXNvbHZlZCwgb3B0aW9uYWxseSB3aXRoIGEgSlNPTiBwb2ludGVyIGluIHRoZSBoYXNoXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyAtIFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlXG4gICAgICovXG4gICAgZ2V0KHBhdGgsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZShwYXRoLCBvcHRpb25zKT8udmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIHRoZSBnaXZlbiBKU09OIHJlZmVyZW5jZSB3aXRoaW4gdGhpcyB7QGxpbmsgJFJlZiN2YWx1ZX0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBmdWxsIHBhdGggYmVpbmcgcmVzb2x2ZWQsIG9wdGlvbmFsbHkgd2l0aCBhIEpTT04gcG9pbnRlciBpbiB0aGUgaGFzaFxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICogQHBhcmFtIGZyaWVuZGx5UGF0aCAtIFRoZSBvcmlnaW5hbCB1c2VyLXNwZWNpZmllZCBwYXRoICh1c2VkIGZvciBlcnJvciBtZXNzYWdlcylcbiAgICAgKiBAcGFyYW0gcGF0aEZyb21Sb290IC0gVGhlIHBhdGggb2YgYG9iamAgZnJvbSB0aGUgc2NoZW1hIHJvb3RcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIHJlc29sdmUocGF0aCwgb3B0aW9ucywgZnJpZW5kbHlQYXRoLCBwYXRoRnJvbVJvb3QpIHtcbiAgICAgICAgY29uc3QgcG9pbnRlciA9IG5ldyBwb2ludGVyX2pzXzEuZGVmYXVsdCh0aGlzLCBwYXRoLCBmcmllbmRseVBhdGgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50ZXIucmVzb2x2ZSh0aGlzLnZhbHVlLCBvcHRpb25zLCBwYXRoRnJvbVJvb3QpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5jb250aW51ZU9uRXJyb3IgfHwgISgwLCBlcnJvcnNfanNfMS5pc0hhbmRsZWRFcnJvcikoZXJyKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlcnIucGF0aCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGVyci5wYXRoID0gKDAsIHVybF9qc18xLnNhZmVQb2ludGVyVG9QYXRoKSgoMCwgdXJsX2pzXzEuZ2V0SGFzaCkocGF0aEZyb21Sb290KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgZXJyb3JzX2pzXzEuSW52YWxpZFBvaW50ZXJFcnJvcikge1xuICAgICAgICAgICAgICAgIGVyci5zb3VyY2UgPSBkZWNvZGVVUkkoKDAsIHVybF9qc18xLnN0cmlwSGFzaCkocGF0aEZyb21Sb290KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFkZEVycm9yKGVycik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSB2YWx1ZSBvZiBhIG5lc3RlZCBwcm9wZXJ0eSB3aXRoaW4gdGhpcyB7QGxpbmsgJFJlZiN2YWx1ZX0uXG4gICAgICogSWYgdGhlIHByb3BlcnR5LCBvciBhbnkgb2YgaXRzIHBhcmVudHMgZG9uJ3QgZXhpc3QsIHRoZXkgd2lsbCBiZSBjcmVhdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhdGggLSBUaGUgZnVsbCBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQsIG9wdGlvbmFsbHkgd2l0aCBhIEpTT04gcG9pbnRlciBpbiB0aGUgaGFzaFxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBhc3NpZ25cbiAgICAgKi9cbiAgICBzZXQocGF0aCwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgcG9pbnRlciA9IG5ldyBwb2ludGVyX2pzXzEuZGVmYXVsdCh0aGlzLCBwYXRoKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHBvaW50ZXIuc2V0KHRoaXMudmFsdWUsIHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIEpTT04gcmVmZXJlbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGluc3BlY3RcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIHN0YXRpYyBpcyRSZWYodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIChCb29sZWFuKHZhbHVlKSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICB2YWx1ZSAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgXCIkcmVmXCIgaW4gdmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZS4kcmVmID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICB2YWx1ZS4kcmVmLmxlbmd0aCA+IDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGFuIGV4dGVybmFsIEpTT04gcmVmZXJlbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGluc3BlY3RcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIHN0YXRpYyBpc0V4dGVybmFsJFJlZih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gJFJlZi5pcyRSZWYodmFsdWUpICYmIHZhbHVlLiRyZWZbMF0gIT09IFwiI1wiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgSlNPTiByZWZlcmVuY2UsIGFuZCB3aGV0aGVyIGl0IGlzIGFsbG93ZWQgYnkgdGhlIG9wdGlvbnMuXG4gICAgICogRm9yIGV4YW1wbGUsIGlmIGl0IHJlZmVyZW5jZXMgYW4gZXh0ZXJuYWwgZmlsZSwgdGhlbiBvcHRpb25zLnJlc29sdmUuZXh0ZXJuYWwgbXVzdCBiZSB0cnVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGluc3BlY3RcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgc3RhdGljIGlzQWxsb3dlZCRSZWYodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuaXMkUmVmKHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlLiRyZWYuc3Vic3RyaW5nKDAsIDIpID09PSBcIiMvXCIgfHwgdmFsdWUuJHJlZiA9PT0gXCIjXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBJdCdzIGEgSlNPTiBQb2ludGVyIHJlZmVyZW5jZSwgd2hpY2ggaXMgYWx3YXlzIGFsbG93ZWRcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLiRyZWZbMF0gIT09IFwiI1wiICYmICghb3B0aW9ucyB8fCBvcHRpb25zLnJlc29sdmU/LmV4dGVybmFsKSkge1xuICAgICAgICAgICAgICAgIC8vIEl0J3MgYW4gZXh0ZXJuYWwgcmVmZXJlbmNlLCB3aGljaCBpcyBhbGxvd2VkIGJ5IHRoZSBvcHRpb25zXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIEpTT04gcmVmZXJlbmNlIHRoYXQgXCJleHRlbmRzXCIgaXRzIHJlc29sdmVkIHZhbHVlLlxuICAgICAqIFRoYXQgaXMsIGl0IGhhcyBleHRyYSBwcm9wZXJ0aWVzIChpbiBhZGRpdGlvbiB0byBcIiRyZWZcIiksIHNvIHJhdGhlciB0aGFuIHNpbXBseSBwb2ludGluZyB0b1xuICAgICAqIGFuIGV4aXN0aW5nIHZhbHVlLCB0aGlzICRyZWYgYWN0dWFsbHkgY3JlYXRlcyBhIE5FVyB2YWx1ZSB0aGF0IGlzIGEgc2hhbGxvdyBjb3B5IG9mIHRoZSByZXNvbHZlZFxuICAgICAqIHZhbHVlLCBwbHVzIHRoZSBleHRyYSBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGU6IHtcbiAgICAgICBwZXJzb246IHtcbiAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgZmlyc3ROYW1lOiB7IHR5cGU6IHN0cmluZyB9XG4gICAgICAgICAgIGxhc3ROYW1lOiB7IHR5cGU6IHN0cmluZyB9XG4gICAgICAgICB9XG4gICAgICAgfVxuICAgICAgIGVtcGxveWVlOiB7XG4gICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICRyZWY6ICMvcGVyc29uL3Byb3BlcnRpZXNcbiAgICAgICAgICAgc2FsYXJ5OiB7IHR5cGU6IG51bWJlciB9XG4gICAgICAgICB9XG4gICAgICAgfVxuICAgICB9XG4gICAgICogIEluIHRoaXMgZXhhbXBsZSwgXCJlbXBsb3llZVwiIGlzIGFuIGV4dGVuZGVkICRyZWYsIHNpbmNlIGl0IGV4dGVuZHMgXCJwZXJzb25cIiB3aXRoIGFuIGFkZGl0aW9uYWxcbiAgICAgKiAgcHJvcGVydHkgKHNhbGFyeSkuICBUaGUgcmVzdWx0IGlzIGEgTkVXIHZhbHVlIHRoYXQgbG9va3MgbGlrZSB0aGlzOlxuICAgICAqXG4gICAgICogIHtcbiAgICAgKiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICogICAgICBmaXJzdE5hbWU6IHsgdHlwZTogc3RyaW5nIH1cbiAgICAgKiAgICAgIGxhc3ROYW1lOiB7IHR5cGU6IHN0cmluZyB9XG4gICAgICogICAgICBzYWxhcnk6IHsgdHlwZTogbnVtYmVyIH1cbiAgICAgKiAgICB9XG4gICAgICogIH1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBpbnNwZWN0XG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBzdGF0aWMgaXNFeHRlbmRlZCRSZWYodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICRSZWYuaXMkUmVmKHZhbHVlKSAmJiBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID4gMTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUgb2YgYSBKU09OIFJlZmVyZW5jZS5cbiAgICAgKiBJZiBuZWNlc3NhcnksIHRoZSByZXNvbHZlZCB2YWx1ZSBpcyBtZXJnZWQgd2l0aCB0aGUgSlNPTiBSZWZlcmVuY2UgdG8gY3JlYXRlIGEgbmV3IG9iamVjdFxuICAgICAqXG4gICAgICogQGV4YW1wbGU6IHtcbiAgICBwZXJzb246IHtcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgZmlyc3ROYW1lOiB7IHR5cGU6IHN0cmluZyB9XG4gICAgICAgIGxhc3ROYW1lOiB7IHR5cGU6IHN0cmluZyB9XG4gICAgICB9XG4gICAgfVxuICAgIGVtcGxveWVlOiB7XG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICRyZWY6ICMvcGVyc29uL3Byb3BlcnRpZXNcbiAgICAgICAgc2FsYXJ5OiB7IHR5cGU6IG51bWJlciB9XG4gICAgICB9XG4gICAgfVxuICAgIH0gV2hlbiBcInBlcnNvblwiIGFuZCBcImVtcGxveWVlXCIgYXJlIG1lcmdlZCwgeW91IGVuZCB1cCB3aXRoIHRoZSBmb2xsb3dpbmcgb2JqZWN0OlxuICAgICAqXG4gICAgICogIHtcbiAgICAgKiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICogICAgICBmaXJzdE5hbWU6IHsgdHlwZTogc3RyaW5nIH1cbiAgICAgKiAgICAgIGxhc3ROYW1lOiB7IHR5cGU6IHN0cmluZyB9XG4gICAgICogICAgICBzYWxhcnk6IHsgdHlwZTogbnVtYmVyIH1cbiAgICAgKiAgICB9XG4gICAgICogIH1cbiAgICAgKlxuICAgICAqIEBwYXJhbSAkcmVmIC0gVGhlIEpTT04gcmVmZXJlbmNlIG9iamVjdCAodGhlIG9uZSB3aXRoIHRoZSBcIiRyZWZcIiBwcm9wZXJ0eSlcbiAgICAgKiBAcGFyYW0gcmVzb2x2ZWRWYWx1ZSAtIFRoZSByZXNvbHZlZCB2YWx1ZSwgd2hpY2ggY2FuIGJlIGFueSB0eXBlXG4gICAgICogQHJldHVybnMgLSBSZXR1cm5zIHRoZSBkZXJlZmVyZW5jZWQgdmFsdWVcbiAgICAgKi9cbiAgICBzdGF0aWMgZGVyZWZlcmVuY2UoJHJlZiwgcmVzb2x2ZWRWYWx1ZSkge1xuICAgICAgICBpZiAocmVzb2x2ZWRWYWx1ZSAmJiB0eXBlb2YgcmVzb2x2ZWRWYWx1ZSA9PT0gXCJvYmplY3RcIiAmJiAkUmVmLmlzRXh0ZW5kZWQkUmVmKCRyZWYpKSB7XG4gICAgICAgICAgICBjb25zdCBtZXJnZWQgPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKCRyZWYpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gXCIkcmVmXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUUyg3MDUzKTogRWxlbWVudCBpbXBsaWNpdGx5IGhhcyBhbiAnYW55JyB0eXBlIGJlY2F1c2UgZXhwcmUuLi4gUmVtb3ZlIHRoaXMgY29tbWVudCB0byBzZWUgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICBtZXJnZWRba2V5XSA9ICRyZWZba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhyZXNvbHZlZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmICghKGtleSBpbiBtZXJnZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVFMoNzA1Myk6IEVsZW1lbnQgaW1wbGljaXRseSBoYXMgYW4gJ2FueScgdHlwZSBiZWNhdXNlIGV4cHJlLi4uIFJlbW92ZSB0aGlzIGNvbW1lbnQgdG8gc2VlIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkW2tleV0gPSByZXNvbHZlZFZhbHVlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIENvbXBsZXRlbHkgcmVwbGFjZSB0aGUgb3JpZ2luYWwgcmVmZXJlbmNlIHdpdGggdGhlIHJlc29sdmVkIHZhbHVlXG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZWRWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9ICRSZWY7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/ref.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/refs.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/refs.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst ono_1 = __webpack_require__(/*! @jsdevtools/ono */ \"(ssr)/./node_modules/@jsdevtools/ono/esm/index.js\");\nconst ref_js_1 = __importDefault(__webpack_require__(/*! ./ref.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/ref.js\"));\nconst url = __importStar(__webpack_require__(/*! ./util/url.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/url.js\"));\nconst convert_path_to_posix_1 = __importDefault(__webpack_require__(/*! ./util/convert-path-to-posix */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/convert-path-to-posix.js\"));\n/**\n * When you call the resolve method, the value that gets passed to the callback function (or Promise) is a $Refs object. This same object is accessible via the parser.$refs property of $RefParser objects.\n *\n * This object is a map of JSON References and their resolved values. It also has several convenient helper methods that make it easy for you to navigate and manipulate the JSON References.\n *\n * See https://apitools.dev/json-schema-ref-parser/docs/refs.html\n */\nclass $Refs {\n    /**\n     * Returns the paths/URLs of all the files in your schema (including the main schema file).\n     *\n     * See https://apitools.dev/json-schema-ref-parser/docs/refs.html#pathstypes\n     *\n     * @param types (optional) Optionally only return certain types of paths (\"file\", \"http\", etc.)\n     */\n    paths(...types) {\n        const paths = getPaths(this._$refs, types.flat());\n        return paths.map((path) => {\n            return (0, convert_path_to_posix_1.default)(path.decoded);\n        });\n    }\n    /**\n     * Returns a map of paths/URLs and their correspond values.\n     *\n     * See https://apitools.dev/json-schema-ref-parser/docs/refs.html#valuestypes\n     *\n     * @param types (optional) Optionally only return values from certain locations (\"file\", \"http\", etc.)\n     */\n    values(...types) {\n        const $refs = this._$refs;\n        const paths = getPaths($refs, types.flat());\n        return paths.reduce((obj, path) => {\n            obj[(0, convert_path_to_posix_1.default)(path.decoded)] = $refs[path.encoded].value;\n            return obj;\n        }, {});\n    }\n    /**\n     * Returns `true` if the given path exists in the schema; otherwise, returns `false`\n     *\n     * See https://apitools.dev/json-schema-ref-parser/docs/refs.html#existsref\n     *\n     * @param $ref The JSON Reference path, optionally with a JSON Pointer in the hash\n     */\n    /**\n     * Determines whether the given JSON reference exists.\n     *\n     * @param path - The path being resolved, optionally with a JSON pointer in the hash\n     * @param [options]\n     * @returns\n     */\n    exists(path, options) {\n        try {\n            this._resolve(path, \"\", options);\n            return true;\n        }\n        catch {\n            return false;\n        }\n    }\n    /**\n     * Resolves the given JSON reference and returns the resolved value.\n     *\n     * @param path - The path being resolved, with a JSON pointer in the hash\n     * @param [options]\n     * @returns - Returns the resolved value\n     */\n    get(path, options) {\n        return this._resolve(path, \"\", options).value;\n    }\n    /**\n     * Sets the value at the given path in the schema. If the property, or any of its parents, don't exist, they will be created.\n     *\n     * @param path The JSON Reference path, optionally with a JSON Pointer in the hash\n     * @param value The value to assign. Can be anything (object, string, number, etc.)\n     */\n    set(path, value) {\n        const absPath = url.resolve(this._root$Ref.path, path);\n        const withoutHash = url.stripHash(absPath);\n        const $ref = this._$refs[withoutHash];\n        if (!$ref) {\n            throw (0, ono_1.ono)(`Error resolving $ref pointer \"${path}\". \\n\"${withoutHash}\" not found.`);\n        }\n        $ref.set(absPath, value);\n    }\n    /**\n     * Returns the specified {@link $Ref} object, or undefined.\n     *\n     * @param path - The path being resolved, optionally with a JSON pointer in the hash\n     * @returns\n     * @protected\n     */\n    _get$Ref(path) {\n        path = url.resolve(this._root$Ref.path, path);\n        const withoutHash = url.stripHash(path);\n        return this._$refs[withoutHash];\n    }\n    /**\n     * Creates a new {@link $Ref} object and adds it to this {@link $Refs} object.\n     *\n     * @param path  - The file path or URL of the referenced file\n     */\n    _add(path) {\n        const withoutHash = url.stripHash(path);\n        const $ref = new ref_js_1.default(this);\n        $ref.path = withoutHash;\n        this._$refs[withoutHash] = $ref;\n        this._root$Ref = this._root$Ref || $ref;\n        return $ref;\n    }\n    /**\n     * Resolves the given JSON reference.\n     *\n     * @param path - The path being resolved, optionally with a JSON pointer in the hash\n     * @param pathFromRoot - The path of `obj` from the schema root\n     * @param [options]\n     * @returns\n     * @protected\n     */\n    _resolve(path, pathFromRoot, options) {\n        const absPath = url.resolve(this._root$Ref.path, path);\n        const withoutHash = url.stripHash(absPath);\n        const $ref = this._$refs[withoutHash];\n        if (!$ref) {\n            throw (0, ono_1.ono)(`Error resolving $ref pointer \"${path}\". \\n\"${withoutHash}\" not found.`);\n        }\n        return $ref.resolve(absPath, options, path, pathFromRoot);\n    }\n    constructor() {\n        /**\n         * A map of paths/urls to {@link $Ref} objects\n         *\n         * @type {object}\n         * @protected\n         */\n        this._$refs = {};\n        /**\n         * Returns the paths of all the files/URLs that are referenced by the JSON schema,\n         * including the schema itself.\n         *\n         * @param [types] - Only return paths of the given types (\"file\", \"http\", etc.)\n         * @returns\n         */\n        /**\n         * Returns the map of JSON references and their resolved values.\n         *\n         * @param [types] - Only return references of the given types (\"file\", \"http\", etc.)\n         * @returns\n         */\n        /**\n         * Returns a POJO (plain old JavaScript object) for serialization as JSON.\n         *\n         * @returns {object}\n         */\n        this.toJSON = this.values;\n        /**\n         * Indicates whether the schema contains any circular references.\n         *\n         * @type {boolean}\n         */\n        this.circular = false;\n        this._$refs = {};\n        // @ts-ignore\n        this._root$Ref = null;\n    }\n}\nexports[\"default\"] = $Refs;\n/**\n * Returns the encoded and decoded paths keys of the given object.\n *\n * @param $refs - The object whose keys are URL-encoded paths\n * @param [types] - Only return paths of the given types (\"file\", \"http\", etc.)\n * @returns\n */\nfunction getPaths($refs, types) {\n    let paths = Object.keys($refs);\n    // Filter the paths by type\n    types = Array.isArray(types[0]) ? types[0] : Array.prototype.slice.call(types);\n    if (types.length > 0 && types[0]) {\n        paths = paths.filter((key) => {\n            return types.includes($refs[key].pathType);\n        });\n    }\n    // Decode local filesystem paths\n    return paths.map((path) => {\n        return {\n            encoded: path,\n            decoded: $refs[path].pathType === \"file\" ? url.toFileSystemPath(path, true) : path,\n        };\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvcmVmcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxjQUFjLG1CQUFPLENBQUMsMEVBQWlCO0FBQ3ZDLGlDQUFpQyxtQkFBTyxDQUFDLDBGQUFVO0FBQ25ELHlCQUF5QixtQkFBTyxDQUFDLG9HQUFlO0FBQ2hELGdEQUFnRCxtQkFBTyxDQUFDLHFJQUE4QjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxJQUFJO0FBQ2I7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsS0FBSyxRQUFRLFlBQVk7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsWUFBWTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVksNEJBQTRCLGFBQWE7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsS0FBSyxRQUFRLFlBQVk7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxZQUFZO0FBQy9DO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaGF0Ym90LXVpLy4vbm9kZV9tb2R1bGVzL0BhcGlkZXZ0b29scy9qc29uLXNjaGVtYS1yZWYtcGFyc2VyL2Rpc3QvbGliL3JlZnMuanM/Y2I0MyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3Qgb25vXzEgPSByZXF1aXJlKFwiQGpzZGV2dG9vbHMvb25vXCIpO1xuY29uc3QgcmVmX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcmVmLmpzXCIpKTtcbmNvbnN0IHVybCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi91dGlsL3VybC5qc1wiKSk7XG5jb25zdCBjb252ZXJ0X3BhdGhfdG9fcG9zaXhfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi91dGlsL2NvbnZlcnQtcGF0aC10by1wb3NpeFwiKSk7XG4vKipcbiAqIFdoZW4geW91IGNhbGwgdGhlIHJlc29sdmUgbWV0aG9kLCB0aGUgdmFsdWUgdGhhdCBnZXRzIHBhc3NlZCB0byB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gKG9yIFByb21pc2UpIGlzIGEgJFJlZnMgb2JqZWN0LiBUaGlzIHNhbWUgb2JqZWN0IGlzIGFjY2Vzc2libGUgdmlhIHRoZSBwYXJzZXIuJHJlZnMgcHJvcGVydHkgb2YgJFJlZlBhcnNlciBvYmplY3RzLlxuICpcbiAqIFRoaXMgb2JqZWN0IGlzIGEgbWFwIG9mIEpTT04gUmVmZXJlbmNlcyBhbmQgdGhlaXIgcmVzb2x2ZWQgdmFsdWVzLiBJdCBhbHNvIGhhcyBzZXZlcmFsIGNvbnZlbmllbnQgaGVscGVyIG1ldGhvZHMgdGhhdCBtYWtlIGl0IGVhc3kgZm9yIHlvdSB0byBuYXZpZ2F0ZSBhbmQgbWFuaXB1bGF0ZSB0aGUgSlNPTiBSZWZlcmVuY2VzLlxuICpcbiAqIFNlZSBodHRwczovL2FwaXRvb2xzLmRldi9qc29uLXNjaGVtYS1yZWYtcGFyc2VyL2RvY3MvcmVmcy5odG1sXG4gKi9cbmNsYXNzICRSZWZzIHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwYXRocy9VUkxzIG9mIGFsbCB0aGUgZmlsZXMgaW4geW91ciBzY2hlbWEgKGluY2x1ZGluZyB0aGUgbWFpbiBzY2hlbWEgZmlsZSkuXG4gICAgICpcbiAgICAgKiBTZWUgaHR0cHM6Ly9hcGl0b29scy5kZXYvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kb2NzL3JlZnMuaHRtbCNwYXRoc3R5cGVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHlwZXMgKG9wdGlvbmFsKSBPcHRpb25hbGx5IG9ubHkgcmV0dXJuIGNlcnRhaW4gdHlwZXMgb2YgcGF0aHMgKFwiZmlsZVwiLCBcImh0dHBcIiwgZXRjLilcbiAgICAgKi9cbiAgICBwYXRocyguLi50eXBlcykge1xuICAgICAgICBjb25zdCBwYXRocyA9IGdldFBhdGhzKHRoaXMuXyRyZWZzLCB0eXBlcy5mbGF0KCkpO1xuICAgICAgICByZXR1cm4gcGF0aHMubWFwKChwYXRoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIGNvbnZlcnRfcGF0aF90b19wb3NpeF8xLmRlZmF1bHQpKHBhdGguZGVjb2RlZCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbWFwIG9mIHBhdGhzL1VSTHMgYW5kIHRoZWlyIGNvcnJlc3BvbmQgdmFsdWVzLlxuICAgICAqXG4gICAgICogU2VlIGh0dHBzOi8vYXBpdG9vbHMuZGV2L2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZG9jcy9yZWZzLmh0bWwjdmFsdWVzdHlwZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0eXBlcyAob3B0aW9uYWwpIE9wdGlvbmFsbHkgb25seSByZXR1cm4gdmFsdWVzIGZyb20gY2VydGFpbiBsb2NhdGlvbnMgKFwiZmlsZVwiLCBcImh0dHBcIiwgZXRjLilcbiAgICAgKi9cbiAgICB2YWx1ZXMoLi4udHlwZXMpIHtcbiAgICAgICAgY29uc3QgJHJlZnMgPSB0aGlzLl8kcmVmcztcbiAgICAgICAgY29uc3QgcGF0aHMgPSBnZXRQYXRocygkcmVmcywgdHlwZXMuZmxhdCgpKTtcbiAgICAgICAgcmV0dXJuIHBhdGhzLnJlZHVjZSgob2JqLCBwYXRoKSA9PiB7XG4gICAgICAgICAgICBvYmpbKDAsIGNvbnZlcnRfcGF0aF90b19wb3NpeF8xLmRlZmF1bHQpKHBhdGguZGVjb2RlZCldID0gJHJlZnNbcGF0aC5lbmNvZGVkXS52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH0sIHt9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIHBhdGggZXhpc3RzIGluIHRoZSBzY2hlbWE7IG90aGVyd2lzZSwgcmV0dXJucyBgZmFsc2VgXG4gICAgICpcbiAgICAgKiBTZWUgaHR0cHM6Ly9hcGl0b29scy5kZXYvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kb2NzL3JlZnMuaHRtbCNleGlzdHNyZWZcbiAgICAgKlxuICAgICAqIEBwYXJhbSAkcmVmIFRoZSBKU09OIFJlZmVyZW5jZSBwYXRoLCBvcHRpb25hbGx5IHdpdGggYSBKU09OIFBvaW50ZXIgaW4gdGhlIGhhc2hcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGdpdmVuIEpTT04gcmVmZXJlbmNlIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoIC0gVGhlIHBhdGggYmVpbmcgcmVzb2x2ZWQsIG9wdGlvbmFsbHkgd2l0aCBhIEpTT04gcG9pbnRlciBpbiB0aGUgaGFzaFxuICAgICAqIEBwYXJhbSBbb3B0aW9uc11cbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGV4aXN0cyhwYXRoLCBvcHRpb25zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNvbHZlKHBhdGgsIFwiXCIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc29sdmVzIHRoZSBnaXZlbiBKU09OIHJlZmVyZW5jZSBhbmQgcmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIGJlaW5nIHJlc29sdmVkLCB3aXRoIGEgSlNPTiBwb2ludGVyIGluIHRoZSBoYXNoXG4gICAgICogQHBhcmFtIFtvcHRpb25zXVxuICAgICAqIEByZXR1cm5zIC0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWVcbiAgICAgKi9cbiAgICBnZXQocGF0aCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZShwYXRoLCBcIlwiLCBvcHRpb25zKS52YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmFsdWUgYXQgdGhlIGdpdmVuIHBhdGggaW4gdGhlIHNjaGVtYS4gSWYgdGhlIHByb3BlcnR5LCBvciBhbnkgb2YgaXRzIHBhcmVudHMsIGRvbid0IGV4aXN0LCB0aGV5IHdpbGwgYmUgY3JlYXRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBKU09OIFJlZmVyZW5jZSBwYXRoLCBvcHRpb25hbGx5IHdpdGggYSBKU09OIFBvaW50ZXIgaW4gdGhlIGhhc2hcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi4gQ2FuIGJlIGFueXRoaW5nIChvYmplY3QsIHN0cmluZywgbnVtYmVyLCBldGMuKVxuICAgICAqL1xuICAgIHNldChwYXRoLCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBhYnNQYXRoID0gdXJsLnJlc29sdmUodGhpcy5fcm9vdCRSZWYucGF0aCwgcGF0aCk7XG4gICAgICAgIGNvbnN0IHdpdGhvdXRIYXNoID0gdXJsLnN0cmlwSGFzaChhYnNQYXRoKTtcbiAgICAgICAgY29uc3QgJHJlZiA9IHRoaXMuXyRyZWZzW3dpdGhvdXRIYXNoXTtcbiAgICAgICAgaWYgKCEkcmVmKSB7XG4gICAgICAgICAgICB0aHJvdyAoMCwgb25vXzEub25vKShgRXJyb3IgcmVzb2x2aW5nICRyZWYgcG9pbnRlciBcIiR7cGF0aH1cIi4gXFxuXCIke3dpdGhvdXRIYXNofVwiIG5vdCBmb3VuZC5gKTtcbiAgICAgICAgfVxuICAgICAgICAkcmVmLnNldChhYnNQYXRoLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNwZWNpZmllZCB7QGxpbmsgJFJlZn0gb2JqZWN0LCBvciB1bmRlZmluZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIGJlaW5nIHJlc29sdmVkLCBvcHRpb25hbGx5IHdpdGggYSBKU09OIHBvaW50ZXIgaW4gdGhlIGhhc2hcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfZ2V0JFJlZihwYXRoKSB7XG4gICAgICAgIHBhdGggPSB1cmwucmVzb2x2ZSh0aGlzLl9yb290JFJlZi5wYXRoLCBwYXRoKTtcbiAgICAgICAgY29uc3Qgd2l0aG91dEhhc2ggPSB1cmwuc3RyaXBIYXNoKHBhdGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fJHJlZnNbd2l0aG91dEhhc2hdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHtAbGluayAkUmVmfSBvYmplY3QgYW5kIGFkZHMgaXQgdG8gdGhpcyB7QGxpbmsgJFJlZnN9IG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoICAtIFRoZSBmaWxlIHBhdGggb3IgVVJMIG9mIHRoZSByZWZlcmVuY2VkIGZpbGVcbiAgICAgKi9cbiAgICBfYWRkKHBhdGgpIHtcbiAgICAgICAgY29uc3Qgd2l0aG91dEhhc2ggPSB1cmwuc3RyaXBIYXNoKHBhdGgpO1xuICAgICAgICBjb25zdCAkcmVmID0gbmV3IHJlZl9qc18xLmRlZmF1bHQodGhpcyk7XG4gICAgICAgICRyZWYucGF0aCA9IHdpdGhvdXRIYXNoO1xuICAgICAgICB0aGlzLl8kcmVmc1t3aXRob3V0SGFzaF0gPSAkcmVmO1xuICAgICAgICB0aGlzLl9yb290JFJlZiA9IHRoaXMuX3Jvb3QkUmVmIHx8ICRyZWY7XG4gICAgICAgIHJldHVybiAkcmVmO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlcyB0aGUgZ2l2ZW4gSlNPTiByZWZlcmVuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aCAtIFRoZSBwYXRoIGJlaW5nIHJlc29sdmVkLCBvcHRpb25hbGx5IHdpdGggYSBKU09OIHBvaW50ZXIgaW4gdGhlIGhhc2hcbiAgICAgKiBAcGFyYW0gcGF0aEZyb21Sb290IC0gVGhlIHBhdGggb2YgYG9iamAgZnJvbSB0aGUgc2NoZW1hIHJvb3RcbiAgICAgKiBAcGFyYW0gW29wdGlvbnNdXG4gICAgICogQHJldHVybnNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3Jlc29sdmUocGF0aCwgcGF0aEZyb21Sb290LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFic1BhdGggPSB1cmwucmVzb2x2ZSh0aGlzLl9yb290JFJlZi5wYXRoLCBwYXRoKTtcbiAgICAgICAgY29uc3Qgd2l0aG91dEhhc2ggPSB1cmwuc3RyaXBIYXNoKGFic1BhdGgpO1xuICAgICAgICBjb25zdCAkcmVmID0gdGhpcy5fJHJlZnNbd2l0aG91dEhhc2hdO1xuICAgICAgICBpZiAoISRyZWYpIHtcbiAgICAgICAgICAgIHRocm93ICgwLCBvbm9fMS5vbm8pKGBFcnJvciByZXNvbHZpbmcgJHJlZiBwb2ludGVyIFwiJHtwYXRofVwiLiBcXG5cIiR7d2l0aG91dEhhc2h9XCIgbm90IGZvdW5kLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkcmVmLnJlc29sdmUoYWJzUGF0aCwgb3B0aW9ucywgcGF0aCwgcGF0aEZyb21Sb290KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIG1hcCBvZiBwYXRocy91cmxzIHRvIHtAbGluayAkUmVmfSBvYmplY3RzXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuXyRyZWZzID0ge307XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBwYXRocyBvZiBhbGwgdGhlIGZpbGVzL1VSTHMgdGhhdCBhcmUgcmVmZXJlbmNlZCBieSB0aGUgSlNPTiBzY2hlbWEsXG4gICAgICAgICAqIGluY2x1ZGluZyB0aGUgc2NoZW1hIGl0c2VsZi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIFt0eXBlc10gLSBPbmx5IHJldHVybiBwYXRocyBvZiB0aGUgZ2l2ZW4gdHlwZXMgKFwiZmlsZVwiLCBcImh0dHBcIiwgZXRjLilcbiAgICAgICAgICogQHJldHVybnNcbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBtYXAgb2YgSlNPTiByZWZlcmVuY2VzIGFuZCB0aGVpciByZXNvbHZlZCB2YWx1ZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBbdHlwZXNdIC0gT25seSByZXR1cm4gcmVmZXJlbmNlcyBvZiB0aGUgZ2l2ZW4gdHlwZXMgKFwiZmlsZVwiLCBcImh0dHBcIiwgZXRjLilcbiAgICAgICAgICogQHJldHVybnNcbiAgICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGEgUE9KTyAocGxhaW4gb2xkIEphdmFTY3JpcHQgb2JqZWN0KSBmb3Igc2VyaWFsaXphdGlvbiBhcyBKU09OLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50b0pTT04gPSB0aGlzLnZhbHVlcztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBzY2hlbWEgY29udGFpbnMgYW55IGNpcmN1bGFyIHJlZmVyZW5jZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jaXJjdWxhciA9IGZhbHNlO1xuICAgICAgICB0aGlzLl8kcmVmcyA9IHt9O1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHRoaXMuX3Jvb3QkUmVmID0gbnVsbDtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSAkUmVmcztcbi8qKlxuICogUmV0dXJucyB0aGUgZW5jb2RlZCBhbmQgZGVjb2RlZCBwYXRocyBrZXlzIG9mIHRoZSBnaXZlbiBvYmplY3QuXG4gKlxuICogQHBhcmFtICRyZWZzIC0gVGhlIG9iamVjdCB3aG9zZSBrZXlzIGFyZSBVUkwtZW5jb2RlZCBwYXRoc1xuICogQHBhcmFtIFt0eXBlc10gLSBPbmx5IHJldHVybiBwYXRocyBvZiB0aGUgZ2l2ZW4gdHlwZXMgKFwiZmlsZVwiLCBcImh0dHBcIiwgZXRjLilcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGdldFBhdGhzKCRyZWZzLCB0eXBlcykge1xuICAgIGxldCBwYXRocyA9IE9iamVjdC5rZXlzKCRyZWZzKTtcbiAgICAvLyBGaWx0ZXIgdGhlIHBhdGhzIGJ5IHR5cGVcbiAgICB0eXBlcyA9IEFycmF5LmlzQXJyYXkodHlwZXNbMF0pID8gdHlwZXNbMF0gOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0eXBlcyk7XG4gICAgaWYgKHR5cGVzLmxlbmd0aCA+IDAgJiYgdHlwZXNbMF0pIHtcbiAgICAgICAgcGF0aHMgPSBwYXRocy5maWx0ZXIoKGtleSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVzLmluY2x1ZGVzKCRyZWZzW2tleV0ucGF0aFR5cGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gRGVjb2RlIGxvY2FsIGZpbGVzeXN0ZW0gcGF0aHNcbiAgICByZXR1cm4gcGF0aHMubWFwKChwYXRoKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbmNvZGVkOiBwYXRoLFxuICAgICAgICAgICAgZGVjb2RlZDogJHJlZnNbcGF0aF0ucGF0aFR5cGUgPT09IFwiZmlsZVwiID8gdXJsLnRvRmlsZVN5c3RlbVBhdGgocGF0aCwgdHJ1ZSkgOiBwYXRoLFxuICAgICAgICB9O1xuICAgIH0pO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/refs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/resolve-external.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/resolve-external.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst ref_js_1 = __importDefault(__webpack_require__(/*! ./ref.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/ref.js\"));\nconst pointer_js_1 = __importDefault(__webpack_require__(/*! ./pointer.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/pointer.js\"));\nconst parse_js_1 = __importDefault(__webpack_require__(/*! ./parse.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/parse.js\"));\nconst url = __importStar(__webpack_require__(/*! ./util/url.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/url.js\"));\nconst errors_js_1 = __webpack_require__(/*! ./util/errors.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/errors.js\");\n/**\n * Crawls the JSON schema, finds all external JSON references, and resolves their values.\n * This method does not mutate the JSON schema. The resolved values are added to {@link $RefParser#$refs}.\n *\n * NOTE: We only care about EXTERNAL references here. INTERNAL references are only relevant when dereferencing.\n *\n * @returns\n * The promise resolves once all JSON references in the schema have been resolved,\n * including nested references that are contained in externally-referenced files.\n */\nfunction resolveExternal(parser, options) {\n    if (!options.resolve?.external) {\n        // Nothing to resolve, so exit early\n        return Promise.resolve();\n    }\n    try {\n        // console.log('Resolving $ref pointers in %s', parser.$refs._root$Ref.path);\n        const promises = crawl(parser.schema, parser.$refs._root$Ref.path + \"#\", parser.$refs, options);\n        return Promise.all(promises);\n    }\n    catch (e) {\n        return Promise.reject(e);\n    }\n}\n/**\n * Recursively crawls the given value, and resolves any external JSON references.\n *\n * @param obj - The value to crawl. If it's not an object or array, it will be ignored.\n * @param path - The full path of `obj`, possibly with a JSON Pointer in the hash\n * @param {boolean} external - Whether `obj` was found in an external document.\n * @param $refs\n * @param options\n * @param seen - Internal.\n *\n * @returns\n * Returns an array of promises. There will be one promise for each JSON reference in `obj`.\n * If `obj` does not contain any JSON references, then the array will be empty.\n * If any of the JSON references point to files that contain additional JSON references,\n * then the corresponding promise will internally reference an array of promises.\n */\nfunction crawl(obj, path, $refs, options, seen, external) {\n    seen || (seen = new Set());\n    let promises = [];\n    if (obj && typeof obj === \"object\" && !ArrayBuffer.isView(obj) && !seen.has(obj)) {\n        seen.add(obj); // Track previously seen objects to avoid infinite recursion\n        if (ref_js_1.default.isExternal$Ref(obj)) {\n            promises.push(resolve$Ref(obj, path, $refs, options));\n        }\n        const keys = Object.keys(obj);\n        for (const key of keys) {\n            const keyPath = pointer_js_1.default.join(path, key);\n            const value = obj[key];\n            promises = promises.concat(crawl(value, keyPath, $refs, options, seen, external));\n        }\n    }\n    return promises;\n}\n/**\n * Resolves the given JSON Reference, and then crawls the resulting value.\n *\n * @param $ref - The JSON Reference to resolve\n * @param path - The full path of `$ref`, possibly with a JSON Pointer in the hash\n * @param $refs\n * @param options\n *\n * @returns\n * The promise resolves once all JSON references in the object have been resolved,\n * including nested references that are contained in externally-referenced files.\n */\nasync function resolve$Ref($ref, path, $refs, options) {\n    const shouldResolveOnCwd = options.dereference?.externalReferenceResolution === \"root\";\n    const resolvedPath = url.resolve(shouldResolveOnCwd ? url.cwd() : path, $ref.$ref);\n    const withoutHash = url.stripHash(resolvedPath);\n    // $ref.$ref = url.relative($refs._root$Ref.path, resolvedPath);\n    // Do we already have this $ref?\n    const ref = $refs._$refs[withoutHash];\n    if (ref) {\n        // We've already parsed this $ref, so use the existing value\n        return Promise.resolve(ref.value);\n    }\n    // Parse the $referenced file/url\n    try {\n        const result = await (0, parse_js_1.default)(resolvedPath, $refs, options);\n        // Crawl the parsed value\n        // console.log('Resolving $ref pointers in %s', withoutHash);\n        const promises = crawl(result, withoutHash + \"#\", $refs, options, new Set(), true);\n        return Promise.all(promises);\n    }\n    catch (err) {\n        if (!options?.continueOnError || !(0, errors_js_1.isHandledError)(err)) {\n            throw err;\n        }\n        if ($refs._$refs[withoutHash]) {\n            err.source = decodeURI(url.stripHash(path));\n            err.path = url.safePointerToPath(url.getHash(path));\n        }\n        return [];\n    }\n}\nexports[\"default\"] = resolveExternal;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvcmVzb2x2ZS1leHRlcm5hbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQ0FBaUMsbUJBQU8sQ0FBQywwRkFBVTtBQUNuRCxxQ0FBcUMsbUJBQU8sQ0FBQyxrR0FBYztBQUMzRCxtQ0FBbUMsbUJBQU8sQ0FBQyw4RkFBWTtBQUN2RCx5QkFBeUIsbUJBQU8sQ0FBQyxvR0FBZTtBQUNoRCxvQkFBb0IsbUJBQU8sQ0FBQywwR0FBa0I7QUFDOUM7QUFDQTtBQUNBLGtGQUFrRix1QkFBdUI7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2hhdGJvdC11aS8uL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kaXN0L2xpYi9yZXNvbHZlLWV4dGVybmFsLmpzPzBmNDkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHJlZl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3JlZi5qc1wiKSk7XG5jb25zdCBwb2ludGVyX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vcG9pbnRlci5qc1wiKSk7XG5jb25zdCBwYXJzZV9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3BhcnNlLmpzXCIpKTtcbmNvbnN0IHVybCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi91dGlsL3VybC5qc1wiKSk7XG5jb25zdCBlcnJvcnNfanNfMSA9IHJlcXVpcmUoXCIuL3V0aWwvZXJyb3JzLmpzXCIpO1xuLyoqXG4gKiBDcmF3bHMgdGhlIEpTT04gc2NoZW1hLCBmaW5kcyBhbGwgZXh0ZXJuYWwgSlNPTiByZWZlcmVuY2VzLCBhbmQgcmVzb2x2ZXMgdGhlaXIgdmFsdWVzLlxuICogVGhpcyBtZXRob2QgZG9lcyBub3QgbXV0YXRlIHRoZSBKU09OIHNjaGVtYS4gVGhlIHJlc29sdmVkIHZhbHVlcyBhcmUgYWRkZWQgdG8ge0BsaW5rICRSZWZQYXJzZXIjJHJlZnN9LlxuICpcbiAqIE5PVEU6IFdlIG9ubHkgY2FyZSBhYm91dCBFWFRFUk5BTCByZWZlcmVuY2VzIGhlcmUuIElOVEVSTkFMIHJlZmVyZW5jZXMgYXJlIG9ubHkgcmVsZXZhbnQgd2hlbiBkZXJlZmVyZW5jaW5nLlxuICpcbiAqIEByZXR1cm5zXG4gKiBUaGUgcHJvbWlzZSByZXNvbHZlcyBvbmNlIGFsbCBKU09OIHJlZmVyZW5jZXMgaW4gdGhlIHNjaGVtYSBoYXZlIGJlZW4gcmVzb2x2ZWQsXG4gKiBpbmNsdWRpbmcgbmVzdGVkIHJlZmVyZW5jZXMgdGhhdCBhcmUgY29udGFpbmVkIGluIGV4dGVybmFsbHktcmVmZXJlbmNlZCBmaWxlcy5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUV4dGVybmFsKHBhcnNlciwgb3B0aW9ucykge1xuICAgIGlmICghb3B0aW9ucy5yZXNvbHZlPy5leHRlcm5hbCkge1xuICAgICAgICAvLyBOb3RoaW5nIHRvIHJlc29sdmUsIHNvIGV4aXQgZWFybHlcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnUmVzb2x2aW5nICRyZWYgcG9pbnRlcnMgaW4gJXMnLCBwYXJzZXIuJHJlZnMuX3Jvb3QkUmVmLnBhdGgpO1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IGNyYXdsKHBhcnNlci5zY2hlbWEsIHBhcnNlci4kcmVmcy5fcm9vdCRSZWYucGF0aCArIFwiI1wiLCBwYXJzZXIuJHJlZnMsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgfVxufVxuLyoqXG4gKiBSZWN1cnNpdmVseSBjcmF3bHMgdGhlIGdpdmVuIHZhbHVlLCBhbmQgcmVzb2x2ZXMgYW55IGV4dGVybmFsIEpTT04gcmVmZXJlbmNlcy5cbiAqXG4gKiBAcGFyYW0gb2JqIC0gVGhlIHZhbHVlIHRvIGNyYXdsLiBJZiBpdCdzIG5vdCBhbiBvYmplY3Qgb3IgYXJyYXksIGl0IHdpbGwgYmUgaWdub3JlZC5cbiAqIEBwYXJhbSBwYXRoIC0gVGhlIGZ1bGwgcGF0aCBvZiBgb2JqYCwgcG9zc2libHkgd2l0aCBhIEpTT04gUG9pbnRlciBpbiB0aGUgaGFzaFxuICogQHBhcmFtIHtib29sZWFufSBleHRlcm5hbCAtIFdoZXRoZXIgYG9iamAgd2FzIGZvdW5kIGluIGFuIGV4dGVybmFsIGRvY3VtZW50LlxuICogQHBhcmFtICRyZWZzXG4gKiBAcGFyYW0gb3B0aW9uc1xuICogQHBhcmFtIHNlZW4gLSBJbnRlcm5hbC5cbiAqXG4gKiBAcmV0dXJuc1xuICogUmV0dXJucyBhbiBhcnJheSBvZiBwcm9taXNlcy4gVGhlcmUgd2lsbCBiZSBvbmUgcHJvbWlzZSBmb3IgZWFjaCBKU09OIHJlZmVyZW5jZSBpbiBgb2JqYC5cbiAqIElmIGBvYmpgIGRvZXMgbm90IGNvbnRhaW4gYW55IEpTT04gcmVmZXJlbmNlcywgdGhlbiB0aGUgYXJyYXkgd2lsbCBiZSBlbXB0eS5cbiAqIElmIGFueSBvZiB0aGUgSlNPTiByZWZlcmVuY2VzIHBvaW50IHRvIGZpbGVzIHRoYXQgY29udGFpbiBhZGRpdGlvbmFsIEpTT04gcmVmZXJlbmNlcyxcbiAqIHRoZW4gdGhlIGNvcnJlc3BvbmRpbmcgcHJvbWlzZSB3aWxsIGludGVybmFsbHkgcmVmZXJlbmNlIGFuIGFycmF5IG9mIHByb21pc2VzLlxuICovXG5mdW5jdGlvbiBjcmF3bChvYmosIHBhdGgsICRyZWZzLCBvcHRpb25zLCBzZWVuLCBleHRlcm5hbCkge1xuICAgIHNlZW4gfHwgKHNlZW4gPSBuZXcgU2V0KCkpO1xuICAgIGxldCBwcm9taXNlcyA9IFtdO1xuICAgIGlmIChvYmogJiYgdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXlCdWZmZXIuaXNWaWV3KG9iaikgJiYgIXNlZW4uaGFzKG9iaikpIHtcbiAgICAgICAgc2Vlbi5hZGQob2JqKTsgLy8gVHJhY2sgcHJldmlvdXNseSBzZWVuIG9iamVjdHMgdG8gYXZvaWQgaW5maW5pdGUgcmVjdXJzaW9uXG4gICAgICAgIGlmIChyZWZfanNfMS5kZWZhdWx0LmlzRXh0ZXJuYWwkUmVmKG9iaikpIHtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2gocmVzb2x2ZSRSZWYob2JqLCBwYXRoLCAkcmVmcywgb3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlQYXRoID0gcG9pbnRlcl9qc18xLmRlZmF1bHQuam9pbihwYXRoLCBrZXkpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgICAgICAgIHByb21pc2VzID0gcHJvbWlzZXMuY29uY2F0KGNyYXdsKHZhbHVlLCBrZXlQYXRoLCAkcmVmcywgb3B0aW9ucywgc2VlbiwgZXh0ZXJuYWwpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvbWlzZXM7XG59XG4vKipcbiAqIFJlc29sdmVzIHRoZSBnaXZlbiBKU09OIFJlZmVyZW5jZSwgYW5kIHRoZW4gY3Jhd2xzIHRoZSByZXN1bHRpbmcgdmFsdWUuXG4gKlxuICogQHBhcmFtICRyZWYgLSBUaGUgSlNPTiBSZWZlcmVuY2UgdG8gcmVzb2x2ZVxuICogQHBhcmFtIHBhdGggLSBUaGUgZnVsbCBwYXRoIG9mIGAkcmVmYCwgcG9zc2libHkgd2l0aCBhIEpTT04gUG9pbnRlciBpbiB0aGUgaGFzaFxuICogQHBhcmFtICRyZWZzXG4gKiBAcGFyYW0gb3B0aW9uc1xuICpcbiAqIEByZXR1cm5zXG4gKiBUaGUgcHJvbWlzZSByZXNvbHZlcyBvbmNlIGFsbCBKU09OIHJlZmVyZW5jZXMgaW4gdGhlIG9iamVjdCBoYXZlIGJlZW4gcmVzb2x2ZWQsXG4gKiBpbmNsdWRpbmcgbmVzdGVkIHJlZmVyZW5jZXMgdGhhdCBhcmUgY29udGFpbmVkIGluIGV4dGVybmFsbHktcmVmZXJlbmNlZCBmaWxlcy5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZSRSZWYoJHJlZiwgcGF0aCwgJHJlZnMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBzaG91bGRSZXNvbHZlT25Dd2QgPSBvcHRpb25zLmRlcmVmZXJlbmNlPy5leHRlcm5hbFJlZmVyZW5jZVJlc29sdXRpb24gPT09IFwicm9vdFwiO1xuICAgIGNvbnN0IHJlc29sdmVkUGF0aCA9IHVybC5yZXNvbHZlKHNob3VsZFJlc29sdmVPbkN3ZCA/IHVybC5jd2QoKSA6IHBhdGgsICRyZWYuJHJlZik7XG4gICAgY29uc3Qgd2l0aG91dEhhc2ggPSB1cmwuc3RyaXBIYXNoKHJlc29sdmVkUGF0aCk7XG4gICAgLy8gJHJlZi4kcmVmID0gdXJsLnJlbGF0aXZlKCRyZWZzLl9yb290JFJlZi5wYXRoLCByZXNvbHZlZFBhdGgpO1xuICAgIC8vIERvIHdlIGFscmVhZHkgaGF2ZSB0aGlzICRyZWY/XG4gICAgY29uc3QgcmVmID0gJHJlZnMuXyRyZWZzW3dpdGhvdXRIYXNoXTtcbiAgICBpZiAocmVmKSB7XG4gICAgICAgIC8vIFdlJ3ZlIGFscmVhZHkgcGFyc2VkIHRoaXMgJHJlZiwgc28gdXNlIHRoZSBleGlzdGluZyB2YWx1ZVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlZi52YWx1ZSk7XG4gICAgfVxuICAgIC8vIFBhcnNlIHRoZSAkcmVmZXJlbmNlZCBmaWxlL3VybFxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0ICgwLCBwYXJzZV9qc18xLmRlZmF1bHQpKHJlc29sdmVkUGF0aCwgJHJlZnMsIG9wdGlvbnMpO1xuICAgICAgICAvLyBDcmF3bCB0aGUgcGFyc2VkIHZhbHVlXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdSZXNvbHZpbmcgJHJlZiBwb2ludGVycyBpbiAlcycsIHdpdGhvdXRIYXNoKTtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBjcmF3bChyZXN1bHQsIHdpdGhvdXRIYXNoICsgXCIjXCIsICRyZWZzLCBvcHRpb25zLCBuZXcgU2V0KCksIHRydWUpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmICghb3B0aW9ucz8uY29udGludWVPbkVycm9yIHx8ICEoMCwgZXJyb3JzX2pzXzEuaXNIYW5kbGVkRXJyb3IpKGVycikpIHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJHJlZnMuXyRyZWZzW3dpdGhvdXRIYXNoXSkge1xuICAgICAgICAgICAgZXJyLnNvdXJjZSA9IGRlY29kZVVSSSh1cmwuc3RyaXBIYXNoKHBhdGgpKTtcbiAgICAgICAgICAgIGVyci5wYXRoID0gdXJsLnNhZmVQb2ludGVyVG9QYXRoKHVybC5nZXRIYXNoKHBhdGgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gcmVzb2x2ZUV4dGVybmFsO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/resolve-external.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/resolvers/file.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/resolvers/file.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst fs_1 = __importDefault(__webpack_require__(/*! fs */ \"fs\"));\nconst ono_1 = __webpack_require__(/*! @jsdevtools/ono */ \"(ssr)/./node_modules/@jsdevtools/ono/esm/index.js\");\nconst url = __importStar(__webpack_require__(/*! ../util/url.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/url.js\"));\nconst errors_js_1 = __webpack_require__(/*! ../util/errors.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/errors.js\");\nexports[\"default\"] = {\n    /**\n     * The order that this resolver will run, in relation to other resolvers.\n     */\n    order: 100,\n    /**\n     * Determines whether this resolver can read a given file reference.\n     * Resolvers that return true will be tried, in order, until one successfully resolves the file.\n     * Resolvers that return false will not be given a chance to resolve the file.\n     */\n    canRead(file) {\n        return url.isFileSystemPath(file.url);\n    },\n    /**\n     * Reads the given file and returns its raw contents as a Buffer.\n     */\n    async read(file) {\n        let path;\n        try {\n            path = url.toFileSystemPath(file.url);\n        }\n        catch (err) {\n            throw new errors_js_1.ResolverError(ono_1.ono.uri(err, `Malformed URI: ${file.url}`), file.url);\n        }\n        try {\n            return await fs_1.default.promises.readFile(path);\n        }\n        catch (err) {\n            throw new errors_js_1.ResolverError((0, ono_1.ono)(err, `Error opening file \"${path}\"`), path);\n        }\n    },\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvcmVzb2x2ZXJzL2ZpbGUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCLG1CQUFPLENBQUMsY0FBSTtBQUN6QyxjQUFjLG1CQUFPLENBQUMsMEVBQWlCO0FBQ3ZDLHlCQUF5QixtQkFBTyxDQUFDLHFHQUFnQjtBQUNqRCxvQkFBb0IsbUJBQU8sQ0FBQywyR0FBbUI7QUFDL0Msa0JBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRixTQUFTO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkYsS0FBSztBQUNoRztBQUNBLEtBQUs7QUFDTCIsInNvdXJjZXMiOlsid2VicGFjazovL2NoYXRib3QtdWkvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvcmVzb2x2ZXJzL2ZpbGUuanM/ZjI4YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZnNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZnNcIikpO1xuY29uc3Qgb25vXzEgPSByZXF1aXJlKFwiQGpzZGV2dG9vbHMvb25vXCIpO1xuY29uc3QgdXJsID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi91dGlsL3VybC5qc1wiKSk7XG5jb25zdCBlcnJvcnNfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlsL2Vycm9ycy5qc1wiKTtcbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgICAvKipcbiAgICAgKiBUaGUgb3JkZXIgdGhhdCB0aGlzIHJlc29sdmVyIHdpbGwgcnVuLCBpbiByZWxhdGlvbiB0byBvdGhlciByZXNvbHZlcnMuXG4gICAgICovXG4gICAgb3JkZXI6IDEwMCxcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhpcyByZXNvbHZlciBjYW4gcmVhZCBhIGdpdmVuIGZpbGUgcmVmZXJlbmNlLlxuICAgICAqIFJlc29sdmVycyB0aGF0IHJldHVybiB0cnVlIHdpbGwgYmUgdHJpZWQsIGluIG9yZGVyLCB1bnRpbCBvbmUgc3VjY2Vzc2Z1bGx5IHJlc29sdmVzIHRoZSBmaWxlLlxuICAgICAqIFJlc29sdmVycyB0aGF0IHJldHVybiBmYWxzZSB3aWxsIG5vdCBiZSBnaXZlbiBhIGNoYW5jZSB0byByZXNvbHZlIHRoZSBmaWxlLlxuICAgICAqL1xuICAgIGNhblJlYWQoZmlsZSkge1xuICAgICAgICByZXR1cm4gdXJsLmlzRmlsZVN5c3RlbVBhdGgoZmlsZS51cmwpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZHMgdGhlIGdpdmVuIGZpbGUgYW5kIHJldHVybnMgaXRzIHJhdyBjb250ZW50cyBhcyBhIEJ1ZmZlci5cbiAgICAgKi9cbiAgICBhc3luYyByZWFkKGZpbGUpIHtcbiAgICAgICAgbGV0IHBhdGg7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwYXRoID0gdXJsLnRvRmlsZVN5c3RlbVBhdGgoZmlsZS51cmwpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfanNfMS5SZXNvbHZlckVycm9yKG9ub18xLm9uby51cmkoZXJyLCBgTWFsZm9ybWVkIFVSSTogJHtmaWxlLnVybH1gKSwgZmlsZS51cmwpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgZnNfMS5kZWZhdWx0LnByb21pc2VzLnJlYWRGaWxlKHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfanNfMS5SZXNvbHZlckVycm9yKCgwLCBvbm9fMS5vbm8pKGVyciwgYEVycm9yIG9wZW5pbmcgZmlsZSBcIiR7cGF0aH1cImApLCBwYXRoKTtcbiAgICAgICAgfVxuICAgIH0sXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/resolvers/file.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/resolvers/http.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/resolvers/http.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst ono_1 = __webpack_require__(/*! @jsdevtools/ono */ \"(ssr)/./node_modules/@jsdevtools/ono/esm/index.js\");\nconst url = __importStar(__webpack_require__(/*! ../util/url.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/url.js\"));\nconst errors_js_1 = __webpack_require__(/*! ../util/errors.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/errors.js\");\nexports[\"default\"] = {\n    /**\n     * The order that this resolver will run, in relation to other resolvers.\n     */\n    order: 200,\n    /**\n     * HTTP headers to send when downloading files.\n     *\n     * @example:\n     * {\n     *   \"User-Agent\": \"JSON Schema $Ref Parser\",\n     *   Accept: \"application/json\"\n     * }\n     */\n    headers: null,\n    /**\n     * HTTP request timeout (in milliseconds).\n     */\n    timeout: 60000, // 60 seconds\n    /**\n     * The maximum number of HTTP redirects to follow.\n     * To disable automatic following of redirects, set this to zero.\n     */\n    redirects: 5,\n    /**\n     * The `withCredentials` option of XMLHttpRequest.\n     * Set this to `true` if you're downloading files from a CORS-enabled server that requires authentication\n     */\n    withCredentials: false,\n    /**\n     * Determines whether this resolver can read a given file reference.\n     * Resolvers that return true will be tried in order, until one successfully resolves the file.\n     * Resolvers that return false will not be given a chance to resolve the file.\n     */\n    canRead(file) {\n        return url.isHttp(file.url);\n    },\n    /**\n     * Reads the given URL and returns its raw contents as a Buffer.\n     */\n    read(file) {\n        const u = url.parse(file.url);\n        if (typeof window !== \"undefined\" && !u.protocol) {\n            // Use the protocol of the current page\n            u.protocol = url.parse(location.href).protocol;\n        }\n        return download(u, this);\n    },\n};\n/**\n * Downloads the given file.\n * @returns\n * The promise resolves with the raw downloaded data, or rejects if there is an HTTP error.\n */\nasync function download(u, httpOptions, _redirects) {\n    u = url.parse(u);\n    const redirects = _redirects || [];\n    redirects.push(u.href);\n    try {\n        const res = await get(u, httpOptions);\n        if (res.status >= 400) {\n            throw (0, ono_1.ono)({ status: res.status }, `HTTP ERROR ${res.status}`);\n        }\n        else if (res.status >= 300) {\n            if (!Number.isNaN(httpOptions.redirects) && redirects.length > httpOptions.redirects) {\n                throw new errors_js_1.ResolverError((0, ono_1.ono)({ status: res.status }, `Error downloading ${redirects[0]}. \\nToo many redirects: \\n  ${redirects.join(\" \\n  \")}`));\n            }\n            else if (!(\"location\" in res.headers) || !res.headers.location) {\n                throw (0, ono_1.ono)({ status: res.status }, `HTTP ${res.status} redirect with no location header`);\n            }\n            else {\n                const redirectTo = url.resolve(u.href, res.headers.location);\n                return download(redirectTo, httpOptions, redirects);\n            }\n        }\n        else {\n            if (res.body) {\n                const buf = await res.arrayBuffer();\n                return Buffer.from(buf);\n            }\n            return Buffer.alloc(0);\n        }\n    }\n    catch (err) {\n        throw new errors_js_1.ResolverError((0, ono_1.ono)(err, `Error downloading ${u.href}`), u.href);\n    }\n}\n/**\n * Sends an HTTP GET request.\n * The promise resolves with the HTTP Response object.\n */\nasync function get(u, httpOptions) {\n    let controller;\n    let timeoutId;\n    if (httpOptions.timeout) {\n        controller = new AbortController();\n        timeoutId = setTimeout(() => controller.abort(), httpOptions.timeout);\n    }\n    const response = await fetch(u, {\n        method: \"GET\",\n        headers: httpOptions.headers || {},\n        credentials: httpOptions.withCredentials ? \"include\" : \"same-origin\",\n        signal: controller ? controller.signal : null,\n    });\n    if (timeoutId) {\n        clearTimeout(timeoutId);\n    }\n    return response;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvcmVzb2x2ZXJzL2h0dHAuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWMsbUJBQU8sQ0FBQywwRUFBaUI7QUFDdkMseUJBQXlCLG1CQUFPLENBQUMscUdBQWdCO0FBQ2pELG9CQUFvQixtQkFBTyxDQUFDLDJHQUFtQjtBQUMvQyxrQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsb0JBQW9CLGdCQUFnQixXQUFXO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxvQkFBb0IsdUJBQXVCLGFBQWEsOEJBQThCLHdCQUF3QjtBQUNuTDtBQUNBO0FBQ0EsdUNBQXVDLG9CQUFvQixVQUFVLFlBQVk7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLE9BQU87QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NoYXRib3QtdWkvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvcmVzb2x2ZXJzL2h0dHAuanM/YTkzYyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3Qgb25vXzEgPSByZXF1aXJlKFwiQGpzZGV2dG9vbHMvb25vXCIpO1xuY29uc3QgdXJsID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi91dGlsL3VybC5qc1wiKSk7XG5jb25zdCBlcnJvcnNfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlsL2Vycm9ycy5qc1wiKTtcbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgICAvKipcbiAgICAgKiBUaGUgb3JkZXIgdGhhdCB0aGlzIHJlc29sdmVyIHdpbGwgcnVuLCBpbiByZWxhdGlvbiB0byBvdGhlciByZXNvbHZlcnMuXG4gICAgICovXG4gICAgb3JkZXI6IDIwMCxcbiAgICAvKipcbiAgICAgKiBIVFRQIGhlYWRlcnMgdG8gc2VuZCB3aGVuIGRvd25sb2FkaW5nIGZpbGVzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGU6XG4gICAgICoge1xuICAgICAqICAgXCJVc2VyLUFnZW50XCI6IFwiSlNPTiBTY2hlbWEgJFJlZiBQYXJzZXJcIixcbiAgICAgKiAgIEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgKiB9XG4gICAgICovXG4gICAgaGVhZGVyczogbnVsbCxcbiAgICAvKipcbiAgICAgKiBIVFRQIHJlcXVlc3QgdGltZW91dCAoaW4gbWlsbGlzZWNvbmRzKS5cbiAgICAgKi9cbiAgICB0aW1lb3V0OiA2MDAwMCwgLy8gNjAgc2Vjb25kc1xuICAgIC8qKlxuICAgICAqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBIVFRQIHJlZGlyZWN0cyB0byBmb2xsb3cuXG4gICAgICogVG8gZGlzYWJsZSBhdXRvbWF0aWMgZm9sbG93aW5nIG9mIHJlZGlyZWN0cywgc2V0IHRoaXMgdG8gemVyby5cbiAgICAgKi9cbiAgICByZWRpcmVjdHM6IDUsXG4gICAgLyoqXG4gICAgICogVGhlIGB3aXRoQ3JlZGVudGlhbHNgIG9wdGlvbiBvZiBYTUxIdHRwUmVxdWVzdC5cbiAgICAgKiBTZXQgdGhpcyB0byBgdHJ1ZWAgaWYgeW91J3JlIGRvd25sb2FkaW5nIGZpbGVzIGZyb20gYSBDT1JTLWVuYWJsZWQgc2VydmVyIHRoYXQgcmVxdWlyZXMgYXV0aGVudGljYXRpb25cbiAgICAgKi9cbiAgICB3aXRoQ3JlZGVudGlhbHM6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciB0aGlzIHJlc29sdmVyIGNhbiByZWFkIGEgZ2l2ZW4gZmlsZSByZWZlcmVuY2UuXG4gICAgICogUmVzb2x2ZXJzIHRoYXQgcmV0dXJuIHRydWUgd2lsbCBiZSB0cmllZCBpbiBvcmRlciwgdW50aWwgb25lIHN1Y2Nlc3NmdWxseSByZXNvbHZlcyB0aGUgZmlsZS5cbiAgICAgKiBSZXNvbHZlcnMgdGhhdCByZXR1cm4gZmFsc2Ugd2lsbCBub3QgYmUgZ2l2ZW4gYSBjaGFuY2UgdG8gcmVzb2x2ZSB0aGUgZmlsZS5cbiAgICAgKi9cbiAgICBjYW5SZWFkKGZpbGUpIHtcbiAgICAgICAgcmV0dXJuIHVybC5pc0h0dHAoZmlsZS51cmwpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVhZHMgdGhlIGdpdmVuIFVSTCBhbmQgcmV0dXJucyBpdHMgcmF3IGNvbnRlbnRzIGFzIGEgQnVmZmVyLlxuICAgICAqL1xuICAgIHJlYWQoZmlsZSkge1xuICAgICAgICBjb25zdCB1ID0gdXJsLnBhcnNlKGZpbGUudXJsKTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgIXUucHJvdG9jb2wpIHtcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgcHJvdG9jb2wgb2YgdGhlIGN1cnJlbnQgcGFnZVxuICAgICAgICAgICAgdS5wcm90b2NvbCA9IHVybC5wYXJzZShsb2NhdGlvbi5ocmVmKS5wcm90b2NvbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG93bmxvYWQodSwgdGhpcyk7XG4gICAgfSxcbn07XG4vKipcbiAqIERvd25sb2FkcyB0aGUgZ2l2ZW4gZmlsZS5cbiAqIEByZXR1cm5zXG4gKiBUaGUgcHJvbWlzZSByZXNvbHZlcyB3aXRoIHRoZSByYXcgZG93bmxvYWRlZCBkYXRhLCBvciByZWplY3RzIGlmIHRoZXJlIGlzIGFuIEhUVFAgZXJyb3IuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRvd25sb2FkKHUsIGh0dHBPcHRpb25zLCBfcmVkaXJlY3RzKSB7XG4gICAgdSA9IHVybC5wYXJzZSh1KTtcbiAgICBjb25zdCByZWRpcmVjdHMgPSBfcmVkaXJlY3RzIHx8IFtdO1xuICAgIHJlZGlyZWN0cy5wdXNoKHUuaHJlZik7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgZ2V0KHUsIGh0dHBPcHRpb25zKTtcbiAgICAgICAgaWYgKHJlcy5zdGF0dXMgPj0gNDAwKSB7XG4gICAgICAgICAgICB0aHJvdyAoMCwgb25vXzEub25vKSh7IHN0YXR1czogcmVzLnN0YXR1cyB9LCBgSFRUUCBFUlJPUiAke3Jlcy5zdGF0dXN9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzLnN0YXR1cyA+PSAzMDApIHtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzTmFOKGh0dHBPcHRpb25zLnJlZGlyZWN0cykgJiYgcmVkaXJlY3RzLmxlbmd0aCA+IGh0dHBPcHRpb25zLnJlZGlyZWN0cykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfanNfMS5SZXNvbHZlckVycm9yKCgwLCBvbm9fMS5vbm8pKHsgc3RhdHVzOiByZXMuc3RhdHVzIH0sIGBFcnJvciBkb3dubG9hZGluZyAke3JlZGlyZWN0c1swXX0uIFxcblRvbyBtYW55IHJlZGlyZWN0czogXFxuICAke3JlZGlyZWN0cy5qb2luKFwiIFxcbiAgXCIpfWApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCEoXCJsb2NhdGlvblwiIGluIHJlcy5oZWFkZXJzKSB8fCAhcmVzLmhlYWRlcnMubG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAoMCwgb25vXzEub25vKSh7IHN0YXR1czogcmVzLnN0YXR1cyB9LCBgSFRUUCAke3Jlcy5zdGF0dXN9IHJlZGlyZWN0IHdpdGggbm8gbG9jYXRpb24gaGVhZGVyYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWRpcmVjdFRvID0gdXJsLnJlc29sdmUodS5ocmVmLCByZXMuaGVhZGVycy5sb2NhdGlvbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvd25sb2FkKHJlZGlyZWN0VG8sIGh0dHBPcHRpb25zLCByZWRpcmVjdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHJlcy5ib2R5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnVmID0gYXdhaXQgcmVzLmFycmF5QnVmZmVyKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJ1Zik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc19qc18xLlJlc29sdmVyRXJyb3IoKDAsIG9ub18xLm9ubykoZXJyLCBgRXJyb3IgZG93bmxvYWRpbmcgJHt1LmhyZWZ9YCksIHUuaHJlZik7XG4gICAgfVxufVxuLyoqXG4gKiBTZW5kcyBhbiBIVFRQIEdFVCByZXF1ZXN0LlxuICogVGhlIHByb21pc2UgcmVzb2x2ZXMgd2l0aCB0aGUgSFRUUCBSZXNwb25zZSBvYmplY3QuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldCh1LCBodHRwT3B0aW9ucykge1xuICAgIGxldCBjb250cm9sbGVyO1xuICAgIGxldCB0aW1lb3V0SWQ7XG4gICAgaWYgKGh0dHBPcHRpb25zLnRpbWVvdXQpIHtcbiAgICAgICAgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiBjb250cm9sbGVyLmFib3J0KCksIGh0dHBPcHRpb25zLnRpbWVvdXQpO1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHUsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgICAgICBoZWFkZXJzOiBodHRwT3B0aW9ucy5oZWFkZXJzIHx8IHt9LFxuICAgICAgICBjcmVkZW50aWFsczogaHR0cE9wdGlvbnMud2l0aENyZWRlbnRpYWxzID8gXCJpbmNsdWRlXCIgOiBcInNhbWUtb3JpZ2luXCIsXG4gICAgICAgIHNpZ25hbDogY29udHJvbGxlciA/IGNvbnRyb2xsZXIuc2lnbmFsIDogbnVsbCxcbiAgICB9KTtcbiAgICBpZiAodGltZW91dElkKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2U7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/resolvers/http.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/convert-path-to-posix.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/convert-path-to-posix.js ***!
  \*************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports[\"default\"] = convertPathToPosix;\nconst path_1 = __importDefault(__webpack_require__(/*! path */ \"path\"));\nfunction convertPathToPosix(filePath) {\n    const isExtendedLengthPath = filePath.startsWith(\"\\\\\\\\?\\\\\");\n    if (isExtendedLengthPath) {\n        return filePath;\n    }\n    return filePath.split(path_1.default?.win32?.sep).join(path_1.default?.posix?.sep ?? \"/\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvdXRpbC9jb252ZXJ0LXBhdGgtdG8tcG9zaXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBZTtBQUNmLCtCQUErQixtQkFBTyxDQUFDLGtCQUFNO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2hhdGJvdC11aS8uL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kaXN0L2xpYi91dGlsL2NvbnZlcnQtcGF0aC10by1wb3NpeC5qcz85NDkwIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gY29udmVydFBhdGhUb1Bvc2l4O1xuY29uc3QgcGF0aF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJwYXRoXCIpKTtcbmZ1bmN0aW9uIGNvbnZlcnRQYXRoVG9Qb3NpeChmaWxlUGF0aCkge1xuICAgIGNvbnN0IGlzRXh0ZW5kZWRMZW5ndGhQYXRoID0gZmlsZVBhdGguc3RhcnRzV2l0aChcIlxcXFxcXFxcP1xcXFxcIik7XG4gICAgaWYgKGlzRXh0ZW5kZWRMZW5ndGhQYXRoKSB7XG4gICAgICAgIHJldHVybiBmaWxlUGF0aDtcbiAgICB9XG4gICAgcmV0dXJuIGZpbGVQYXRoLnNwbGl0KHBhdGhfMS5kZWZhdWx0Py53aW4zMj8uc2VwKS5qb2luKHBhdGhfMS5kZWZhdWx0Py5wb3NpeD8uc2VwID8/IFwiL1wiKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/convert-path-to-posix.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/errors.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/errors.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InvalidPointerError = exports.TimeoutError = exports.MissingPointerError = exports.UnmatchedResolverError = exports.ResolverError = exports.UnmatchedParserError = exports.ParserError = exports.JSONParserErrorGroup = exports.JSONParserError = void 0;\nexports.isHandledError = isHandledError;\nexports.normalizeError = normalizeError;\nconst ono_1 = __webpack_require__(/*! @jsdevtools/ono */ \"(ssr)/./node_modules/@jsdevtools/ono/esm/index.js\");\nconst url_js_1 = __webpack_require__(/*! ./url.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/url.js\");\nclass JSONParserError extends Error {\n    constructor(message, source) {\n        super();\n        this.code = \"EUNKNOWN\";\n        this.name = \"JSONParserError\";\n        this.message = message;\n        this.source = source;\n        this.path = null;\n        ono_1.Ono.extend(this);\n    }\n    get footprint() {\n        return `${this.path}+${this.source}+${this.code}+${this.message}`;\n    }\n}\nexports.JSONParserError = JSONParserError;\nclass JSONParserErrorGroup extends Error {\n    constructor(parser) {\n        super();\n        this.files = parser;\n        this.name = \"JSONParserErrorGroup\";\n        this.message = `${this.errors.length} error${this.errors.length > 1 ? \"s\" : \"\"} occurred while reading '${(0, url_js_1.toFileSystemPath)(parser.$refs._root$Ref.path)}'`;\n        ono_1.Ono.extend(this);\n    }\n    static getParserErrors(parser) {\n        const errors = [];\n        for (const $ref of Object.values(parser.$refs._$refs)) {\n            if ($ref.errors) {\n                errors.push(...$ref.errors);\n            }\n        }\n        return errors;\n    }\n    get errors() {\n        return JSONParserErrorGroup.getParserErrors(this.files);\n    }\n}\nexports.JSONParserErrorGroup = JSONParserErrorGroup;\nclass ParserError extends JSONParserError {\n    constructor(message, source) {\n        super(`Error parsing ${source}: ${message}`, source);\n        this.code = \"EPARSER\";\n        this.name = \"ParserError\";\n    }\n}\nexports.ParserError = ParserError;\nclass UnmatchedParserError extends JSONParserError {\n    constructor(source) {\n        super(`Could not find parser for \"${source}\"`, source);\n        this.code = \"EUNMATCHEDPARSER\";\n        this.name = \"UnmatchedParserError\";\n    }\n}\nexports.UnmatchedParserError = UnmatchedParserError;\nclass ResolverError extends JSONParserError {\n    constructor(ex, source) {\n        super(ex.message || `Error reading file \"${source}\"`, source);\n        this.code = \"ERESOLVER\";\n        this.name = \"ResolverError\";\n        if (\"code\" in ex) {\n            this.ioErrorCode = String(ex.code);\n        }\n    }\n}\nexports.ResolverError = ResolverError;\nclass UnmatchedResolverError extends JSONParserError {\n    constructor(source) {\n        super(`Could not find resolver for \"${source}\"`, source);\n        this.code = \"EUNMATCHEDRESOLVER\";\n        this.name = \"UnmatchedResolverError\";\n    }\n}\nexports.UnmatchedResolverError = UnmatchedResolverError;\nclass MissingPointerError extends JSONParserError {\n    constructor(token, path) {\n        super(`Token \"${token}\" does not exist.`, (0, url_js_1.stripHash)(path));\n        this.code = \"EUNMATCHEDRESOLVER\";\n        this.name = \"MissingPointerError\";\n    }\n}\nexports.MissingPointerError = MissingPointerError;\nclass TimeoutError extends JSONParserError {\n    constructor(timeout) {\n        super(`Dereferencing timeout reached: ${timeout}ms`);\n        this.code = \"ETIMEOUT\";\n        this.name = \"TimeoutError\";\n    }\n}\nexports.TimeoutError = TimeoutError;\nclass InvalidPointerError extends JSONParserError {\n    constructor(pointer, path) {\n        super(`Invalid $ref pointer \"${pointer}\". Pointers must begin with \"#/\"`, (0, url_js_1.stripHash)(path));\n        this.code = \"EUNMATCHEDRESOLVER\";\n        this.name = \"InvalidPointerError\";\n    }\n}\nexports.InvalidPointerError = InvalidPointerError;\nfunction isHandledError(err) {\n    return err instanceof JSONParserError || err instanceof JSONParserErrorGroup;\n}\nfunction normalizeError(err) {\n    if (err.path === null) {\n        err.path = [];\n    }\n    return err;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvdXRpbC9lcnJvcnMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkJBQTJCLEdBQUcsb0JBQW9CLEdBQUcsMkJBQTJCLEdBQUcsOEJBQThCLEdBQUcscUJBQXFCLEdBQUcsNEJBQTRCLEdBQUcsbUJBQW1CLEdBQUcsNEJBQTRCLEdBQUcsdUJBQXVCO0FBQ3ZQLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIsY0FBYyxtQkFBTyxDQUFDLDBFQUFpQjtBQUN2QyxpQkFBaUIsbUJBQU8sQ0FBQywrRkFBVTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFVBQVUsR0FBRyxZQUFZLEdBQUcsVUFBVSxHQUFHLGFBQWE7QUFDeEU7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG9CQUFvQixPQUFPLG1DQUFtQywwQkFBMEIsNERBQTREO0FBQzlLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0EsK0JBQStCLE9BQU8sSUFBSSxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0EsbURBQW1ELE9BQU87QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLDhDQUE4QyxPQUFPO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSx3QkFBd0IsTUFBTTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsZ0RBQWdELFFBQVE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NoYXRib3QtdWkvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvdXRpbC9lcnJvcnMuanM/MGI0MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW52YWxpZFBvaW50ZXJFcnJvciA9IGV4cG9ydHMuVGltZW91dEVycm9yID0gZXhwb3J0cy5NaXNzaW5nUG9pbnRlckVycm9yID0gZXhwb3J0cy5Vbm1hdGNoZWRSZXNvbHZlckVycm9yID0gZXhwb3J0cy5SZXNvbHZlckVycm9yID0gZXhwb3J0cy5Vbm1hdGNoZWRQYXJzZXJFcnJvciA9IGV4cG9ydHMuUGFyc2VyRXJyb3IgPSBleHBvcnRzLkpTT05QYXJzZXJFcnJvckdyb3VwID0gZXhwb3J0cy5KU09OUGFyc2VyRXJyb3IgPSB2b2lkIDA7XG5leHBvcnRzLmlzSGFuZGxlZEVycm9yID0gaXNIYW5kbGVkRXJyb3I7XG5leHBvcnRzLm5vcm1hbGl6ZUVycm9yID0gbm9ybWFsaXplRXJyb3I7XG5jb25zdCBvbm9fMSA9IHJlcXVpcmUoXCJAanNkZXZ0b29scy9vbm9cIik7XG5jb25zdCB1cmxfanNfMSA9IHJlcXVpcmUoXCIuL3VybC5qc1wiKTtcbmNsYXNzIEpTT05QYXJzZXJFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzb3VyY2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb2RlID0gXCJFVU5LTk9XTlwiO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIkpTT05QYXJzZXJFcnJvclwiO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5wYXRoID0gbnVsbDtcbiAgICAgICAgb25vXzEuT25vLmV4dGVuZCh0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGZvb3RwcmludCgpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMucGF0aH0rJHt0aGlzLnNvdXJjZX0rJHt0aGlzLmNvZGV9KyR7dGhpcy5tZXNzYWdlfWA7XG4gICAgfVxufVxuZXhwb3J0cy5KU09OUGFyc2VyRXJyb3IgPSBKU09OUGFyc2VyRXJyb3I7XG5jbGFzcyBKU09OUGFyc2VyRXJyb3JHcm91cCBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5maWxlcyA9IHBhcnNlcjtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJKU09OUGFyc2VyRXJyb3JHcm91cFwiO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBgJHt0aGlzLmVycm9ycy5sZW5ndGh9IGVycm9yJHt0aGlzLmVycm9ycy5sZW5ndGggPiAxID8gXCJzXCIgOiBcIlwifSBvY2N1cnJlZCB3aGlsZSByZWFkaW5nICckeygwLCB1cmxfanNfMS50b0ZpbGVTeXN0ZW1QYXRoKShwYXJzZXIuJHJlZnMuX3Jvb3QkUmVmLnBhdGgpfSdgO1xuICAgICAgICBvbm9fMS5Pbm8uZXh0ZW5kKHRoaXMpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0UGFyc2VyRXJyb3JzKHBhcnNlcikge1xuICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCAkcmVmIG9mIE9iamVjdC52YWx1ZXMocGFyc2VyLiRyZWZzLl8kcmVmcykpIHtcbiAgICAgICAgICAgIGlmICgkcmVmLmVycm9ycykge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKC4uLiRyZWYuZXJyb3JzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyb3JzO1xuICAgIH1cbiAgICBnZXQgZXJyb3JzKCkge1xuICAgICAgICByZXR1cm4gSlNPTlBhcnNlckVycm9yR3JvdXAuZ2V0UGFyc2VyRXJyb3JzKHRoaXMuZmlsZXMpO1xuICAgIH1cbn1cbmV4cG9ydHMuSlNPTlBhcnNlckVycm9yR3JvdXAgPSBKU09OUGFyc2VyRXJyb3JHcm91cDtcbmNsYXNzIFBhcnNlckVycm9yIGV4dGVuZHMgSlNPTlBhcnNlckVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzb3VyY2UpIHtcbiAgICAgICAgc3VwZXIoYEVycm9yIHBhcnNpbmcgJHtzb3VyY2V9OiAke21lc3NhZ2V9YCwgc291cmNlKTtcbiAgICAgICAgdGhpcy5jb2RlID0gXCJFUEFSU0VSXCI7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiUGFyc2VyRXJyb3JcIjtcbiAgICB9XG59XG5leHBvcnRzLlBhcnNlckVycm9yID0gUGFyc2VyRXJyb3I7XG5jbGFzcyBVbm1hdGNoZWRQYXJzZXJFcnJvciBleHRlbmRzIEpTT05QYXJzZXJFcnJvciB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlKSB7XG4gICAgICAgIHN1cGVyKGBDb3VsZCBub3QgZmluZCBwYXJzZXIgZm9yIFwiJHtzb3VyY2V9XCJgLCBzb3VyY2UpO1xuICAgICAgICB0aGlzLmNvZGUgPSBcIkVVTk1BVENIRURQQVJTRVJcIjtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJVbm1hdGNoZWRQYXJzZXJFcnJvclwiO1xuICAgIH1cbn1cbmV4cG9ydHMuVW5tYXRjaGVkUGFyc2VyRXJyb3IgPSBVbm1hdGNoZWRQYXJzZXJFcnJvcjtcbmNsYXNzIFJlc29sdmVyRXJyb3IgZXh0ZW5kcyBKU09OUGFyc2VyRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGV4LCBzb3VyY2UpIHtcbiAgICAgICAgc3VwZXIoZXgubWVzc2FnZSB8fCBgRXJyb3IgcmVhZGluZyBmaWxlIFwiJHtzb3VyY2V9XCJgLCBzb3VyY2UpO1xuICAgICAgICB0aGlzLmNvZGUgPSBcIkVSRVNPTFZFUlwiO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlJlc29sdmVyRXJyb3JcIjtcbiAgICAgICAgaWYgKFwiY29kZVwiIGluIGV4KSB7XG4gICAgICAgICAgICB0aGlzLmlvRXJyb3JDb2RlID0gU3RyaW5nKGV4LmNvZGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5SZXNvbHZlckVycm9yID0gUmVzb2x2ZXJFcnJvcjtcbmNsYXNzIFVubWF0Y2hlZFJlc29sdmVyRXJyb3IgZXh0ZW5kcyBKU09OUGFyc2VyRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgICAgICBzdXBlcihgQ291bGQgbm90IGZpbmQgcmVzb2x2ZXIgZm9yIFwiJHtzb3VyY2V9XCJgLCBzb3VyY2UpO1xuICAgICAgICB0aGlzLmNvZGUgPSBcIkVVTk1BVENIRURSRVNPTFZFUlwiO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlVubWF0Y2hlZFJlc29sdmVyRXJyb3JcIjtcbiAgICB9XG59XG5leHBvcnRzLlVubWF0Y2hlZFJlc29sdmVyRXJyb3IgPSBVbm1hdGNoZWRSZXNvbHZlckVycm9yO1xuY2xhc3MgTWlzc2luZ1BvaW50ZXJFcnJvciBleHRlbmRzIEpTT05QYXJzZXJFcnJvciB7XG4gICAgY29uc3RydWN0b3IodG9rZW4sIHBhdGgpIHtcbiAgICAgICAgc3VwZXIoYFRva2VuIFwiJHt0b2tlbn1cIiBkb2VzIG5vdCBleGlzdC5gLCAoMCwgdXJsX2pzXzEuc3RyaXBIYXNoKShwYXRoKSk7XG4gICAgICAgIHRoaXMuY29kZSA9IFwiRVVOTUFUQ0hFRFJFU09MVkVSXCI7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiTWlzc2luZ1BvaW50ZXJFcnJvclwiO1xuICAgIH1cbn1cbmV4cG9ydHMuTWlzc2luZ1BvaW50ZXJFcnJvciA9IE1pc3NpbmdQb2ludGVyRXJyb3I7XG5jbGFzcyBUaW1lb3V0RXJyb3IgZXh0ZW5kcyBKU09OUGFyc2VyRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHRpbWVvdXQpIHtcbiAgICAgICAgc3VwZXIoYERlcmVmZXJlbmNpbmcgdGltZW91dCByZWFjaGVkOiAke3RpbWVvdXR9bXNgKTtcbiAgICAgICAgdGhpcy5jb2RlID0gXCJFVElNRU9VVFwiO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlRpbWVvdXRFcnJvclwiO1xuICAgIH1cbn1cbmV4cG9ydHMuVGltZW91dEVycm9yID0gVGltZW91dEVycm9yO1xuY2xhc3MgSW52YWxpZFBvaW50ZXJFcnJvciBleHRlbmRzIEpTT05QYXJzZXJFcnJvciB7XG4gICAgY29uc3RydWN0b3IocG9pbnRlciwgcGF0aCkge1xuICAgICAgICBzdXBlcihgSW52YWxpZCAkcmVmIHBvaW50ZXIgXCIke3BvaW50ZXJ9XCIuIFBvaW50ZXJzIG11c3QgYmVnaW4gd2l0aCBcIiMvXCJgLCAoMCwgdXJsX2pzXzEuc3RyaXBIYXNoKShwYXRoKSk7XG4gICAgICAgIHRoaXMuY29kZSA9IFwiRVVOTUFUQ0hFRFJFU09MVkVSXCI7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiSW52YWxpZFBvaW50ZXJFcnJvclwiO1xuICAgIH1cbn1cbmV4cG9ydHMuSW52YWxpZFBvaW50ZXJFcnJvciA9IEludmFsaWRQb2ludGVyRXJyb3I7XG5mdW5jdGlvbiBpc0hhbmRsZWRFcnJvcihlcnIpIHtcbiAgICByZXR1cm4gZXJyIGluc3RhbmNlb2YgSlNPTlBhcnNlckVycm9yIHx8IGVyciBpbnN0YW5jZW9mIEpTT05QYXJzZXJFcnJvckdyb3VwO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplRXJyb3IoZXJyKSB7XG4gICAgaWYgKGVyci5wYXRoID09PSBudWxsKSB7XG4gICAgICAgIGVyci5wYXRoID0gW107XG4gICAgfVxuICAgIHJldHVybiBlcnI7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/errors.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/is-windows.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/is-windows.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isWindows = void 0;\nconst isWindowsConst = /^win/.test(globalThis.process ? globalThis.process.platform : \"\");\nconst isWindows = () => isWindowsConst;\nexports.isWindows = isWindows;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvdXRpbC9pcy13aW5kb3dzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2hhdGJvdC11aS8uL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kaXN0L2xpYi91dGlsL2lzLXdpbmRvd3MuanM/ZDhlZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaXNXaW5kb3dzID0gdm9pZCAwO1xuY29uc3QgaXNXaW5kb3dzQ29uc3QgPSAvXndpbi8udGVzdChnbG9iYWxUaGlzLnByb2Nlc3MgPyBnbG9iYWxUaGlzLnByb2Nlc3MucGxhdGZvcm0gOiBcIlwiKTtcbmNvbnN0IGlzV2luZG93cyA9ICgpID0+IGlzV2luZG93c0NvbnN0O1xuZXhwb3J0cy5pc1dpbmRvd3MgPSBpc1dpbmRvd3M7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/is-windows.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/maybe.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/maybe.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports[\"default\"] = maybe;\nconst next_js_1 = __importDefault(__webpack_require__(/*! ./next.js */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/next.js\"));\nfunction maybe(cb, promise) {\n    if (cb) {\n        promise.then(function (result) {\n            (0, next_js_1.default)(function () {\n                cb(null, result);\n            });\n        }, function (err) {\n            (0, next_js_1.default)(function () {\n                cb(err);\n            });\n        });\n        return undefined;\n    }\n    else {\n        return promise;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvdXRpbC9tYXliZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFlO0FBQ2Ysa0NBQWtDLG1CQUFPLENBQUMsaUdBQVc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY2hhdGJvdC11aS8uL25vZGVfbW9kdWxlcy9AYXBpZGV2dG9vbHMvanNvbi1zY2hlbWEtcmVmLXBhcnNlci9kaXN0L2xpYi91dGlsL21heWJlLmpzP2U4NGMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlZmF1bHQgPSBtYXliZTtcbmNvbnN0IG5leHRfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9uZXh0LmpzXCIpKTtcbmZ1bmN0aW9uIG1heWJlKGNiLCBwcm9taXNlKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAoMCwgbmV4dF9qc18xLmRlZmF1bHQpKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjYihudWxsLCByZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICgwLCBuZXh0X2pzXzEuZGVmYXVsdCkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNiKGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/maybe.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/next.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/next.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nfunction makeNext() {\n    if (typeof process === \"object\" && typeof process.nextTick === \"function\") {\n        return process.nextTick;\n    }\n    else if (typeof setImmediate === \"function\") {\n        return setImmediate;\n    }\n    else {\n        return function next(f) {\n            setTimeout(f, 0);\n        };\n    }\n}\nexports[\"default\"] = makeNext();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvdXRpbC9uZXh0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaGF0Ym90LXVpLy4vbm9kZV9tb2R1bGVzL0BhcGlkZXZ0b29scy9qc29uLXNjaGVtYS1yZWYtcGFyc2VyL2Rpc3QvbGliL3V0aWwvbmV4dC5qcz85ODI5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gbWFrZU5leHQoKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBwcm9jZXNzLm5leHRUaWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2s7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gc2V0SW1tZWRpYXRlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoZikge1xuICAgICAgICAgICAgc2V0VGltZW91dChmLCAwKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBtYWtlTmV4dCgpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/next.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/plugins.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/plugins.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.all = all;\nexports.filter = filter;\nexports.sort = sort;\nexports.run = run;\n/**\n * Returns the given plugins as an array, rather than an object map.\n * All other methods in this module expect an array of plugins rather than an object map.\n *\n * @returns\n */\nfunction all(plugins) {\n    return Object.keys(plugins || {})\n        .filter((key) => {\n        return typeof plugins[key] === \"object\";\n    })\n        .map((key) => {\n        plugins[key].name = key;\n        return plugins[key];\n    });\n}\n/**\n * Filters the given plugins, returning only the ones return `true` for the given method.\n */\nfunction filter(plugins, method, file) {\n    return plugins.filter((plugin) => {\n        return !!getResult(plugin, method, file);\n    });\n}\n/**\n * Sorts the given plugins, in place, by their `order` property.\n */\nfunction sort(plugins) {\n    for (const plugin of plugins) {\n        plugin.order = plugin.order || Number.MAX_SAFE_INTEGER;\n    }\n    return plugins.sort((a, b) => {\n        return a.order - b.order;\n    });\n}\n/**\n * Runs the specified method of the given plugins, in order, until one of them returns a successful result.\n * Each method can return a synchronous value, a Promise, or call an error-first callback.\n * If the promise resolves successfully, or the callback is called without an error, then the result\n * is immediately returned and no further plugins are called.\n * If the promise rejects, or the callback is called with an error, then the next plugin is called.\n * If ALL plugins fail, then the last error is thrown.\n */\nasync function run(plugins, method, file, $refs) {\n    let plugin;\n    let lastError;\n    let index = 0;\n    return new Promise((resolve, reject) => {\n        runNextPlugin();\n        function runNextPlugin() {\n            plugin = plugins[index++];\n            if (!plugin) {\n                // There are no more functions, so re-throw the last error\n                return reject(lastError);\n            }\n            try {\n                // console.log('  %s', plugin.name);\n                const result = getResult(plugin, method, file, callback, $refs);\n                if (result && typeof result.then === \"function\") {\n                    // A promise was returned\n                    result.then(onSuccess, onError);\n                }\n                else if (result !== undefined) {\n                    // A synchronous result was returned\n                    onSuccess(result);\n                }\n                else if (index === plugins.length) {\n                    throw new Error(\"No promise has been returned or callback has been called.\");\n                }\n            }\n            catch (e) {\n                onError(e);\n            }\n        }\n        function callback(err, result) {\n            if (err) {\n                onError(err);\n            }\n            else {\n                onSuccess(result);\n            }\n        }\n        function onSuccess(result) {\n            // console.log('    success');\n            resolve({\n                plugin,\n                result,\n            });\n        }\n        function onError(error) {\n            // console.log('    %s', err.message || err);\n            lastError = {\n                plugin,\n                error,\n            };\n            runNextPlugin();\n        }\n    });\n}\n/**\n * Returns the value of the given property.\n * If the property is a function, then the result of the function is returned.\n * If the value is a RegExp, then it will be tested against the file URL.\n * If the value is an array, then it will be compared against the file extension.\n */\nfunction getResult(obj, prop, file, callback, $refs) {\n    const value = obj[prop];\n    if (typeof value === \"function\") {\n        return value.apply(obj, [file, callback, $refs]);\n    }\n    if (!callback) {\n        // The synchronous plugin functions (canParse and canRead)\n        // allow a \"shorthand\" syntax, where the user can match\n        // files by RegExp or by file extension.\n        if (value instanceof RegExp) {\n            return value.test(file.url);\n        }\n        else if (typeof value === \"string\") {\n            return value === file.extension;\n        }\n        else if (Array.isArray(value)) {\n            return value.indexOf(file.extension) !== -1;\n        }\n    }\n    return value;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvdXRpbC9wbHVnaW5zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFdBQVc7QUFDWCxjQUFjO0FBQ2QsWUFBWTtBQUNaLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NoYXRib3QtdWkvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvdXRpbC9wbHVnaW5zLmpzPzQ5ZmMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFsbCA9IGFsbDtcbmV4cG9ydHMuZmlsdGVyID0gZmlsdGVyO1xuZXhwb3J0cy5zb3J0ID0gc29ydDtcbmV4cG9ydHMucnVuID0gcnVuO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBnaXZlbiBwbHVnaW5zIGFzIGFuIGFycmF5LCByYXRoZXIgdGhhbiBhbiBvYmplY3QgbWFwLlxuICogQWxsIG90aGVyIG1ldGhvZHMgaW4gdGhpcyBtb2R1bGUgZXhwZWN0IGFuIGFycmF5IG9mIHBsdWdpbnMgcmF0aGVyIHRoYW4gYW4gb2JqZWN0IG1hcC5cbiAqXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBhbGwocGx1Z2lucykge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhwbHVnaW5zIHx8IHt9KVxuICAgICAgICAuZmlsdGVyKChrZXkpID0+IHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBwbHVnaW5zW2tleV0gPT09IFwib2JqZWN0XCI7XG4gICAgfSlcbiAgICAgICAgLm1hcCgoa2V5KSA9PiB7XG4gICAgICAgIHBsdWdpbnNba2V5XS5uYW1lID0ga2V5O1xuICAgICAgICByZXR1cm4gcGx1Z2luc1trZXldO1xuICAgIH0pO1xufVxuLyoqXG4gKiBGaWx0ZXJzIHRoZSBnaXZlbiBwbHVnaW5zLCByZXR1cm5pbmcgb25seSB0aGUgb25lcyByZXR1cm4gYHRydWVgIGZvciB0aGUgZ2l2ZW4gbWV0aG9kLlxuICovXG5mdW5jdGlvbiBmaWx0ZXIocGx1Z2lucywgbWV0aG9kLCBmaWxlKSB7XG4gICAgcmV0dXJuIHBsdWdpbnMuZmlsdGVyKChwbHVnaW4pID0+IHtcbiAgICAgICAgcmV0dXJuICEhZ2V0UmVzdWx0KHBsdWdpbiwgbWV0aG9kLCBmaWxlKTtcbiAgICB9KTtcbn1cbi8qKlxuICogU29ydHMgdGhlIGdpdmVuIHBsdWdpbnMsIGluIHBsYWNlLCBieSB0aGVpciBgb3JkZXJgIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBzb3J0KHBsdWdpbnMpIHtcbiAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiBwbHVnaW5zKSB7XG4gICAgICAgIHBsdWdpbi5vcmRlciA9IHBsdWdpbi5vcmRlciB8fCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICB9XG4gICAgcmV0dXJuIHBsdWdpbnMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICByZXR1cm4gYS5vcmRlciAtIGIub3JkZXI7XG4gICAgfSk7XG59XG4vKipcbiAqIFJ1bnMgdGhlIHNwZWNpZmllZCBtZXRob2Qgb2YgdGhlIGdpdmVuIHBsdWdpbnMsIGluIG9yZGVyLCB1bnRpbCBvbmUgb2YgdGhlbSByZXR1cm5zIGEgc3VjY2Vzc2Z1bCByZXN1bHQuXG4gKiBFYWNoIG1ldGhvZCBjYW4gcmV0dXJuIGEgc3luY2hyb25vdXMgdmFsdWUsIGEgUHJvbWlzZSwgb3IgY2FsbCBhbiBlcnJvci1maXJzdCBjYWxsYmFjay5cbiAqIElmIHRoZSBwcm9taXNlIHJlc29sdmVzIHN1Y2Nlc3NmdWxseSwgb3IgdGhlIGNhbGxiYWNrIGlzIGNhbGxlZCB3aXRob3V0IGFuIGVycm9yLCB0aGVuIHRoZSByZXN1bHRcbiAqIGlzIGltbWVkaWF0ZWx5IHJldHVybmVkIGFuZCBubyBmdXJ0aGVyIHBsdWdpbnMgYXJlIGNhbGxlZC5cbiAqIElmIHRoZSBwcm9taXNlIHJlamVjdHMsIG9yIHRoZSBjYWxsYmFjayBpcyBjYWxsZWQgd2l0aCBhbiBlcnJvciwgdGhlbiB0aGUgbmV4dCBwbHVnaW4gaXMgY2FsbGVkLlxuICogSWYgQUxMIHBsdWdpbnMgZmFpbCwgdGhlbiB0aGUgbGFzdCBlcnJvciBpcyB0aHJvd24uXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJ1bihwbHVnaW5zLCBtZXRob2QsIGZpbGUsICRyZWZzKSB7XG4gICAgbGV0IHBsdWdpbjtcbiAgICBsZXQgbGFzdEVycm9yO1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgcnVuTmV4dFBsdWdpbigpO1xuICAgICAgICBmdW5jdGlvbiBydW5OZXh0UGx1Z2luKCkge1xuICAgICAgICAgICAgcGx1Z2luID0gcGx1Z2luc1tpbmRleCsrXTtcbiAgICAgICAgICAgIGlmICghcGx1Z2luKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlcmUgYXJlIG5vIG1vcmUgZnVuY3Rpb25zLCBzbyByZS10aHJvdyB0aGUgbGFzdCBlcnJvclxuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobGFzdEVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJyAgJXMnLCBwbHVnaW4ubmFtZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZ2V0UmVzdWx0KHBsdWdpbiwgbWV0aG9kLCBmaWxlLCBjYWxsYmFjaywgJHJlZnMpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgJiYgdHlwZW9mIHJlc3VsdC50aGVuID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBwcm9taXNlIHdhcyByZXR1cm5lZFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQudGhlbihvblN1Y2Nlc3MsIG9uRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIHN5bmNocm9ub3VzIHJlc3VsdCB3YXMgcmV0dXJuZWRcbiAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGluZGV4ID09PSBwbHVnaW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBwcm9taXNlIGhhcyBiZWVuIHJldHVybmVkIG9yIGNhbGxiYWNrIGhhcyBiZWVuIGNhbGxlZC5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBvbkVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNhbGxiYWNrKGVyciwgcmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb25TdWNjZXNzKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25TdWNjZXNzKHJlc3VsdCkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJyAgICBzdWNjZXNzJyk7XG4gICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICBwbHVnaW4sXG4gICAgICAgICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25FcnJvcihlcnJvcikge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJyAgICAlcycsIGVyci5tZXNzYWdlIHx8IGVycik7XG4gICAgICAgICAgICBsYXN0RXJyb3IgPSB7XG4gICAgICAgICAgICAgICAgcGx1Z2luLFxuICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJ1bk5leHRQbHVnaW4oKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gKiBJZiB0aGUgcHJvcGVydHkgaXMgYSBmdW5jdGlvbiwgdGhlbiB0aGUgcmVzdWx0IG9mIHRoZSBmdW5jdGlvbiBpcyByZXR1cm5lZC5cbiAqIElmIHRoZSB2YWx1ZSBpcyBhIFJlZ0V4cCwgdGhlbiBpdCB3aWxsIGJlIHRlc3RlZCBhZ2FpbnN0IHRoZSBmaWxlIFVSTC5cbiAqIElmIHRoZSB2YWx1ZSBpcyBhbiBhcnJheSwgdGhlbiBpdCB3aWxsIGJlIGNvbXBhcmVkIGFnYWluc3QgdGhlIGZpbGUgZXh0ZW5zaW9uLlxuICovXG5mdW5jdGlvbiBnZXRSZXN1bHQob2JqLCBwcm9wLCBmaWxlLCBjYWxsYmFjaywgJHJlZnMpIHtcbiAgICBjb25zdCB2YWx1ZSA9IG9ialtwcm9wXTtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmFwcGx5KG9iaiwgW2ZpbGUsIGNhbGxiYWNrLCAkcmVmc10pO1xuICAgIH1cbiAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgIC8vIFRoZSBzeW5jaHJvbm91cyBwbHVnaW4gZnVuY3Rpb25zIChjYW5QYXJzZSBhbmQgY2FuUmVhZClcbiAgICAgICAgLy8gYWxsb3cgYSBcInNob3J0aGFuZFwiIHN5bnRheCwgd2hlcmUgdGhlIHVzZXIgY2FuIG1hdGNoXG4gICAgICAgIC8vIGZpbGVzIGJ5IFJlZ0V4cCBvciBieSBmaWxlIGV4dGVuc2lvbi5cbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudGVzdChmaWxlLnVybCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IGZpbGUuZXh0ZW5zaW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuaW5kZXhPZihmaWxlLmV4dGVuc2lvbikgIT09IC0xO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/plugins.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/url.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/url.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parse = void 0;\nexports.resolve = resolve;\nexports.cwd = cwd;\nexports.getProtocol = getProtocol;\nexports.getExtension = getExtension;\nexports.stripQuery = stripQuery;\nexports.getHash = getHash;\nexports.stripHash = stripHash;\nexports.isHttp = isHttp;\nexports.isFileSystemPath = isFileSystemPath;\nexports.fromFileSystemPath = fromFileSystemPath;\nexports.toFileSystemPath = toFileSystemPath;\nexports.safePointerToPath = safePointerToPath;\nexports.relative = relative;\nconst convert_path_to_posix_1 = __importDefault(__webpack_require__(/*! ./convert-path-to-posix */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/convert-path-to-posix.js\"));\nconst path_1 = __importStar(__webpack_require__(/*! path */ \"path\"));\nconst forwardSlashPattern = /\\//g;\nconst protocolPattern = /^(\\w{2,}):\\/\\//i;\nconst jsonPointerSlash = /~1/g;\nconst jsonPointerTilde = /~0/g;\nconst path_2 = __webpack_require__(/*! path */ \"path\");\nconst is_windows_1 = __webpack_require__(/*! ./is-windows */ \"(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/is-windows.js\");\n// RegExp patterns to URL-encode special characters in local filesystem paths\nconst urlEncodePatterns = [\n    [/\\?/g, \"%3F\"],\n    [/#/g, \"%23\"],\n];\n// RegExp patterns to URL-decode special characters for local filesystem paths\nconst urlDecodePatterns = [/%23/g, \"#\", /%24/g, \"$\", /%26/g, \"&\", /%2C/g, \",\", /%40/g, \"@\"];\nconst parse = (u) => new URL(u);\nexports.parse = parse;\n/**\n * Returns resolved target URL relative to a base URL in a manner similar to that of a Web browser resolving an anchor tag HREF.\n *\n * @returns\n */\nfunction resolve(from, to) {\n    const fromUrl = new URL((0, convert_path_to_posix_1.default)(from), \"resolve://\");\n    const resolvedUrl = new URL((0, convert_path_to_posix_1.default)(to), fromUrl);\n    const endSpaces = to.match(/(\\s*)$/)?.[1] || \"\";\n    if (resolvedUrl.protocol === \"resolve:\") {\n        // `from` is a relative URL.\n        const { pathname, search, hash } = resolvedUrl;\n        return pathname + search + hash + endSpaces;\n    }\n    return resolvedUrl.toString() + endSpaces;\n}\n/**\n * Returns the current working directory (in Node) or the current page URL (in browsers).\n *\n * @returns\n */\nfunction cwd() {\n    if (typeof window !== \"undefined\") {\n        return location.href;\n    }\n    const path = process.cwd();\n    const lastChar = path.slice(-1);\n    if (lastChar === \"/\" || lastChar === \"\\\\\") {\n        return path;\n    }\n    else {\n        return path + \"/\";\n    }\n}\n/**\n * Returns the protocol of the given URL, or `undefined` if it has no protocol.\n *\n * @param path\n * @returns\n */\nfunction getProtocol(path) {\n    const match = protocolPattern.exec(path || \"\");\n    if (match) {\n        return match[1].toLowerCase();\n    }\n    return undefined;\n}\n/**\n * Returns the lowercased file extension of the given URL,\n * or an empty string if it has no extension.\n *\n * @param path\n * @returns\n */\nfunction getExtension(path) {\n    const lastDot = path.lastIndexOf(\".\");\n    if (lastDot >= 0) {\n        return stripQuery(path.substr(lastDot).toLowerCase());\n    }\n    return \"\";\n}\n/**\n * Removes the query, if any, from the given path.\n *\n * @param path\n * @returns\n */\nfunction stripQuery(path) {\n    const queryIndex = path.indexOf(\"?\");\n    if (queryIndex >= 0) {\n        path = path.substr(0, queryIndex);\n    }\n    return path;\n}\n/**\n * Returns the hash (URL fragment), of the given path.\n * If there is no hash, then the root hash (\"#\") is returned.\n *\n * @param path\n * @returns\n */\nfunction getHash(path) {\n    if (!path) {\n        return \"#\";\n    }\n    const hashIndex = path.indexOf(\"#\");\n    if (hashIndex >= 0) {\n        return path.substring(hashIndex);\n    }\n    return \"#\";\n}\n/**\n * Removes the hash (URL fragment), if any, from the given path.\n *\n * @param path\n * @returns\n */\nfunction stripHash(path) {\n    if (!path) {\n        return \"\";\n    }\n    const hashIndex = path.indexOf(\"#\");\n    if (hashIndex >= 0) {\n        path = path.substring(0, hashIndex);\n    }\n    return path;\n}\n/**\n * Determines whether the given path is an HTTP(S) URL.\n *\n * @param path\n * @returns\n */\nfunction isHttp(path) {\n    const protocol = getProtocol(path);\n    if (protocol === \"http\" || protocol === \"https\") {\n        return true;\n    }\n    else if (protocol === undefined) {\n        // There is no protocol.  If we're running in a browser, then assume it's HTTP.\n        return typeof window !== \"undefined\";\n    }\n    else {\n        // It's some other protocol, such as \"ftp://\", \"mongodb://\", etc.\n        return false;\n    }\n}\n/**\n * Determines whether the given path is a filesystem path.\n * This includes \"file://\" URLs.\n *\n * @param path\n * @returns\n */\nfunction isFileSystemPath(path) {\n    // @ts-ignore\n    if (typeof window !== \"undefined\" || (typeof process !== \"undefined\" && false)) {\n        // We're running in a browser, so assume that all paths are URLs.\n        // This way, even relative paths will be treated as URLs rather than as filesystem paths\n        return false;\n    }\n    const protocol = getProtocol(path);\n    return protocol === undefined || protocol === \"file\";\n}\n/**\n * Converts a filesystem path to a properly-encoded URL.\n *\n * This is intended to handle situations where JSON Schema $Ref Parser is called\n * with a filesystem path that contains characters which are not allowed in URLs.\n *\n * @example\n * The following filesystem paths would be converted to the following URLs:\n *\n *    <\"!@#$%^&*+=?'>.json              ==>   %3C%22!@%23$%25%5E&*+=%3F\\'%3E.json\n *    C:\\\\My Documents\\\\File (1).json   ==>   C:/My%20Documents/File%20(1).json\n *    file://Project #42/file.json      ==>   file://Project%20%2342/file.json\n *\n * @param path\n * @returns\n */\nfunction fromFileSystemPath(path) {\n    // Step 1: On Windows, replace backslashes with forward slashes,\n    // rather than encoding them as \"%5C\"\n    if ((0, is_windows_1.isWindows)()) {\n        const projectDir = cwd();\n        const upperPath = path.toUpperCase();\n        const projectDirPosixPath = (0, convert_path_to_posix_1.default)(projectDir);\n        const posixUpper = projectDirPosixPath.toUpperCase();\n        const hasProjectDir = upperPath.includes(posixUpper);\n        const hasProjectUri = upperPath.includes(posixUpper);\n        const isAbsolutePath = path_1.win32?.isAbsolute(path) ||\n            path.startsWith(\"http://\") ||\n            path.startsWith(\"https://\") ||\n            path.startsWith(\"file://\");\n        if (!(hasProjectDir || hasProjectUri || isAbsolutePath) && !projectDir.startsWith(\"http\")) {\n            path = (0, path_2.join)(projectDir, path);\n        }\n        path = (0, convert_path_to_posix_1.default)(path);\n    }\n    // Step 2: `encodeURI` will take care of MOST characters\n    path = encodeURI(path);\n    // Step 3: Manually encode characters that are not encoded by `encodeURI`.\n    // This includes characters such as \"#\" and \"?\", which have special meaning in URLs,\n    // but are just normal characters in a filesystem path.\n    for (const pattern of urlEncodePatterns) {\n        path = path.replace(pattern[0], pattern[1]);\n    }\n    return path;\n}\n/**\n * Converts a URL to a local filesystem path.\n */\nfunction toFileSystemPath(path, keepFileProtocol) {\n    // Step 1: `decodeURI` will decode characters such as Cyrillic characters, spaces, etc.\n    path = decodeURI(path);\n    // Step 2: Manually decode characters that are not decoded by `decodeURI`.\n    // This includes characters such as \"#\" and \"?\", which have special meaning in URLs,\n    // but are just normal characters in a filesystem path.\n    for (let i = 0; i < urlDecodePatterns.length; i += 2) {\n        path = path.replace(urlDecodePatterns[i], urlDecodePatterns[i + 1]);\n    }\n    // Step 3: If it's a \"file://\" URL, then format it consistently\n    // or convert it to a local filesystem path\n    let isFileUrl = path.substr(0, 7).toLowerCase() === \"file://\";\n    if (isFileUrl) {\n        // Strip-off the protocol, and the initial \"/\", if there is one\n        path = path[7] === \"/\" ? path.substr(8) : path.substr(7);\n        // insert a colon (\":\") after the drive letter on Windows\n        if ((0, is_windows_1.isWindows)() && path[1] === \"/\") {\n            path = path[0] + \":\" + path.substr(1);\n        }\n        if (keepFileProtocol) {\n            // Return the consistently-formatted \"file://\" URL\n            path = \"file:///\" + path;\n        }\n        else {\n            // Convert the \"file://\" URL to a local filesystem path.\n            // On Windows, it will start with something like \"C:/\".\n            // On Posix, it will start with \"/\"\n            isFileUrl = false;\n            path = (0, is_windows_1.isWindows)() ? path : \"/\" + path;\n        }\n    }\n    // Step 4: Normalize Windows paths (unless it's a \"file://\" URL)\n    if ((0, is_windows_1.isWindows)() && !isFileUrl) {\n        // Replace forward slashes with backslashes\n        path = path.replace(forwardSlashPattern, \"\\\\\");\n        // Capitalize the drive letter\n        if (path.substr(1, 2) === \":\\\\\") {\n            path = path[0].toUpperCase() + path.substr(1);\n        }\n    }\n    return path;\n}\n/**\n * Converts a $ref pointer to a valid JSON Path.\n *\n * @param pointer\n * @returns\n */\nfunction safePointerToPath(pointer) {\n    if (pointer.length <= 1 || pointer[0] !== \"#\" || pointer[1] !== \"/\") {\n        return [];\n    }\n    return pointer\n        .slice(2)\n        .split(\"/\")\n        .map((value) => {\n        return decodeURIComponent(value).replace(jsonPointerSlash, \"/\").replace(jsonPointerTilde, \"~\");\n    });\n}\nfunction relative(from, to) {\n    if (!isFileSystemPath(from) || !isFileSystemPath(to)) {\n        return resolve(from, to);\n    }\n    const fromDir = path_1.default.dirname(stripHash(from));\n    const toPath = stripHash(to);\n    const result = path_1.default.relative(fromDir, toPath);\n    return result + getHash(to);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvdXRpbC91cmwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYTtBQUNiLGVBQWU7QUFDZixXQUFXO0FBQ1gsbUJBQW1CO0FBQ25CLG9CQUFvQjtBQUNwQixrQkFBa0I7QUFDbEIsZUFBZTtBQUNmLGlCQUFpQjtBQUNqQixjQUFjO0FBQ2Qsd0JBQXdCO0FBQ3hCLDBCQUEwQjtBQUMxQix3QkFBd0I7QUFDeEIseUJBQXlCO0FBQ3pCLGdCQUFnQjtBQUNoQixnREFBZ0QsbUJBQU8sQ0FBQyxnSUFBeUI7QUFDakYsNEJBQTRCLG1CQUFPLENBQUMsa0JBQU07QUFDMUM7QUFDQSw4QkFBOEIsR0FBRztBQUNqQztBQUNBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLGtCQUFNO0FBQzdCLHFCQUFxQixtQkFBTyxDQUFDLDBHQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsS0FBZTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw4QkFBOEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NoYXRib3QtdWkvLi9ub2RlX21vZHVsZXMvQGFwaWRldnRvb2xzL2pzb24tc2NoZW1hLXJlZi1wYXJzZXIvZGlzdC9saWIvdXRpbC91cmwuanM/NWE5MCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wYXJzZSA9IHZvaWQgMDtcbmV4cG9ydHMucmVzb2x2ZSA9IHJlc29sdmU7XG5leHBvcnRzLmN3ZCA9IGN3ZDtcbmV4cG9ydHMuZ2V0UHJvdG9jb2wgPSBnZXRQcm90b2NvbDtcbmV4cG9ydHMuZ2V0RXh0ZW5zaW9uID0gZ2V0RXh0ZW5zaW9uO1xuZXhwb3J0cy5zdHJpcFF1ZXJ5ID0gc3RyaXBRdWVyeTtcbmV4cG9ydHMuZ2V0SGFzaCA9IGdldEhhc2g7XG5leHBvcnRzLnN0cmlwSGFzaCA9IHN0cmlwSGFzaDtcbmV4cG9ydHMuaXNIdHRwID0gaXNIdHRwO1xuZXhwb3J0cy5pc0ZpbGVTeXN0ZW1QYXRoID0gaXNGaWxlU3lzdGVtUGF0aDtcbmV4cG9ydHMuZnJvbUZpbGVTeXN0ZW1QYXRoID0gZnJvbUZpbGVTeXN0ZW1QYXRoO1xuZXhwb3J0cy50b0ZpbGVTeXN0ZW1QYXRoID0gdG9GaWxlU3lzdGVtUGF0aDtcbmV4cG9ydHMuc2FmZVBvaW50ZXJUb1BhdGggPSBzYWZlUG9pbnRlclRvUGF0aDtcbmV4cG9ydHMucmVsYXRpdmUgPSByZWxhdGl2ZTtcbmNvbnN0IGNvbnZlcnRfcGF0aF90b19wb3NpeF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2NvbnZlcnQtcGF0aC10by1wb3NpeFwiKSk7XG5jb25zdCBwYXRoXzEgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInBhdGhcIikpO1xuY29uc3QgZm9yd2FyZFNsYXNoUGF0dGVybiA9IC9cXC8vZztcbmNvbnN0IHByb3RvY29sUGF0dGVybiA9IC9eKFxcd3syLH0pOlxcL1xcLy9pO1xuY29uc3QganNvblBvaW50ZXJTbGFzaCA9IC9+MS9nO1xuY29uc3QganNvblBvaW50ZXJUaWxkZSA9IC9+MC9nO1xuY29uc3QgcGF0aF8yID0gcmVxdWlyZShcInBhdGhcIik7XG5jb25zdCBpc193aW5kb3dzXzEgPSByZXF1aXJlKFwiLi9pcy13aW5kb3dzXCIpO1xuLy8gUmVnRXhwIHBhdHRlcm5zIHRvIFVSTC1lbmNvZGUgc3BlY2lhbCBjaGFyYWN0ZXJzIGluIGxvY2FsIGZpbGVzeXN0ZW0gcGF0aHNcbmNvbnN0IHVybEVuY29kZVBhdHRlcm5zID0gW1xuICAgIFsvXFw/L2csIFwiJTNGXCJdLFxuICAgIFsvIy9nLCBcIiUyM1wiXSxcbl07XG4vLyBSZWdFeHAgcGF0dGVybnMgdG8gVVJMLWRlY29kZSBzcGVjaWFsIGNoYXJhY3RlcnMgZm9yIGxvY2FsIGZpbGVzeXN0ZW0gcGF0aHNcbmNvbnN0IHVybERlY29kZVBhdHRlcm5zID0gWy8lMjMvZywgXCIjXCIsIC8lMjQvZywgXCIkXCIsIC8lMjYvZywgXCImXCIsIC8lMkMvZywgXCIsXCIsIC8lNDAvZywgXCJAXCJdO1xuY29uc3QgcGFyc2UgPSAodSkgPT4gbmV3IFVSTCh1KTtcbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbi8qKlxuICogUmV0dXJucyByZXNvbHZlZCB0YXJnZXQgVVJMIHJlbGF0aXZlIHRvIGEgYmFzZSBVUkwgaW4gYSBtYW5uZXIgc2ltaWxhciB0byB0aGF0IG9mIGEgV2ViIGJyb3dzZXIgcmVzb2x2aW5nIGFuIGFuY2hvciB0YWcgSFJFRi5cbiAqXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiByZXNvbHZlKGZyb20sIHRvKSB7XG4gICAgY29uc3QgZnJvbVVybCA9IG5ldyBVUkwoKDAsIGNvbnZlcnRfcGF0aF90b19wb3NpeF8xLmRlZmF1bHQpKGZyb20pLCBcInJlc29sdmU6Ly9cIik7XG4gICAgY29uc3QgcmVzb2x2ZWRVcmwgPSBuZXcgVVJMKCgwLCBjb252ZXJ0X3BhdGhfdG9fcG9zaXhfMS5kZWZhdWx0KSh0byksIGZyb21VcmwpO1xuICAgIGNvbnN0IGVuZFNwYWNlcyA9IHRvLm1hdGNoKC8oXFxzKikkLyk/LlsxXSB8fCBcIlwiO1xuICAgIGlmIChyZXNvbHZlZFVybC5wcm90b2NvbCA9PT0gXCJyZXNvbHZlOlwiKSB7XG4gICAgICAgIC8vIGBmcm9tYCBpcyBhIHJlbGF0aXZlIFVSTC5cbiAgICAgICAgY29uc3QgeyBwYXRobmFtZSwgc2VhcmNoLCBoYXNoIH0gPSByZXNvbHZlZFVybDtcbiAgICAgICAgcmV0dXJuIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaCArIGVuZFNwYWNlcztcbiAgICB9XG4gICAgcmV0dXJuIHJlc29sdmVkVXJsLnRvU3RyaW5nKCkgKyBlbmRTcGFjZXM7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnkgKGluIE5vZGUpIG9yIHRoZSBjdXJyZW50IHBhZ2UgVVJMIChpbiBicm93c2VycykuXG4gKlxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gY3dkKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiBsb2NhdGlvbi5ocmVmO1xuICAgIH1cbiAgICBjb25zdCBwYXRoID0gcHJvY2Vzcy5jd2QoKTtcbiAgICBjb25zdCBsYXN0Q2hhciA9IHBhdGguc2xpY2UoLTEpO1xuICAgIGlmIChsYXN0Q2hhciA9PT0gXCIvXCIgfHwgbGFzdENoYXIgPT09IFwiXFxcXFwiKSB7XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHBhdGggKyBcIi9cIjtcbiAgICB9XG59XG4vKipcbiAqIFJldHVybnMgdGhlIHByb3RvY29sIG9mIHRoZSBnaXZlbiBVUkwsIG9yIGB1bmRlZmluZWRgIGlmIGl0IGhhcyBubyBwcm90b2NvbC5cbiAqXG4gKiBAcGFyYW0gcGF0aFxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gZ2V0UHJvdG9jb2wocGF0aCkge1xuICAgIGNvbnN0IG1hdGNoID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocGF0aCB8fCBcIlwiKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGxvd2VyY2FzZWQgZmlsZSBleHRlbnNpb24gb2YgdGhlIGdpdmVuIFVSTCxcbiAqIG9yIGFuIGVtcHR5IHN0cmluZyBpZiBpdCBoYXMgbm8gZXh0ZW5zaW9uLlxuICpcbiAqIEBwYXJhbSBwYXRoXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBnZXRFeHRlbnNpb24ocGF0aCkge1xuICAgIGNvbnN0IGxhc3REb3QgPSBwYXRoLmxhc3RJbmRleE9mKFwiLlwiKTtcbiAgICBpZiAobGFzdERvdCA+PSAwKSB7XG4gICAgICAgIHJldHVybiBzdHJpcFF1ZXJ5KHBhdGguc3Vic3RyKGxhc3REb3QpLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cbiAgICByZXR1cm4gXCJcIjtcbn1cbi8qKlxuICogUmVtb3ZlcyB0aGUgcXVlcnksIGlmIGFueSwgZnJvbSB0aGUgZ2l2ZW4gcGF0aC5cbiAqXG4gKiBAcGFyYW0gcGF0aFxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gc3RyaXBRdWVyeShwYXRoKSB7XG4gICAgY29uc3QgcXVlcnlJbmRleCA9IHBhdGguaW5kZXhPZihcIj9cIik7XG4gICAgaWYgKHF1ZXJ5SW5kZXggPj0gMCkge1xuICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHIoMCwgcXVlcnlJbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBoYXNoIChVUkwgZnJhZ21lbnQpLCBvZiB0aGUgZ2l2ZW4gcGF0aC5cbiAqIElmIHRoZXJlIGlzIG5vIGhhc2gsIHRoZW4gdGhlIHJvb3QgaGFzaCAoXCIjXCIpIGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSBwYXRoXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBnZXRIYXNoKHBhdGgpIHtcbiAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgcmV0dXJuIFwiI1wiO1xuICAgIH1cbiAgICBjb25zdCBoYXNoSW5kZXggPSBwYXRoLmluZGV4T2YoXCIjXCIpO1xuICAgIGlmIChoYXNoSW5kZXggPj0gMCkge1xuICAgICAgICByZXR1cm4gcGF0aC5zdWJzdHJpbmcoaGFzaEluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIFwiI1wiO1xufVxuLyoqXG4gKiBSZW1vdmVzIHRoZSBoYXNoIChVUkwgZnJhZ21lbnQpLCBpZiBhbnksIGZyb20gdGhlIGdpdmVuIHBhdGguXG4gKlxuICogQHBhcmFtIHBhdGhcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIHN0cmlwSGFzaChwYXRoKSB7XG4gICAgaWYgKCFwYXRoKSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICBjb25zdCBoYXNoSW5kZXggPSBwYXRoLmluZGV4T2YoXCIjXCIpO1xuICAgIGlmIChoYXNoSW5kZXggPj0gMCkge1xuICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcoMCwgaGFzaEluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGg7XG59XG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgZ2l2ZW4gcGF0aCBpcyBhbiBIVFRQKFMpIFVSTC5cbiAqXG4gKiBAcGFyYW0gcGF0aFxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gaXNIdHRwKHBhdGgpIHtcbiAgICBjb25zdCBwcm90b2NvbCA9IGdldFByb3RvY29sKHBhdGgpO1xuICAgIGlmIChwcm90b2NvbCA9PT0gXCJodHRwXCIgfHwgcHJvdG9jb2wgPT09IFwiaHR0cHNcIikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvdG9jb2wgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBUaGVyZSBpcyBubyBwcm90b2NvbC4gIElmIHdlJ3JlIHJ1bm5pbmcgaW4gYSBicm93c2VyLCB0aGVuIGFzc3VtZSBpdCdzIEhUVFAuXG4gICAgICAgIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gSXQncyBzb21lIG90aGVyIHByb3RvY29sLCBzdWNoIGFzIFwiZnRwOi8vXCIsIFwibW9uZ29kYjovL1wiLCBldGMuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgZ2l2ZW4gcGF0aCBpcyBhIGZpbGVzeXN0ZW0gcGF0aC5cbiAqIFRoaXMgaW5jbHVkZXMgXCJmaWxlOi8vXCIgVVJMcy5cbiAqXG4gKiBAcGFyYW0gcGF0aFxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gaXNGaWxlU3lzdGVtUGF0aChwYXRoKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiIHx8ICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmJyb3dzZXIpKSB7XG4gICAgICAgIC8vIFdlJ3JlIHJ1bm5pbmcgaW4gYSBicm93c2VyLCBzbyBhc3N1bWUgdGhhdCBhbGwgcGF0aHMgYXJlIFVSTHMuXG4gICAgICAgIC8vIFRoaXMgd2F5LCBldmVuIHJlbGF0aXZlIHBhdGhzIHdpbGwgYmUgdHJlYXRlZCBhcyBVUkxzIHJhdGhlciB0aGFuIGFzIGZpbGVzeXN0ZW0gcGF0aHNcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBwcm90b2NvbCA9IGdldFByb3RvY29sKHBhdGgpO1xuICAgIHJldHVybiBwcm90b2NvbCA9PT0gdW5kZWZpbmVkIHx8IHByb3RvY29sID09PSBcImZpbGVcIjtcbn1cbi8qKlxuICogQ29udmVydHMgYSBmaWxlc3lzdGVtIHBhdGggdG8gYSBwcm9wZXJseS1lbmNvZGVkIFVSTC5cbiAqXG4gKiBUaGlzIGlzIGludGVuZGVkIHRvIGhhbmRsZSBzaXR1YXRpb25zIHdoZXJlIEpTT04gU2NoZW1hICRSZWYgUGFyc2VyIGlzIGNhbGxlZFxuICogd2l0aCBhIGZpbGVzeXN0ZW0gcGF0aCB0aGF0IGNvbnRhaW5zIGNoYXJhY3RlcnMgd2hpY2ggYXJlIG5vdCBhbGxvd2VkIGluIFVSTHMuXG4gKlxuICogQGV4YW1wbGVcbiAqIFRoZSBmb2xsb3dpbmcgZmlsZXN5c3RlbSBwYXRocyB3b3VsZCBiZSBjb252ZXJ0ZWQgdG8gdGhlIGZvbGxvd2luZyBVUkxzOlxuICpcbiAqICAgIDxcIiFAIyQlXiYqKz0/Jz4uanNvbiAgICAgICAgICAgICAgPT0+ICAgJTNDJTIyIUAlMjMkJTI1JTVFJiorPSUzRlxcJyUzRS5qc29uXG4gKiAgICBDOlxcXFxNeSBEb2N1bWVudHNcXFxcRmlsZSAoMSkuanNvbiAgID09PiAgIEM6L015JTIwRG9jdW1lbnRzL0ZpbGUlMjAoMSkuanNvblxuICogICAgZmlsZTovL1Byb2plY3QgIzQyL2ZpbGUuanNvbiAgICAgID09PiAgIGZpbGU6Ly9Qcm9qZWN0JTIwJTIzNDIvZmlsZS5qc29uXG4gKlxuICogQHBhcmFtIHBhdGhcbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIGZyb21GaWxlU3lzdGVtUGF0aChwYXRoKSB7XG4gICAgLy8gU3RlcCAxOiBPbiBXaW5kb3dzLCByZXBsYWNlIGJhY2tzbGFzaGVzIHdpdGggZm9yd2FyZCBzbGFzaGVzLFxuICAgIC8vIHJhdGhlciB0aGFuIGVuY29kaW5nIHRoZW0gYXMgXCIlNUNcIlxuICAgIGlmICgoMCwgaXNfd2luZG93c18xLmlzV2luZG93cykoKSkge1xuICAgICAgICBjb25zdCBwcm9qZWN0RGlyID0gY3dkKCk7XG4gICAgICAgIGNvbnN0IHVwcGVyUGF0aCA9IHBhdGgudG9VcHBlckNhc2UoKTtcbiAgICAgICAgY29uc3QgcHJvamVjdERpclBvc2l4UGF0aCA9ICgwLCBjb252ZXJ0X3BhdGhfdG9fcG9zaXhfMS5kZWZhdWx0KShwcm9qZWN0RGlyKTtcbiAgICAgICAgY29uc3QgcG9zaXhVcHBlciA9IHByb2plY3REaXJQb3NpeFBhdGgudG9VcHBlckNhc2UoKTtcbiAgICAgICAgY29uc3QgaGFzUHJvamVjdERpciA9IHVwcGVyUGF0aC5pbmNsdWRlcyhwb3NpeFVwcGVyKTtcbiAgICAgICAgY29uc3QgaGFzUHJvamVjdFVyaSA9IHVwcGVyUGF0aC5pbmNsdWRlcyhwb3NpeFVwcGVyKTtcbiAgICAgICAgY29uc3QgaXNBYnNvbHV0ZVBhdGggPSBwYXRoXzEud2luMzI/LmlzQWJzb2x1dGUocGF0aCkgfHxcbiAgICAgICAgICAgIHBhdGguc3RhcnRzV2l0aChcImh0dHA6Ly9cIikgfHxcbiAgICAgICAgICAgIHBhdGguc3RhcnRzV2l0aChcImh0dHBzOi8vXCIpIHx8XG4gICAgICAgICAgICBwYXRoLnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpO1xuICAgICAgICBpZiAoIShoYXNQcm9qZWN0RGlyIHx8IGhhc1Byb2plY3RVcmkgfHwgaXNBYnNvbHV0ZVBhdGgpICYmICFwcm9qZWN0RGlyLnN0YXJ0c1dpdGgoXCJodHRwXCIpKSB7XG4gICAgICAgICAgICBwYXRoID0gKDAsIHBhdGhfMi5qb2luKShwcm9qZWN0RGlyLCBwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBwYXRoID0gKDAsIGNvbnZlcnRfcGF0aF90b19wb3NpeF8xLmRlZmF1bHQpKHBhdGgpO1xuICAgIH1cbiAgICAvLyBTdGVwIDI6IGBlbmNvZGVVUklgIHdpbGwgdGFrZSBjYXJlIG9mIE1PU1QgY2hhcmFjdGVyc1xuICAgIHBhdGggPSBlbmNvZGVVUkkocGF0aCk7XG4gICAgLy8gU3RlcCAzOiBNYW51YWxseSBlbmNvZGUgY2hhcmFjdGVycyB0aGF0IGFyZSBub3QgZW5jb2RlZCBieSBgZW5jb2RlVVJJYC5cbiAgICAvLyBUaGlzIGluY2x1ZGVzIGNoYXJhY3RlcnMgc3VjaCBhcyBcIiNcIiBhbmQgXCI/XCIsIHdoaWNoIGhhdmUgc3BlY2lhbCBtZWFuaW5nIGluIFVSTHMsXG4gICAgLy8gYnV0IGFyZSBqdXN0IG5vcm1hbCBjaGFyYWN0ZXJzIGluIGEgZmlsZXN5c3RlbSBwYXRoLlxuICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiB1cmxFbmNvZGVQYXR0ZXJucykge1xuICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKHBhdHRlcm5bMF0sIHBhdHRlcm5bMV0pO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbn1cbi8qKlxuICogQ29udmVydHMgYSBVUkwgdG8gYSBsb2NhbCBmaWxlc3lzdGVtIHBhdGguXG4gKi9cbmZ1bmN0aW9uIHRvRmlsZVN5c3RlbVBhdGgocGF0aCwga2VlcEZpbGVQcm90b2NvbCkge1xuICAgIC8vIFN0ZXAgMTogYGRlY29kZVVSSWAgd2lsbCBkZWNvZGUgY2hhcmFjdGVycyBzdWNoIGFzIEN5cmlsbGljIGNoYXJhY3RlcnMsIHNwYWNlcywgZXRjLlxuICAgIHBhdGggPSBkZWNvZGVVUkkocGF0aCk7XG4gICAgLy8gU3RlcCAyOiBNYW51YWxseSBkZWNvZGUgY2hhcmFjdGVycyB0aGF0IGFyZSBub3QgZGVjb2RlZCBieSBgZGVjb2RlVVJJYC5cbiAgICAvLyBUaGlzIGluY2x1ZGVzIGNoYXJhY3RlcnMgc3VjaCBhcyBcIiNcIiBhbmQgXCI/XCIsIHdoaWNoIGhhdmUgc3BlY2lhbCBtZWFuaW5nIGluIFVSTHMsXG4gICAgLy8gYnV0IGFyZSBqdXN0IG5vcm1hbCBjaGFyYWN0ZXJzIGluIGEgZmlsZXN5c3RlbSBwYXRoLlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdXJsRGVjb2RlUGF0dGVybnMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZSh1cmxEZWNvZGVQYXR0ZXJuc1tpXSwgdXJsRGVjb2RlUGF0dGVybnNbaSArIDFdKTtcbiAgICB9XG4gICAgLy8gU3RlcCAzOiBJZiBpdCdzIGEgXCJmaWxlOi8vXCIgVVJMLCB0aGVuIGZvcm1hdCBpdCBjb25zaXN0ZW50bHlcbiAgICAvLyBvciBjb252ZXJ0IGl0IHRvIGEgbG9jYWwgZmlsZXN5c3RlbSBwYXRoXG4gICAgbGV0IGlzRmlsZVVybCA9IHBhdGguc3Vic3RyKDAsIDcpLnRvTG93ZXJDYXNlKCkgPT09IFwiZmlsZTovL1wiO1xuICAgIGlmIChpc0ZpbGVVcmwpIHtcbiAgICAgICAgLy8gU3RyaXAtb2ZmIHRoZSBwcm90b2NvbCwgYW5kIHRoZSBpbml0aWFsIFwiL1wiLCBpZiB0aGVyZSBpcyBvbmVcbiAgICAgICAgcGF0aCA9IHBhdGhbN10gPT09IFwiL1wiID8gcGF0aC5zdWJzdHIoOCkgOiBwYXRoLnN1YnN0cig3KTtcbiAgICAgICAgLy8gaW5zZXJ0IGEgY29sb24gKFwiOlwiKSBhZnRlciB0aGUgZHJpdmUgbGV0dGVyIG9uIFdpbmRvd3NcbiAgICAgICAgaWYgKCgwLCBpc193aW5kb3dzXzEuaXNXaW5kb3dzKSgpICYmIHBhdGhbMV0gPT09IFwiL1wiKSB7XG4gICAgICAgICAgICBwYXRoID0gcGF0aFswXSArIFwiOlwiICsgcGF0aC5zdWJzdHIoMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtlZXBGaWxlUHJvdG9jb2wpIHtcbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgY29uc2lzdGVudGx5LWZvcm1hdHRlZCBcImZpbGU6Ly9cIiBVUkxcbiAgICAgICAgICAgIHBhdGggPSBcImZpbGU6Ly8vXCIgKyBwYXRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgXCJmaWxlOi8vXCIgVVJMIHRvIGEgbG9jYWwgZmlsZXN5c3RlbSBwYXRoLlxuICAgICAgICAgICAgLy8gT24gV2luZG93cywgaXQgd2lsbCBzdGFydCB3aXRoIHNvbWV0aGluZyBsaWtlIFwiQzovXCIuXG4gICAgICAgICAgICAvLyBPbiBQb3NpeCwgaXQgd2lsbCBzdGFydCB3aXRoIFwiL1wiXG4gICAgICAgICAgICBpc0ZpbGVVcmwgPSBmYWxzZTtcbiAgICAgICAgICAgIHBhdGggPSAoMCwgaXNfd2luZG93c18xLmlzV2luZG93cykoKSA/IHBhdGggOiBcIi9cIiArIHBhdGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gU3RlcCA0OiBOb3JtYWxpemUgV2luZG93cyBwYXRocyAodW5sZXNzIGl0J3MgYSBcImZpbGU6Ly9cIiBVUkwpXG4gICAgaWYgKCgwLCBpc193aW5kb3dzXzEuaXNXaW5kb3dzKSgpICYmICFpc0ZpbGVVcmwpIHtcbiAgICAgICAgLy8gUmVwbGFjZSBmb3J3YXJkIHNsYXNoZXMgd2l0aCBiYWNrc2xhc2hlc1xuICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKGZvcndhcmRTbGFzaFBhdHRlcm4sIFwiXFxcXFwiKTtcbiAgICAgICAgLy8gQ2FwaXRhbGl6ZSB0aGUgZHJpdmUgbGV0dGVyXG4gICAgICAgIGlmIChwYXRoLnN1YnN0cigxLCAyKSA9PT0gXCI6XFxcXFwiKSB7XG4gICAgICAgICAgICBwYXRoID0gcGF0aFswXS50b1VwcGVyQ2FzZSgpICsgcGF0aC5zdWJzdHIoMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhdGg7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgJHJlZiBwb2ludGVyIHRvIGEgdmFsaWQgSlNPTiBQYXRoLlxuICpcbiAqIEBwYXJhbSBwb2ludGVyXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBzYWZlUG9pbnRlclRvUGF0aChwb2ludGVyKSB7XG4gICAgaWYgKHBvaW50ZXIubGVuZ3RoIDw9IDEgfHwgcG9pbnRlclswXSAhPT0gXCIjXCIgfHwgcG9pbnRlclsxXSAhPT0gXCIvXCIpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gcG9pbnRlclxuICAgICAgICAuc2xpY2UoMilcbiAgICAgICAgLnNwbGl0KFwiL1wiKVxuICAgICAgICAubWFwKCh2YWx1ZSkgPT4ge1xuICAgICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKS5yZXBsYWNlKGpzb25Qb2ludGVyU2xhc2gsIFwiL1wiKS5yZXBsYWNlKGpzb25Qb2ludGVyVGlsZGUsIFwiflwiKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHJlbGF0aXZlKGZyb20sIHRvKSB7XG4gICAgaWYgKCFpc0ZpbGVTeXN0ZW1QYXRoKGZyb20pIHx8ICFpc0ZpbGVTeXN0ZW1QYXRoKHRvKSkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZShmcm9tLCB0byk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EaXIgPSBwYXRoXzEuZGVmYXVsdC5kaXJuYW1lKHN0cmlwSGFzaChmcm9tKSk7XG4gICAgY29uc3QgdG9QYXRoID0gc3RyaXBIYXNoKHRvKTtcbiAgICBjb25zdCByZXN1bHQgPSBwYXRoXzEuZGVmYXVsdC5yZWxhdGl2ZShmcm9tRGlyLCB0b1BhdGgpO1xuICAgIHJldHVybiByZXN1bHQgKyBnZXRIYXNoKHRvKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@apidevtools/json-schema-ref-parser/dist/lib/util/url.js\n");

/***/ })

};
;
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@vercel";
exports.ids = ["vendor-chunks/@vercel"];
exports.modules = {

/***/ "(rsc)/./node_modules/@vercel/edge-config/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@vercel/edge-config/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createClient: () => (/* binding */ createClient),\n/* harmony export */   digest: () => (/* binding */ digest),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   getAll: () => (/* binding */ getAll),\n/* harmony export */   has: () => (/* binding */ has),\n/* harmony export */   parseConnectionString: () => (/* binding */ parseConnectionString)\n/* harmony export */ });\n/* harmony import */ var _vercel_edge_config_fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @vercel/edge-config-fs */ \"node:fs/promises\");\n// src/index.ts\n\n\n// package.json\nvar name = \"@vercel/edge-config\";\nvar version = \"0.4.1\";\n\n// src/utils/index.ts\nvar ERRORS = {\n  UNEXPECTED: \"@vercel/edge-config: Unexpected error\",\n  UNAUTHORIZED: \"@vercel/edge-config: Unauthorized\",\n  NETWORK: \"@vercel/edge-config: Network error\",\n  EDGE_CONFIG_NOT_FOUND: \"@vercel/edge-config: Edge Config not found\"\n};\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\nfunction pick(obj, keys) {\n  const ret = {};\n  keys.forEach((key) => {\n    ret[key] = obj[key];\n  });\n  return ret;\n}\nfunction assertIsKey(key) {\n  if (typeof key !== \"string\") {\n    throw new Error(\"@vercel/edge-config: Expected key to be a string\");\n  }\n}\nfunction assertIsKeys(keys) {\n  if (!Array.isArray(keys) || keys.some((key) => typeof key !== \"string\")) {\n    throw new Error(\n      \"@vercel/edge-config: Expected keys to be an array of string\"\n    );\n  }\n}\nfunction clone(value) {\n  if (typeof structuredClone === \"function\")\n    return structuredClone(value);\n  if (value === void 0)\n    return value;\n  return JSON.parse(JSON.stringify(value));\n}\nfunction parseVercelConnectionString(text) {\n  try {\n    const url = new URL(text);\n    if (url.host !== \"edge-config.vercel.com\")\n      return null;\n    if (url.protocol !== \"https:\")\n      return null;\n    if (!url.pathname.startsWith(\"/ecfg\"))\n      return null;\n    const id = url.pathname.split(\"/\")[1];\n    if (!id)\n      return null;\n    const token = url.searchParams.get(\"token\");\n    if (!token || token === \"\")\n      return null;\n    return {\n      type: \"vercel\",\n      baseUrl: `https://edge-config.vercel.com/${id}`,\n      id,\n      version: \"1\",\n      token\n    };\n  } catch {\n    return null;\n  }\n}\nfunction parseExternalConnectionString(connectionString) {\n  try {\n    const url = new URL(connectionString);\n    let id = url.searchParams.get(\"id\");\n    const token = url.searchParams.get(\"token\");\n    const version2 = url.searchParams.get(\"version\") || \"1\";\n    if (!id || url.pathname.startsWith(\"/ecfg_\")) {\n      id = url.pathname.split(\"/\")[1] || null;\n    }\n    if (!id || !token)\n      return null;\n    url.search = \"\";\n    return {\n      type: \"external\",\n      baseUrl: url.toString(),\n      id,\n      token,\n      version: version2\n    };\n  } catch {\n    return null;\n  }\n}\nfunction parseConnectionString(connectionString) {\n  const connection = parseVercelConnectionString(connectionString);\n  if (connection)\n    return connection;\n  return parseExternalConnectionString(connectionString);\n}\nvar isDynamicServerError = (error) => error instanceof Error && hasOwnProperty(error, \"digest\") && error.digest === \"DYNAMIC_SERVER_USAGE\";\n\n// src/utils/fetch-with-cached-response.ts\nfunction createResponse(cachedResponseEntry) {\n  return new Response(cachedResponseEntry.response, {\n    headers: {\n      ...cachedResponseEntry.headers,\n      Age: String(\n        // age header may not be 0 when serving stale content, must be >= 1\n        Math.max(1, Math.floor((Date.now() - cachedResponseEntry.time) / 1e3))\n      )\n    },\n    status: cachedResponseEntry.status\n  });\n}\nfunction createHandleStaleIfError(cachedResponseEntry, staleIfError) {\n  return function handleStaleIfError(response) {\n    switch (response.status) {\n      case 500:\n      case 502:\n      case 503:\n      case 504:\n        return typeof staleIfError === \"number\" && cachedResponseEntry.time < Date.now() + staleIfError * 1e3 ? createResponse(cachedResponseEntry) : response;\n      default:\n        return response;\n    }\n  };\n}\nfunction createHandleStaleIfErrorException(cachedResponseEntry, staleIfError) {\n  return function handleStaleIfError(reason) {\n    if (typeof staleIfError === \"number\" && cachedResponseEntry.time < Date.now() + staleIfError * 1e3) {\n      return createResponse(cachedResponseEntry);\n    }\n    throw reason;\n  };\n}\nvar cache = /* @__PURE__ */ new Map();\nfunction extractStaleIfError(cacheControlHeader) {\n  if (!cacheControlHeader)\n    return null;\n  const matched = /stale-if-error=(?<staleIfError>\\d+)/i.exec(\n    cacheControlHeader\n  );\n  return (matched == null ? void 0 : matched.groups) ? Number(matched.groups.staleIfError) : null;\n}\nasync function fetchWithCachedResponse(url, options = {}) {\n  const { headers: customHeaders = new Headers(), ...customOptions } = options;\n  const authHeader = customHeaders.get(\"Authorization\");\n  const cacheKey = `${url},${authHeader || \"\"}`;\n  const cachedResponseEntry = cache.get(cacheKey);\n  if (cachedResponseEntry) {\n    const { etag: etag2, response: cachedResponse } = cachedResponseEntry;\n    const headers = new Headers(customHeaders);\n    headers.set(\"If-None-Match\", etag2);\n    const staleIfError = extractStaleIfError(headers.get(\"Cache-Control\"));\n    const res2 = await fetch(url, {\n      ...customOptions,\n      headers\n    }).then(\n      createHandleStaleIfError(cachedResponseEntry, staleIfError),\n      createHandleStaleIfErrorException(cachedResponseEntry, staleIfError)\n    );\n    if (res2.status === 304) {\n      res2.cachedResponseBody = JSON.parse(cachedResponse);\n      return res2;\n    }\n    const newETag = res2.headers.get(\"ETag\");\n    if (res2.ok && newETag)\n      cache.set(cacheKey, {\n        etag: newETag,\n        response: await res2.clone().text(),\n        headers: Object.fromEntries(res2.headers.entries()),\n        status: res2.status,\n        time: Date.now()\n      });\n    return res2;\n  }\n  const res = await fetch(url, options);\n  const etag = res.headers.get(\"ETag\");\n  if (res.ok && etag) {\n    cache.set(cacheKey, {\n      etag,\n      response: await res.clone().text(),\n      headers: Object.fromEntries(res.headers.entries()),\n      status: res.status,\n      time: Date.now()\n    });\n  }\n  return res;\n}\n\n// src/index.ts\nasync function getFileSystemEdgeConfig(connection) {\n  if (connection.type !== \"vercel\")\n    return null;\n  if (!process.env.AWS_LAMBDA_FUNCTION_NAME)\n    return null;\n  try {\n    const content = await (0,_vercel_edge_config_fs__WEBPACK_IMPORTED_MODULE_0__.readFile)(\n      `/opt/edge-config/${connection.id}.json`,\n      \"utf-8\"\n    );\n    return JSON.parse(content);\n  } catch {\n    return null;\n  }\n}\nasync function consumeResponseBodyInNodeJsRuntimeToPreventMemoryLeak(res) {\n  if (typeof EdgeRuntime !== \"undefined\")\n    return;\n  await res.arrayBuffer();\n}\nfunction createClient(connectionString, options = {\n  staleIfError: 604800\n  /* one week */\n}) {\n  if (!connectionString)\n    throw new Error(\"@vercel/edge-config: No connection string provided\");\n  const connection = parseConnectionString(connectionString);\n  if (!connection)\n    throw new Error(\"@vercel/edge-config: Invalid connection string provided\");\n  const baseUrl = connection.baseUrl;\n  const version2 = connection.version;\n  const headers = {\n    Authorization: `Bearer ${connection.token}`\n  };\n  if (typeof process !== \"undefined\" && process.env.VERCEL_ENV)\n    headers[\"x-edge-config-vercel-env\"] = process.env.VERCEL_ENV;\n  if (typeof name === \"string\" && typeof version === \"string\")\n    headers[\"x-edge-config-sdk\"] = `${name}@${version}`;\n  if (typeof options.staleIfError === \"number\" && options.staleIfError > 0)\n    headers[\"cache-control\"] = `stale-if-error=${options.staleIfError}`;\n  return {\n    connection,\n    async get(key) {\n      const localEdgeConfig = await getFileSystemEdgeConfig(connection);\n      if (localEdgeConfig) {\n        assertIsKey(key);\n        return Promise.resolve(clone(localEdgeConfig.items[key]));\n      }\n      assertIsKey(key);\n      return fetchWithCachedResponse(\n        `${baseUrl}/item/${key}?version=${version2}`,\n        {\n          headers: new Headers(headers),\n          cache: \"no-store\"\n        }\n      ).then(\n        async (res) => {\n          if (res.ok)\n            return res.json();\n          await consumeResponseBodyInNodeJsRuntimeToPreventMemoryLeak(res);\n          if (res.status === 401)\n            throw new Error(ERRORS.UNAUTHORIZED);\n          if (res.status === 404) {\n            if (res.headers.has(\"x-edge-config-digest\"))\n              return void 0;\n            throw new Error(ERRORS.EDGE_CONFIG_NOT_FOUND);\n          }\n          if (res.cachedResponseBody !== void 0)\n            return res.cachedResponseBody;\n          throw new Error(ERRORS.UNEXPECTED);\n        },\n        (error) => {\n          if (isDynamicServerError(error))\n            throw error;\n          throw new Error(ERRORS.NETWORK);\n        }\n      );\n    },\n    async has(key) {\n      const localEdgeConfig = await getFileSystemEdgeConfig(connection);\n      if (localEdgeConfig) {\n        assertIsKey(key);\n        return Promise.resolve(hasOwnProperty(localEdgeConfig.items, key));\n      }\n      assertIsKey(key);\n      return fetch(`${baseUrl}/item/${key}?version=${version2}`, {\n        method: \"HEAD\",\n        headers: new Headers(headers),\n        cache: \"no-store\"\n      }).then(\n        (res) => {\n          if (res.status === 401)\n            throw new Error(ERRORS.UNAUTHORIZED);\n          if (res.status === 404) {\n            if (res.headers.has(\"x-edge-config-digest\"))\n              return false;\n            throw new Error(ERRORS.EDGE_CONFIG_NOT_FOUND);\n          }\n          if (res.ok)\n            return true;\n          throw new Error(ERRORS.UNEXPECTED);\n        },\n        (error) => {\n          if (isDynamicServerError(error))\n            throw error;\n          throw new Error(ERRORS.NETWORK);\n        }\n      );\n    },\n    async getAll(keys) {\n      const localEdgeConfig = await getFileSystemEdgeConfig(connection);\n      if (localEdgeConfig) {\n        if (keys === void 0) {\n          return Promise.resolve(clone(localEdgeConfig.items));\n        }\n        assertIsKeys(keys);\n        return Promise.resolve(clone(pick(localEdgeConfig.items, keys)));\n      }\n      if (Array.isArray(keys))\n        assertIsKeys(keys);\n      const search = Array.isArray(keys) ? new URLSearchParams(\n        keys.map((key) => [\"key\", key])\n      ).toString() : null;\n      if (search === \"\")\n        return Promise.resolve({});\n      return fetchWithCachedResponse(\n        `${baseUrl}/items?version=${version2}${search === null ? \"\" : `&${search}`}`,\n        {\n          headers: new Headers(headers),\n          cache: \"no-store\"\n        }\n      ).then(\n        async (res) => {\n          if (res.ok)\n            return res.json();\n          await consumeResponseBodyInNodeJsRuntimeToPreventMemoryLeak(res);\n          if (res.status === 401)\n            throw new Error(ERRORS.UNAUTHORIZED);\n          if (res.status === 404)\n            throw new Error(ERRORS.EDGE_CONFIG_NOT_FOUND);\n          if (res.cachedResponseBody !== void 0)\n            return res.cachedResponseBody;\n          throw new Error(ERRORS.UNEXPECTED);\n        },\n        (error) => {\n          if (isDynamicServerError(error))\n            throw error;\n          throw new Error(ERRORS.NETWORK);\n        }\n      );\n    },\n    async digest() {\n      const localEdgeConfig = await getFileSystemEdgeConfig(connection);\n      if (localEdgeConfig) {\n        return Promise.resolve(localEdgeConfig.digest);\n      }\n      return fetchWithCachedResponse(`${baseUrl}/digest?version=${version2}`, {\n        headers: new Headers(headers),\n        cache: \"no-store\"\n      }).then(\n        async (res) => {\n          if (res.ok)\n            return res.json();\n          await consumeResponseBodyInNodeJsRuntimeToPreventMemoryLeak(res);\n          if (res.cachedResponseBody !== void 0)\n            return res.cachedResponseBody;\n          throw new Error(ERRORS.UNEXPECTED);\n        },\n        (error) => {\n          if (isDynamicServerError(error))\n            throw error;\n          throw new Error(ERRORS.NETWORK);\n        }\n      );\n    }\n  };\n}\nvar defaultEdgeConfigClient;\nfunction init() {\n  if (!defaultEdgeConfigClient) {\n    defaultEdgeConfigClient = createClient(process.env.EDGE_CONFIG);\n  }\n}\nvar get = (...args) => {\n  init();\n  return defaultEdgeConfigClient.get(...args);\n};\nvar getAll = (...args) => {\n  init();\n  return defaultEdgeConfigClient.getAll(...args);\n};\nvar has = (...args) => {\n  init();\n  return defaultEdgeConfigClient.has(...args);\n};\nvar digest = (...args) => {\n  init();\n  return defaultEdgeConfigClient.digest(...args);\n};\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQHZlcmNlbC9lZGdlLWNvbmZpZy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNrRDs7QUFFbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxHQUFHO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RCxVQUFVLDJEQUEyRDtBQUNyRTtBQUNBLHNCQUFzQixJQUFJLEdBQUcsaUJBQWlCO0FBQzlDO0FBQ0E7QUFDQSxZQUFZLHdDQUF3QztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdFQUFRO0FBQ2xDLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsaUJBQWlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLEtBQUssR0FBRyxRQUFRO0FBQ3REO0FBQ0EsaURBQWlELHFCQUFxQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUSxRQUFRLElBQUksV0FBVyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRLFFBQVEsSUFBSSxXQUFXLFNBQVM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLFdBQVcsUUFBUSxpQkFBaUIsU0FBUyxFQUFFLDJCQUEyQixPQUFPLEVBQUU7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUSxrQkFBa0IsU0FBUztBQUMzRTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2NoYXRib3QtdWkvLi9ub2RlX21vZHVsZXMvQHZlcmNlbC9lZGdlLWNvbmZpZy9kaXN0L2luZGV4LmpzP2E0NzYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2luZGV4LnRzXG5pbXBvcnQgeyByZWFkRmlsZSB9IGZyb20gXCJAdmVyY2VsL2VkZ2UtY29uZmlnLWZzXCI7XG5cbi8vIHBhY2thZ2UuanNvblxudmFyIG5hbWUgPSBcIkB2ZXJjZWwvZWRnZS1jb25maWdcIjtcbnZhciB2ZXJzaW9uID0gXCIwLjQuMVwiO1xuXG4vLyBzcmMvdXRpbHMvaW5kZXgudHNcbnZhciBFUlJPUlMgPSB7XG4gIFVORVhQRUNURUQ6IFwiQHZlcmNlbC9lZGdlLWNvbmZpZzogVW5leHBlY3RlZCBlcnJvclwiLFxuICBVTkFVVEhPUklaRUQ6IFwiQHZlcmNlbC9lZGdlLWNvbmZpZzogVW5hdXRob3JpemVkXCIsXG4gIE5FVFdPUks6IFwiQHZlcmNlbC9lZGdlLWNvbmZpZzogTmV0d29yayBlcnJvclwiLFxuICBFREdFX0NPTkZJR19OT1RfRk9VTkQ6IFwiQHZlcmNlbC9lZGdlLWNvbmZpZzogRWRnZSBDb25maWcgbm90IGZvdW5kXCJcbn07XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuZnVuY3Rpb24gcGljayhvYmosIGtleXMpIHtcbiAgY29uc3QgcmV0ID0ge307XG4gIGtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgcmV0W2tleV0gPSBvYmpba2V5XTtcbiAgfSk7XG4gIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBhc3NlcnRJc0tleShrZXkpIHtcbiAgaWYgKHR5cGVvZiBrZXkgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJAdmVyY2VsL2VkZ2UtY29uZmlnOiBFeHBlY3RlZCBrZXkgdG8gYmUgYSBzdHJpbmdcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGFzc2VydElzS2V5cyhrZXlzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShrZXlzKSB8fCBrZXlzLnNvbWUoKGtleSkgPT4gdHlwZW9mIGtleSAhPT0gXCJzdHJpbmdcIikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkB2ZXJjZWwvZWRnZS1jb25maWc6IEV4cGVjdGVkIGtleXMgdG8gYmUgYW4gYXJyYXkgb2Ygc3RyaW5nXCJcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBjbG9uZSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHN0cnVjdHVyZWRDbG9uZSA9PT0gXCJmdW5jdGlvblwiKVxuICAgIHJldHVybiBzdHJ1Y3R1cmVkQ2xvbmUodmFsdWUpO1xuICBpZiAodmFsdWUgPT09IHZvaWQgMClcbiAgICByZXR1cm4gdmFsdWU7XG4gIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG59XG5mdW5jdGlvbiBwYXJzZVZlcmNlbENvbm5lY3Rpb25TdHJpbmcodGV4dCkge1xuICB0cnkge1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwodGV4dCk7XG4gICAgaWYgKHVybC5ob3N0ICE9PSBcImVkZ2UtY29uZmlnLnZlcmNlbC5jb21cIilcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGlmICh1cmwucHJvdG9jb2wgIT09IFwiaHR0cHM6XCIpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAoIXVybC5wYXRobmFtZS5zdGFydHNXaXRoKFwiL2VjZmdcIikpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBpZCA9IHVybC5wYXRobmFtZS5zcGxpdChcIi9cIilbMV07XG4gICAgaWYgKCFpZClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHRva2VuID0gdXJsLnNlYXJjaFBhcmFtcy5nZXQoXCJ0b2tlblwiKTtcbiAgICBpZiAoIXRva2VuIHx8IHRva2VuID09PSBcIlwiKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidmVyY2VsXCIsXG4gICAgICBiYXNlVXJsOiBgaHR0cHM6Ly9lZGdlLWNvbmZpZy52ZXJjZWwuY29tLyR7aWR9YCxcbiAgICAgIGlkLFxuICAgICAgdmVyc2lvbjogXCIxXCIsXG4gICAgICB0b2tlblxuICAgIH07XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZUV4dGVybmFsQ29ubmVjdGlvblN0cmluZyhjb25uZWN0aW9uU3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChjb25uZWN0aW9uU3RyaW5nKTtcbiAgICBsZXQgaWQgPSB1cmwuc2VhcmNoUGFyYW1zLmdldChcImlkXCIpO1xuICAgIGNvbnN0IHRva2VuID0gdXJsLnNlYXJjaFBhcmFtcy5nZXQoXCJ0b2tlblwiKTtcbiAgICBjb25zdCB2ZXJzaW9uMiA9IHVybC5zZWFyY2hQYXJhbXMuZ2V0KFwidmVyc2lvblwiKSB8fCBcIjFcIjtcbiAgICBpZiAoIWlkIHx8IHVybC5wYXRobmFtZS5zdGFydHNXaXRoKFwiL2VjZmdfXCIpKSB7XG4gICAgICBpZCA9IHVybC5wYXRobmFtZS5zcGxpdChcIi9cIilbMV0gfHwgbnVsbDtcbiAgICB9XG4gICAgaWYgKCFpZCB8fCAhdG9rZW4pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB1cmwuc2VhcmNoID0gXCJcIjtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJleHRlcm5hbFwiLFxuICAgICAgYmFzZVVybDogdXJsLnRvU3RyaW5nKCksXG4gICAgICBpZCxcbiAgICAgIHRva2VuLFxuICAgICAgdmVyc2lvbjogdmVyc2lvbjJcbiAgICB9O1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VDb25uZWN0aW9uU3RyaW5nKGNvbm5lY3Rpb25TdHJpbmcpIHtcbiAgY29uc3QgY29ubmVjdGlvbiA9IHBhcnNlVmVyY2VsQ29ubmVjdGlvblN0cmluZyhjb25uZWN0aW9uU3RyaW5nKTtcbiAgaWYgKGNvbm5lY3Rpb24pXG4gICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gIHJldHVybiBwYXJzZUV4dGVybmFsQ29ubmVjdGlvblN0cmluZyhjb25uZWN0aW9uU3RyaW5nKTtcbn1cbnZhciBpc0R5bmFtaWNTZXJ2ZXJFcnJvciA9IChlcnJvcikgPT4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBoYXNPd25Qcm9wZXJ0eShlcnJvciwgXCJkaWdlc3RcIikgJiYgZXJyb3IuZGlnZXN0ID09PSBcIkRZTkFNSUNfU0VSVkVSX1VTQUdFXCI7XG5cbi8vIHNyYy91dGlscy9mZXRjaC13aXRoLWNhY2hlZC1yZXNwb25zZS50c1xuZnVuY3Rpb24gY3JlYXRlUmVzcG9uc2UoY2FjaGVkUmVzcG9uc2VFbnRyeSkge1xuICByZXR1cm4gbmV3IFJlc3BvbnNlKGNhY2hlZFJlc3BvbnNlRW50cnkucmVzcG9uc2UsIHtcbiAgICBoZWFkZXJzOiB7XG4gICAgICAuLi5jYWNoZWRSZXNwb25zZUVudHJ5LmhlYWRlcnMsXG4gICAgICBBZ2U6IFN0cmluZyhcbiAgICAgICAgLy8gYWdlIGhlYWRlciBtYXkgbm90IGJlIDAgd2hlbiBzZXJ2aW5nIHN0YWxlIGNvbnRlbnQsIG11c3QgYmUgPj0gMVxuICAgICAgICBNYXRoLm1heCgxLCBNYXRoLmZsb29yKChEYXRlLm5vdygpIC0gY2FjaGVkUmVzcG9uc2VFbnRyeS50aW1lKSAvIDFlMykpXG4gICAgICApXG4gICAgfSxcbiAgICBzdGF0dXM6IGNhY2hlZFJlc3BvbnNlRW50cnkuc3RhdHVzXG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlSGFuZGxlU3RhbGVJZkVycm9yKGNhY2hlZFJlc3BvbnNlRW50cnksIHN0YWxlSWZFcnJvcikge1xuICByZXR1cm4gZnVuY3Rpb24gaGFuZGxlU3RhbGVJZkVycm9yKHJlc3BvbnNlKSB7XG4gICAgc3dpdGNoIChyZXNwb25zZS5zdGF0dXMpIHtcbiAgICAgIGNhc2UgNTAwOlxuICAgICAgY2FzZSA1MDI6XG4gICAgICBjYXNlIDUwMzpcbiAgICAgIGNhc2UgNTA0OlxuICAgICAgICByZXR1cm4gdHlwZW9mIHN0YWxlSWZFcnJvciA9PT0gXCJudW1iZXJcIiAmJiBjYWNoZWRSZXNwb25zZUVudHJ5LnRpbWUgPCBEYXRlLm5vdygpICsgc3RhbGVJZkVycm9yICogMWUzID8gY3JlYXRlUmVzcG9uc2UoY2FjaGVkUmVzcG9uc2VFbnRyeSkgOiByZXNwb25zZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVIYW5kbGVTdGFsZUlmRXJyb3JFeGNlcHRpb24oY2FjaGVkUmVzcG9uc2VFbnRyeSwgc3RhbGVJZkVycm9yKSB7XG4gIHJldHVybiBmdW5jdGlvbiBoYW5kbGVTdGFsZUlmRXJyb3IocmVhc29uKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFsZUlmRXJyb3IgPT09IFwibnVtYmVyXCIgJiYgY2FjaGVkUmVzcG9uc2VFbnRyeS50aW1lIDwgRGF0ZS5ub3coKSArIHN0YWxlSWZFcnJvciAqIDFlMykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVJlc3BvbnNlKGNhY2hlZFJlc3BvbnNlRW50cnkpO1xuICAgIH1cbiAgICB0aHJvdyByZWFzb247XG4gIH07XG59XG52YXIgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuZnVuY3Rpb24gZXh0cmFjdFN0YWxlSWZFcnJvcihjYWNoZUNvbnRyb2xIZWFkZXIpIHtcbiAgaWYgKCFjYWNoZUNvbnRyb2xIZWFkZXIpXG4gICAgcmV0dXJuIG51bGw7XG4gIGNvbnN0IG1hdGNoZWQgPSAvc3RhbGUtaWYtZXJyb3I9KD88c3RhbGVJZkVycm9yPlxcZCspL2kuZXhlYyhcbiAgICBjYWNoZUNvbnRyb2xIZWFkZXJcbiAgKTtcbiAgcmV0dXJuIChtYXRjaGVkID09IG51bGwgPyB2b2lkIDAgOiBtYXRjaGVkLmdyb3VwcykgPyBOdW1iZXIobWF0Y2hlZC5ncm91cHMuc3RhbGVJZkVycm9yKSA6IG51bGw7XG59XG5hc3luYyBmdW5jdGlvbiBmZXRjaFdpdGhDYWNoZWRSZXNwb25zZSh1cmwsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IGhlYWRlcnM6IGN1c3RvbUhlYWRlcnMgPSBuZXcgSGVhZGVycygpLCAuLi5jdXN0b21PcHRpb25zIH0gPSBvcHRpb25zO1xuICBjb25zdCBhdXRoSGVhZGVyID0gY3VzdG9tSGVhZGVycy5nZXQoXCJBdXRob3JpemF0aW9uXCIpO1xuICBjb25zdCBjYWNoZUtleSA9IGAke3VybH0sJHthdXRoSGVhZGVyIHx8IFwiXCJ9YDtcbiAgY29uc3QgY2FjaGVkUmVzcG9uc2VFbnRyeSA9IGNhY2hlLmdldChjYWNoZUtleSk7XG4gIGlmIChjYWNoZWRSZXNwb25zZUVudHJ5KSB7XG4gICAgY29uc3QgeyBldGFnOiBldGFnMiwgcmVzcG9uc2U6IGNhY2hlZFJlc3BvbnNlIH0gPSBjYWNoZWRSZXNwb25zZUVudHJ5O1xuICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycyhjdXN0b21IZWFkZXJzKTtcbiAgICBoZWFkZXJzLnNldChcIklmLU5vbmUtTWF0Y2hcIiwgZXRhZzIpO1xuICAgIGNvbnN0IHN0YWxlSWZFcnJvciA9IGV4dHJhY3RTdGFsZUlmRXJyb3IoaGVhZGVycy5nZXQoXCJDYWNoZS1Db250cm9sXCIpKTtcbiAgICBjb25zdCByZXMyID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgICAuLi5jdXN0b21PcHRpb25zLFxuICAgICAgaGVhZGVyc1xuICAgIH0pLnRoZW4oXG4gICAgICBjcmVhdGVIYW5kbGVTdGFsZUlmRXJyb3IoY2FjaGVkUmVzcG9uc2VFbnRyeSwgc3RhbGVJZkVycm9yKSxcbiAgICAgIGNyZWF0ZUhhbmRsZVN0YWxlSWZFcnJvckV4Y2VwdGlvbihjYWNoZWRSZXNwb25zZUVudHJ5LCBzdGFsZUlmRXJyb3IpXG4gICAgKTtcbiAgICBpZiAocmVzMi5zdGF0dXMgPT09IDMwNCkge1xuICAgICAgcmVzMi5jYWNoZWRSZXNwb25zZUJvZHkgPSBKU09OLnBhcnNlKGNhY2hlZFJlc3BvbnNlKTtcbiAgICAgIHJldHVybiByZXMyO1xuICAgIH1cbiAgICBjb25zdCBuZXdFVGFnID0gcmVzMi5oZWFkZXJzLmdldChcIkVUYWdcIik7XG4gICAgaWYgKHJlczIub2sgJiYgbmV3RVRhZylcbiAgICAgIGNhY2hlLnNldChjYWNoZUtleSwge1xuICAgICAgICBldGFnOiBuZXdFVGFnLFxuICAgICAgICByZXNwb25zZTogYXdhaXQgcmVzMi5jbG9uZSgpLnRleHQoKSxcbiAgICAgICAgaGVhZGVyczogT2JqZWN0LmZyb21FbnRyaWVzKHJlczIuaGVhZGVycy5lbnRyaWVzKCkpLFxuICAgICAgICBzdGF0dXM6IHJlczIuc3RhdHVzLFxuICAgICAgICB0aW1lOiBEYXRlLm5vdygpXG4gICAgICB9KTtcbiAgICByZXR1cm4gcmVzMjtcbiAgfVxuICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaCh1cmwsIG9wdGlvbnMpO1xuICBjb25zdCBldGFnID0gcmVzLmhlYWRlcnMuZ2V0KFwiRVRhZ1wiKTtcbiAgaWYgKHJlcy5vayAmJiBldGFnKSB7XG4gICAgY2FjaGUuc2V0KGNhY2hlS2V5LCB7XG4gICAgICBldGFnLFxuICAgICAgcmVzcG9uc2U6IGF3YWl0IHJlcy5jbG9uZSgpLnRleHQoKSxcbiAgICAgIGhlYWRlcnM6IE9iamVjdC5mcm9tRW50cmllcyhyZXMuaGVhZGVycy5lbnRyaWVzKCkpLFxuICAgICAgc3RhdHVzOiByZXMuc3RhdHVzLFxuICAgICAgdGltZTogRGF0ZS5ub3coKVxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbi8vIHNyYy9pbmRleC50c1xuYXN5bmMgZnVuY3Rpb24gZ2V0RmlsZVN5c3RlbUVkZ2VDb25maWcoY29ubmVjdGlvbikge1xuICBpZiAoY29ubmVjdGlvbi50eXBlICE9PSBcInZlcmNlbFwiKVxuICAgIHJldHVybiBudWxsO1xuICBpZiAoIXByb2Nlc3MuZW52LkFXU19MQU1CREFfRlVOQ1RJT05fTkFNRSlcbiAgICByZXR1cm4gbnVsbDtcbiAgdHJ5IHtcbiAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgcmVhZEZpbGUoXG4gICAgICBgL29wdC9lZGdlLWNvbmZpZy8ke2Nvbm5lY3Rpb24uaWR9Lmpzb25gLFxuICAgICAgXCJ1dGYtOFwiXG4gICAgKTtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShjb250ZW50KTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGNvbnN1bWVSZXNwb25zZUJvZHlJbk5vZGVKc1J1bnRpbWVUb1ByZXZlbnRNZW1vcnlMZWFrKHJlcykge1xuICBpZiAodHlwZW9mIEVkZ2VSdW50aW1lICE9PSBcInVuZGVmaW5lZFwiKVxuICAgIHJldHVybjtcbiAgYXdhaXQgcmVzLmFycmF5QnVmZmVyKCk7XG59XG5mdW5jdGlvbiBjcmVhdGVDbGllbnQoY29ubmVjdGlvblN0cmluZywgb3B0aW9ucyA9IHtcbiAgc3RhbGVJZkVycm9yOiA2MDQ4MDBcbiAgLyogb25lIHdlZWsgKi9cbn0pIHtcbiAgaWYgKCFjb25uZWN0aW9uU3RyaW5nKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkB2ZXJjZWwvZWRnZS1jb25maWc6IE5vIGNvbm5lY3Rpb24gc3RyaW5nIHByb3ZpZGVkXCIpO1xuICBjb25zdCBjb25uZWN0aW9uID0gcGFyc2VDb25uZWN0aW9uU3RyaW5nKGNvbm5lY3Rpb25TdHJpbmcpO1xuICBpZiAoIWNvbm5lY3Rpb24pXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQHZlcmNlbC9lZGdlLWNvbmZpZzogSW52YWxpZCBjb25uZWN0aW9uIHN0cmluZyBwcm92aWRlZFwiKTtcbiAgY29uc3QgYmFzZVVybCA9IGNvbm5lY3Rpb24uYmFzZVVybDtcbiAgY29uc3QgdmVyc2lvbjIgPSBjb25uZWN0aW9uLnZlcnNpb247XG4gIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2Nvbm5lY3Rpb24udG9rZW59YFxuICB9O1xuICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2Vzcy5lbnYuVkVSQ0VMX0VOVilcbiAgICBoZWFkZXJzW1wieC1lZGdlLWNvbmZpZy12ZXJjZWwtZW52XCJdID0gcHJvY2Vzcy5lbnYuVkVSQ0VMX0VOVjtcbiAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiB2ZXJzaW9uID09PSBcInN0cmluZ1wiKVxuICAgIGhlYWRlcnNbXCJ4LWVkZ2UtY29uZmlnLXNka1wiXSA9IGAke25hbWV9QCR7dmVyc2lvbn1gO1xuICBpZiAodHlwZW9mIG9wdGlvbnMuc3RhbGVJZkVycm9yID09PSBcIm51bWJlclwiICYmIG9wdGlvbnMuc3RhbGVJZkVycm9yID4gMClcbiAgICBoZWFkZXJzW1wiY2FjaGUtY29udHJvbFwiXSA9IGBzdGFsZS1pZi1lcnJvcj0ke29wdGlvbnMuc3RhbGVJZkVycm9yfWA7XG4gIHJldHVybiB7XG4gICAgY29ubmVjdGlvbixcbiAgICBhc3luYyBnZXQoa2V5KSB7XG4gICAgICBjb25zdCBsb2NhbEVkZ2VDb25maWcgPSBhd2FpdCBnZXRGaWxlU3lzdGVtRWRnZUNvbmZpZyhjb25uZWN0aW9uKTtcbiAgICAgIGlmIChsb2NhbEVkZ2VDb25maWcpIHtcbiAgICAgICAgYXNzZXJ0SXNLZXkoa2V5KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjbG9uZShsb2NhbEVkZ2VDb25maWcuaXRlbXNba2V5XSkpO1xuICAgICAgfVxuICAgICAgYXNzZXJ0SXNLZXkoa2V5KTtcbiAgICAgIHJldHVybiBmZXRjaFdpdGhDYWNoZWRSZXNwb25zZShcbiAgICAgICAgYCR7YmFzZVVybH0vaXRlbS8ke2tleX0/dmVyc2lvbj0ke3ZlcnNpb24yfWAsXG4gICAgICAgIHtcbiAgICAgICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyhoZWFkZXJzKSxcbiAgICAgICAgICBjYWNoZTogXCJuby1zdG9yZVwiXG4gICAgICAgIH1cbiAgICAgICkudGhlbihcbiAgICAgICAgYXN5bmMgKHJlcykgPT4ge1xuICAgICAgICAgIGlmIChyZXMub2spXG4gICAgICAgICAgICByZXR1cm4gcmVzLmpzb24oKTtcbiAgICAgICAgICBhd2FpdCBjb25zdW1lUmVzcG9uc2VCb2R5SW5Ob2RlSnNSdW50aW1lVG9QcmV2ZW50TWVtb3J5TGVhayhyZXMpO1xuICAgICAgICAgIGlmIChyZXMuc3RhdHVzID09PSA0MDEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1JTLlVOQVVUSE9SSVpFRCk7XG4gICAgICAgICAgaWYgKHJlcy5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgICAgaWYgKHJlcy5oZWFkZXJzLmhhcyhcIngtZWRnZS1jb25maWctZGlnZXN0XCIpKVxuICAgICAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SUy5FREdFX0NPTkZJR19OT1RfRk9VTkQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzLmNhY2hlZFJlc3BvbnNlQm9keSAhPT0gdm9pZCAwKVxuICAgICAgICAgICAgcmV0dXJuIHJlcy5jYWNoZWRSZXNwb25zZUJvZHk7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SUy5VTkVYUEVDVEVEKTtcbiAgICAgICAgfSxcbiAgICAgICAgKGVycm9yKSA9PiB7XG4gICAgICAgICAgaWYgKGlzRHluYW1pY1NlcnZlckVycm9yKGVycm9yKSlcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUlMuTkVUV09SSyk7XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSxcbiAgICBhc3luYyBoYXMoa2V5KSB7XG4gICAgICBjb25zdCBsb2NhbEVkZ2VDb25maWcgPSBhd2FpdCBnZXRGaWxlU3lzdGVtRWRnZUNvbmZpZyhjb25uZWN0aW9uKTtcbiAgICAgIGlmIChsb2NhbEVkZ2VDb25maWcpIHtcbiAgICAgICAgYXNzZXJ0SXNLZXkoa2V5KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShoYXNPd25Qcm9wZXJ0eShsb2NhbEVkZ2VDb25maWcuaXRlbXMsIGtleSkpO1xuICAgICAgfVxuICAgICAgYXNzZXJ0SXNLZXkoa2V5KTtcbiAgICAgIHJldHVybiBmZXRjaChgJHtiYXNlVXJsfS9pdGVtLyR7a2V5fT92ZXJzaW9uPSR7dmVyc2lvbjJ9YCwge1xuICAgICAgICBtZXRob2Q6IFwiSEVBRFwiLFxuICAgICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyhoZWFkZXJzKSxcbiAgICAgICAgY2FjaGU6IFwibm8tc3RvcmVcIlxuICAgICAgfSkudGhlbihcbiAgICAgICAgKHJlcykgPT4ge1xuICAgICAgICAgIGlmIChyZXMuc3RhdHVzID09PSA0MDEpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1JTLlVOQVVUSE9SSVpFRCk7XG4gICAgICAgICAgaWYgKHJlcy5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgICAgaWYgKHJlcy5oZWFkZXJzLmhhcyhcIngtZWRnZS1jb25maWctZGlnZXN0XCIpKVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1JTLkVER0VfQ09ORklHX05PVF9GT1VORCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXMub2spXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1JTLlVORVhQRUNURUQpO1xuICAgICAgICB9LFxuICAgICAgICAoZXJyb3IpID0+IHtcbiAgICAgICAgICBpZiAoaXNEeW5hbWljU2VydmVyRXJyb3IoZXJyb3IpKVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SUy5ORVRXT1JLKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9LFxuICAgIGFzeW5jIGdldEFsbChrZXlzKSB7XG4gICAgICBjb25zdCBsb2NhbEVkZ2VDb25maWcgPSBhd2FpdCBnZXRGaWxlU3lzdGVtRWRnZUNvbmZpZyhjb25uZWN0aW9uKTtcbiAgICAgIGlmIChsb2NhbEVkZ2VDb25maWcpIHtcbiAgICAgICAgaWYgKGtleXMgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY2xvbmUobG9jYWxFZGdlQ29uZmlnLml0ZW1zKSk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0SXNLZXlzKGtleXMpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNsb25lKHBpY2sobG9jYWxFZGdlQ29uZmlnLml0ZW1zLCBrZXlzKSkpO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoa2V5cykpXG4gICAgICAgIGFzc2VydElzS2V5cyhrZXlzKTtcbiAgICAgIGNvbnN0IHNlYXJjaCA9IEFycmF5LmlzQXJyYXkoa2V5cykgPyBuZXcgVVJMU2VhcmNoUGFyYW1zKFxuICAgICAgICBrZXlzLm1hcCgoa2V5KSA9PiBbXCJrZXlcIiwga2V5XSlcbiAgICAgICkudG9TdHJpbmcoKSA6IG51bGw7XG4gICAgICBpZiAoc2VhcmNoID09PSBcIlwiKVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHt9KTtcbiAgICAgIHJldHVybiBmZXRjaFdpdGhDYWNoZWRSZXNwb25zZShcbiAgICAgICAgYCR7YmFzZVVybH0vaXRlbXM/dmVyc2lvbj0ke3ZlcnNpb24yfSR7c2VhcmNoID09PSBudWxsID8gXCJcIiA6IGAmJHtzZWFyY2h9YH1gLFxuICAgICAgICB7XG4gICAgICAgICAgaGVhZGVyczogbmV3IEhlYWRlcnMoaGVhZGVycyksXG4gICAgICAgICAgY2FjaGU6IFwibm8tc3RvcmVcIlxuICAgICAgICB9XG4gICAgICApLnRoZW4oXG4gICAgICAgIGFzeW5jIChyZXMpID0+IHtcbiAgICAgICAgICBpZiAocmVzLm9rKVxuICAgICAgICAgICAgcmV0dXJuIHJlcy5qc29uKCk7XG4gICAgICAgICAgYXdhaXQgY29uc3VtZVJlc3BvbnNlQm9keUluTm9kZUpzUnVudGltZVRvUHJldmVudE1lbW9yeUxlYWsocmVzKTtcbiAgICAgICAgICBpZiAocmVzLnN0YXR1cyA9PT0gNDAxKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKEVSUk9SUy5VTkFVVEhPUklaRUQpO1xuICAgICAgICAgIGlmIChyZXMuc3RhdHVzID09PSA0MDQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1JTLkVER0VfQ09ORklHX05PVF9GT1VORCk7XG4gICAgICAgICAgaWYgKHJlcy5jYWNoZWRSZXNwb25zZUJvZHkgIT09IHZvaWQgMClcbiAgICAgICAgICAgIHJldHVybiByZXMuY2FjaGVkUmVzcG9uc2VCb2R5O1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUlMuVU5FWFBFQ1RFRCk7XG4gICAgICAgIH0sXG4gICAgICAgIChlcnJvcikgPT4ge1xuICAgICAgICAgIGlmIChpc0R5bmFtaWNTZXJ2ZXJFcnJvcihlcnJvcikpXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1JTLk5FVFdPUkspO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH0sXG4gICAgYXN5bmMgZGlnZXN0KCkge1xuICAgICAgY29uc3QgbG9jYWxFZGdlQ29uZmlnID0gYXdhaXQgZ2V0RmlsZVN5c3RlbUVkZ2VDb25maWcoY29ubmVjdGlvbik7XG4gICAgICBpZiAobG9jYWxFZGdlQ29uZmlnKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobG9jYWxFZGdlQ29uZmlnLmRpZ2VzdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmV0Y2hXaXRoQ2FjaGVkUmVzcG9uc2UoYCR7YmFzZVVybH0vZGlnZXN0P3ZlcnNpb249JHt2ZXJzaW9uMn1gLCB7XG4gICAgICAgIGhlYWRlcnM6IG5ldyBIZWFkZXJzKGhlYWRlcnMpLFxuICAgICAgICBjYWNoZTogXCJuby1zdG9yZVwiXG4gICAgICB9KS50aGVuKFxuICAgICAgICBhc3luYyAocmVzKSA9PiB7XG4gICAgICAgICAgaWYgKHJlcy5vaylcbiAgICAgICAgICAgIHJldHVybiByZXMuanNvbigpO1xuICAgICAgICAgIGF3YWl0IGNvbnN1bWVSZXNwb25zZUJvZHlJbk5vZGVKc1J1bnRpbWVUb1ByZXZlbnRNZW1vcnlMZWFrKHJlcyk7XG4gICAgICAgICAgaWYgKHJlcy5jYWNoZWRSZXNwb25zZUJvZHkgIT09IHZvaWQgMClcbiAgICAgICAgICAgIHJldHVybiByZXMuY2FjaGVkUmVzcG9uc2VCb2R5O1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihFUlJPUlMuVU5FWFBFQ1RFRCk7XG4gICAgICAgIH0sXG4gICAgICAgIChlcnJvcikgPT4ge1xuICAgICAgICAgIGlmIChpc0R5bmFtaWNTZXJ2ZXJFcnJvcihlcnJvcikpXG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRVJST1JTLk5FVFdPUkspO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cbiAgfTtcbn1cbnZhciBkZWZhdWx0RWRnZUNvbmZpZ0NsaWVudDtcbmZ1bmN0aW9uIGluaXQoKSB7XG4gIGlmICghZGVmYXVsdEVkZ2VDb25maWdDbGllbnQpIHtcbiAgICBkZWZhdWx0RWRnZUNvbmZpZ0NsaWVudCA9IGNyZWF0ZUNsaWVudChwcm9jZXNzLmVudi5FREdFX0NPTkZJRyk7XG4gIH1cbn1cbnZhciBnZXQgPSAoLi4uYXJncykgPT4ge1xuICBpbml0KCk7XG4gIHJldHVybiBkZWZhdWx0RWRnZUNvbmZpZ0NsaWVudC5nZXQoLi4uYXJncyk7XG59O1xudmFyIGdldEFsbCA9ICguLi5hcmdzKSA9PiB7XG4gIGluaXQoKTtcbiAgcmV0dXJuIGRlZmF1bHRFZGdlQ29uZmlnQ2xpZW50LmdldEFsbCguLi5hcmdzKTtcbn07XG52YXIgaGFzID0gKC4uLmFyZ3MpID0+IHtcbiAgaW5pdCgpO1xuICByZXR1cm4gZGVmYXVsdEVkZ2VDb25maWdDbGllbnQuaGFzKC4uLmFyZ3MpO1xufTtcbnZhciBkaWdlc3QgPSAoLi4uYXJncykgPT4ge1xuICBpbml0KCk7XG4gIHJldHVybiBkZWZhdWx0RWRnZUNvbmZpZ0NsaWVudC5kaWdlc3QoLi4uYXJncyk7XG59O1xuZXhwb3J0IHtcbiAgY3JlYXRlQ2xpZW50LFxuICBkaWdlc3QsXG4gIGdldCxcbiAgZ2V0QWxsLFxuICBoYXMsXG4gIHBhcnNlQ29ubmVjdGlvblN0cmluZ1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@vercel/edge-config/dist/index.js\n");

/***/ })

};
;